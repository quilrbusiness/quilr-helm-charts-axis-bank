id: identity-risk
name: Identity Risks
type: screen
enabled: true
version: 1.0.134
icon_url: https://staticcontent1.blob.core.windows.net/finding-icons/posture-ai-usage.svg
table_query:
  id: 82f39be8-e238-4a2e-bee3-5ecb6bd420a3
  name: Display Table Data
  queryString: null
  type: merge
  allowed_params: true
  allowed_body: true
  input_params:
    sample: value
  input_body: null
  dataSourceType: knowledgegraph
  sortOrder: desc
  sortColumn: lastseen
  limit: 10
  offset: 0
detailed_widget:
  - id: BID_05_detailed
    name: "MFA not supported Drilldown Table"
    input_params:
      appId: $appId
      behavior: $behavior
      group: AND toLower(group.displayName) IN [ x IN [$group] | toLower(x) ]
      department: AND toLower(department.name) IN [ x IN [$department] | toLower(x) ]
      appname: AND toLower(COALESCE(app.name, app.domain, app.id)) IN [ x IN [$appname] | toLower(x) ]
      app_category: AND toLower(app_category.name) IN [ x IN [$app_category] | toLower(x) ]
      criticality: AND toLower(COALESCE(has.criticality, app.criticality)) IN [ x IN [$criticality] | toLower(x) ]
      approval_status: AND toLower(has.approval_status) IN [ x IN [$approval_status] | toLower(x) ]
      password_hygiene: AND passwordHygiene[$password_hygiene] > 0
      mfa_status: AND CASE WHEN $mfa_status = 'null' THEN mfaStatus IS NULL ELSE mfaStatus[$mfa_status] > 0 END
    dataSourceType: "knowledgegraph"
    enabled: true
    allowed_params: true
    sortOrder: ""
    sortColumn: ""
    position: null
    template: null
    className: null
    multi_value_params:
      - id: appId
        delimiter: ","
      - id: group
        delimiter: ","
      - id: department
        delimiter: ","
      - id: appname
        delimiter: ","
      - id: app_category
        delimiter: ","
      - id: criticality
        delimiter: ","
      - id: approval_status
        delimiter: ","
    query: "MATCH (app:APPLICATION) WHERE app.id_ IN [$appId] 
            MATCH (app)<-[using_app:USING_APP]-(account:ACCOUNT {tenant: $tenant}) 
            MATCH (account)-[:HAS_FINDING]->(finding:FINDING)<-[:EVALUATED_TO]-(rule:RULE)-[:BELONGS_TO]->(behavior:BEHAVIOR {id: $behavior}) 
            MATCH (account)<-[auth_type]-(email:EMAIL)<-[:HAS_EMAIL]-(user:USER) 
            
            WITH app, account, email, user, 
                 COLLECT(DISTINCT auth_type) AS auth_types,
                 COLLECT(DISTINCT finding) AS findings,
                 COLLECT(DISTINCT rule) AS rules,
                 datetime.truncate('day', datetime() - duration('P1M')).epochMillis AS one_month_ago_epoch
            
            OPTIONAL MATCH (account)-[:HAS_CRED_FINGERPRINT]-(cred:CRED_FINGERPRINT)-[]-(same_password_account:ACCOUNT {tenant: $tenant}) 
            WHERE same_password_account <> account AND same_password_account.email = account.email
            
            WITH app, account, email, user, auth_types, findings, rules, one_month_ago_epoch,
                 COUNT(DISTINCT same_password_account.id) as passwordReuseCount,
                 SIZE(findings) AS findingCount
            
            UNWIND findings AS finding
            UNWIND rules AS rule
            WITH app, account, email, user, auth_types, passwordReuseCount, one_month_ago_epoch, finding, findingCount, rule
            WHERE (finding)<-[:EVALUATED_TO]-(rule)
            
            OPTIONAL MATCH (finding)-[:TRIGGERED]->(action:ACTION) 
            OPTIONAL MATCH (action)-[:RESULTED_IN]-(outcome:OUTCOME)
            OPTIONAL MATCH (action)-[:HAS_INTERACTION]->(interaction:INTERACTION)
            
            WITH app, account, email, user, auth_types, passwordReuseCount, one_month_ago_epoch, findingCount,
                 COLLECT(DISTINCT {
                   findingId: finding.id, 
                   ruleName: rule.name,
                   action: action.name, 
                   outcomeDesc: outcome.description, 
                   actionDesc: action.description, 
                   hasInteraction: CASE WHEN interaction IS NOT NULL THEN true ELSE false END 
                 }) AS findingData
            
            WITH app, account, email, user, auth_types, passwordReuseCount, one_month_ago_epoch, findingCount, findingData,
                 ANY(data IN findingData WHERE data.hasInteraction = true) AS interactionsExist,
                 apoc.map.fromPairs([data IN findingData WHERE data.action IS NOT NULL | [data.action, COALESCE(data.outcomeDesc, data.actionDesc)]]) AS actionCurrentState,
                 apoc.map.fromPairs([data IN findingData WHERE data.hasInteraction = true AND data.ruleName IS NOT NULL | [data.ruleName, true]]) AS ruleInteractionMap
            
            OPTIONAL MATCH (app)-[has:HAS_APP_SETTINGS]-(tenant:TENANT {id: $tenant}) 
            OPTIONAL MATCH (user)-[:HAS_DEPARTMENT]->(department:DEPARTMENT) 
            OPTIONAL MATCH (user)-[:BELONGS_TO]->(group:GROUP {userDefined: true}) 
            OPTIONAL MATCH (app)-[:HAS_APP_CATEGORY]->(app_category:APP_CATEGORY)
            
            CALL { 
              WITH account 
              MATCH (account)-[:HAS_FINDING]-(f)-[]-(:RULE)-[]-(b:BEHAVIOR) 
              WHERE b.id IN ['BID_06', 'BID_07', 'BID_08', 'BID_11'] 
              RETURN COUNT(DISTINCT CASE WHEN b.id = 'BID_06' THEN f.id END) AS noMFAUsed, 
                     COUNT(DISTINCT CASE WHEN b.id = 'BID_07' THEN f.id END) AS weakMFAUsed, 
                     COUNT(DISTINCT CASE WHEN b.id = 'BID_08' THEN f.id END) AS compromisedPasswords, 
                     COUNT(DISTINCT CASE WHEN b.id = 'BID_11' THEN f.id END) AS weakPasswords 
            }
            
            WITH email.id AS userMail,
                 user.displayName AS userName,
                 COALESCE(app.name, app.domain, app.id) AS appName,
                 user.profilePicUrl AS userProfilePicUrl,
                 app.logoUrl AS appLogoUrl,
                 has.approval_status AS appStatus,
                 account.id AS accountId,
                 app.isMfaSupported as isMfaSupported,
                 one_month_ago_epoch,
                 COLLECT(DISTINCT department.name) AS departments,
                 COLLECT(DISTINCT group.displayName) AS groups,
                 COLLECT(DISTINCT app_category.name) AS appCategories,
                 MAX(findingCount) AS totalFindingCount,
                 MAX(passwordReuseCount) AS totalPasswordReuseCount,
                 SUM(weakPasswords) AS totalWeakPasswords,
                 SUM(compromisedPasswords) AS totalCompromisedPasswords,
                 SUM(noMFAUsed) AS totalNoMFAUsed,
                 SUM(weakMFAUsed) AS totalWeakMFAUsed,
                 COLLECT(actionCurrentState) AS allActionStates,
                 COLLECT(ruleInteractionMap) AS allRuleInteractions,
                 apoc.coll.contains(COLLECT(interactionsExist), true) AS hasAnyInteractions,
                 apoc.coll.min([auth IN apoc.coll.flatten(COLLECT(auth_types)) | auth.creationTime]) AS firstAccessed,
                 apoc.coll.max([auth IN apoc.coll.flatten(COLLECT(auth_types)) | auth.last_access_time]) AS lastAccessed
            
            WHERE appName IS NOT NULL AND toLower(userMail) =~ toLower('.*{searchText}.*') 
                  {placeholder}
            
            RETURN userMail,
                   userName,
                   appName,
                   userProfilePicUrl,
                   departments,
                   groups,
                   appLogoUrl,
                   appCategories,
                   appStatus,
                   accountId,
                   firstAccessed AS firstAccessTime,
                   lastAccessed AS lastAccessTime,
                   totalFindingCount AS findingCount,
                   apoc.map.mergeList(allActionStates) AS actionCurrentState,
                   totalPasswordReuseCount AS passwordReuseCount,
                   apoc.map.fromPairs([
                     ['Weak Passwords', totalWeakPasswords], 
                     ['Compromised Passwords', totalCompromisedPasswords]
                   ]) AS passwordHygiene,
                   CASE 
                     WHEN isMfaSupported <> true THEN null 
                     ELSE apoc.map.fromPairs([
                       ['No MFA', totalNoMFAUsed], 
                       ['Weak MFA', totalWeakMFAUsed]
                     ])
                   END AS mfaStatus,
                   hasAnyInteractions AS interactionsExist,
                   apoc.map.mergeList(allRuleInteractions) AS ruleInteractionMap,
                   firstAccessed < one_month_ago_epoch AS newlyDiscovered
            ORDER BY lastAccessTime DESC"
    pagination_query: "MATCH (app:APPLICATION) WHERE app.id_ IN [$appId] 
                       MATCH (app)<-[using_app:USING_APP]-(account:ACCOUNT {tenant: $tenant}) 
                       MATCH (account)-[:HAS_FINDING]->(finding:FINDING)<-[:EVALUATED_TO]-(rule:RULE)-[:BELONGS_TO]->(behavior:BEHAVIOR {id: $behavior}) 
                       MATCH (account)<-[auth_type]-(email:EMAIL)<-[:HAS_EMAIL]-(user:USER) 
                       
                       WITH app, account, email, user, 
                            COLLECT(DISTINCT auth_type) AS auth_types,
                            COLLECT(DISTINCT finding) AS findings,
                            COLLECT(DISTINCT rule) AS rules,
                            datetime.truncate('day', datetime() - duration('P1M')).epochMillis AS one_month_ago_epoch
                       
                       OPTIONAL MATCH (account)-[:HAS_CRED_FINGERPRINT]-(cred:CRED_FINGERPRINT)-[]-(same_password_account:ACCOUNT {tenant: $tenant}) 
                       WHERE same_password_account <> account AND same_password_account.email = account.email
                       
                       WITH app, account, email, user, auth_types, findings, rules, one_month_ago_epoch,
                            COUNT(DISTINCT same_password_account.id) as passwordReuseCount,
                            SIZE(findings) AS findingCount
                       
                       UNWIND findings AS finding
                       UNWIND rules AS rule
                       WITH app, account, email, user, auth_types, passwordReuseCount, one_month_ago_epoch, finding, findingCount, rule
                       WHERE (finding)<-[:EVALUATED_TO]-(rule)
                       
                       OPTIONAL MATCH (finding)-[:TRIGGERED]->(action:ACTION) 
                       OPTIONAL MATCH (action)-[:RESULTED_IN]-(outcome:OUTCOME)
                       OPTIONAL MATCH (action)-[:HAS_INTERACTION]->(interaction:INTERACTION)
                       
                       WITH app, account, email, user, auth_types, passwordReuseCount, one_month_ago_epoch, findingCount,
                            COLLECT(DISTINCT {
                              findingId: finding.id, 
                              ruleName: rule.name,
                              action: action.name, 
                              outcomeDesc: outcome.description, 
                              actionDesc: action.description, 
                              hasInteraction: CASE WHEN interaction IS NOT NULL THEN true ELSE false END 
                            }) AS findingData
                       
                       WITH app, account, email, user, auth_types, passwordReuseCount, one_month_ago_epoch, findingCount, findingData,
                            ANY(data IN findingData WHERE data.hasInteraction = true) AS interactionsExist,
                            apoc.map.fromPairs([data IN findingData WHERE data.action IS NOT NULL | [data.action, COALESCE(data.outcomeDesc, data.actionDesc)]]) AS actionCurrentState,
                            apoc.map.fromPairs([data IN findingData WHERE data.hasInteraction = true AND data.ruleName IS NOT NULL | [data.ruleName, true]]) AS ruleInteractionMap
                       
                       OPTIONAL MATCH (app)-[has:HAS_APP_SETTINGS]-(tenant:TENANT {id: $tenant}) 
                       OPTIONAL MATCH (user)-[:HAS_DEPARTMENT]->(department:DEPARTMENT) 
                       OPTIONAL MATCH (user)-[:BELONGS_TO]->(group:GROUP {userDefined: true}) 
                       OPTIONAL MATCH (app)-[:HAS_APP_CATEGORY]->(app_category:APP_CATEGORY)
                       
                       CALL { 
                         WITH account 
                         MATCH (account)-[:HAS_FINDING]-(f)-[]-(:RULE)-[]-(b:BEHAVIOR) 
                         WHERE b.id IN ['BID_06', 'BID_07', 'BID_08', 'BID_11'] 
                         RETURN COUNT(DISTINCT CASE WHEN b.id = 'BID_06' THEN f.id END) AS noMFAUsed, 
                                COUNT(DISTINCT CASE WHEN b.id = 'BID_07' THEN f.id END) AS weakMFAUsed, 
                                COUNT(DISTINCT CASE WHEN b.id = 'BID_08' THEN f.id END) AS compromisedPasswords, 
                                COUNT(DISTINCT CASE WHEN b.id = 'BID_11' THEN f.id END) AS weakPasswords 
                       }
                       
                       WITH email.id AS userMail,
                            user.displayName AS userName,
                            COALESCE(app.name, app.domain, app.id) AS appName,
                            user.profilePicUrl AS userProfilePicUrl,
                            app.logoUrl AS appLogoUrl,
                            has.approval_status AS appStatus,
                            account.id AS accountId,
                            app.isMfaSupported as isMfaSupported,
                            one_month_ago_epoch,
                            COLLECT(DISTINCT department.name) AS departments,
                            COLLECT(DISTINCT group.displayName) AS groups,
                            COLLECT(DISTINCT app_category.name) AS appCategories,
                            MAX(findingCount) AS totalFindingCount,
                            MAX(passwordReuseCount) AS totalPasswordReuseCount,
                            SUM(weakPasswords) AS totalWeakPasswords,
                            SUM(compromisedPasswords) AS totalCompromisedPasswords,
                            SUM(noMFAUsed) AS totalNoMFAUsed,
                            SUM(weakMFAUsed) AS totalWeakMFAUsed,
                            COLLECT(actionCurrentState) AS allActionStates,
                            COLLECT(ruleInteractionMap) AS allRuleInteractions,
                            apoc.coll.contains(COLLECT(interactionsExist), true) AS hasAnyInteractions,
                            apoc.coll.min([auth IN apoc.coll.flatten(COLLECT(auth_types)) | auth.creationTime]) AS firstAccessed,
                            apoc.coll.max([auth IN apoc.coll.flatten(COLLECT(auth_types)) | auth.last_access_time]) AS lastAccessed
                       
                       WHERE appName IS NOT NULL AND toLower(userMail) =~ toLower('.*{searchText}.*') 
                             {placeholder}
                       
                       WITH userMail,
                              userName,
                              appName,
                              userProfilePicUrl,
                              departments,
                              groups,
                              appLogoUrl,
                              appCategories,
                              appStatus,
                              accountId,
                              firstAccessed AS firstAccessTime,
                              lastAccessed AS lastAccessTime,
                              totalFindingCount AS findingCount,
                              apoc.map.mergeList(allActionStates) AS actionCurrentState,
                              totalPasswordReuseCount AS passwordReuseCount,
                              apoc.map.fromPairs([
                                ['Weak Passwords', totalWeakPasswords], 
                                ['Compromised Passwords', totalCompromisedPasswords]
                              ]) AS passwordHygiene,
                              CASE 
                                WHEN isMfaSupported <> true THEN null 
                                ELSE apoc.map.fromPairs([
                                  ['No MFA', totalNoMFAUsed], 
                                  ['Weak MFA', totalWeakMFAUsed]
                                ])
                              END AS mfaStatus,
                              hasAnyInteractions AS interactionsExist,
                              apoc.map.mergeList(allRuleInteractions) AS ruleInteractionMap,
                              firstAccessed < one_month_ago_epoch AS newlyDiscovered
                              
                              RETURN COUNT(*) AS totalCount"
  - id: BID_06_detailed
    name: "No MFA used Drilldown Table"
    input_params:
      appId: $appId
      behavior: $behavior
      group: AND toLower(group.displayName) IN [ x IN [$group] | toLower(x) ]
      department: AND toLower(department.name) IN [ x IN [$department] | toLower(x) ]
      appname: AND toLower(COALESCE(app.name, app.domain, app.id)) IN [ x IN [$appname] | toLower(x) ]
      app_category: AND toLower(app_category.name) IN [ x IN [$app_category] | toLower(x) ]
      criticality: AND toLower(COALESCE(has.criticality, app.criticality)) IN [ x IN [$criticality] | toLower(x) ]
      approval_status: AND toLower(has.approval_status) IN [ x IN [$approval_status] | toLower(x) ]
      password_hygiene: AND passwordHygiene[$password_hygiene] > 0
      mfa_status: AND CASE WHEN $mfa_status = 'null' THEN mfaStatus IS NULL ELSE mfaStatus[$mfa_status] > 0 END
    dataSourceType: "knowledgegraph"
    enabled: true
    allowed_params: true
    sortOrder: ""
    sortColumn: ""
    position: null
    template: null
    className: null
    multi_value_params:
      - id: appId
        delimiter: ","
      - id: group
        delimiter: ","
      - id: department
        delimiter: ","
      - id: appname
        delimiter: ","
      - id: app_category
        delimiter: ","
      - id: criticality
        delimiter: ","
      - id: approval_status
        delimiter: ","
    query: "MATCH (app:APPLICATION) WHERE app.id_ IN [$appId] 
            MATCH (app)<-[using_app:USING_APP]-(account:ACCOUNT {tenant: $tenant}) 
            MATCH (account)-[:HAS_FINDING]->(finding:FINDING)<-[:EVALUATED_TO]-(rule:RULE)-[:BELONGS_TO]->(behavior:BEHAVIOR {id: $behavior}) 
            MATCH (account)<-[auth_type]-(email:EMAIL)<-[:HAS_EMAIL]-(user:USER) 

            WITH app, account, email, user, 
                 COLLECT(DISTINCT auth_type) AS auth_types,
                 COLLECT(DISTINCT finding) AS findings,
                 COLLECT(DISTINCT rule) AS rules,
                 datetime.truncate('day', datetime() - duration('P1M')).epochMillis AS one_month_ago_epoch

            OPTIONAL MATCH (account)-[:HAS_CRED_FINGERPRINT]-(cred:CRED_FINGERPRINT)-[]-(same_password_account:ACCOUNT {tenant: $tenant}) 
            WHERE same_password_account <> account AND same_password_account.email = account.email

            WITH app, account, email, user, auth_types, findings, rules, one_month_ago_epoch,
                 COUNT(DISTINCT same_password_account.id) as passwordReuseCount,
                 SIZE(findings) AS findingCount

            UNWIND findings AS finding
            UNWIND rules AS rule
            WITH app, account, email, user, auth_types, passwordReuseCount, one_month_ago_epoch, finding, findingCount, rule
            WHERE (finding)<-[:EVALUATED_TO]-(rule)

            OPTIONAL MATCH (finding)-[:TRIGGERED]->(action:ACTION) 
            OPTIONAL MATCH (action)-[:RESULTED_IN]-(outcome:OUTCOME)
            OPTIONAL MATCH (action)-[:HAS_INTERACTION]->(interaction:INTERACTION)

            WITH app, account, email, user, auth_types, passwordReuseCount, one_month_ago_epoch, findingCount,
                 COLLECT(DISTINCT {
                   findingId: finding.id, 
                   ruleName: rule.name,
                   action: action.name, 
                   outcomeDesc: outcome.description, 
                   actionDesc: action.description, 
                   hasInteraction: CASE WHEN interaction IS NOT NULL THEN true ELSE false END 
                 }) AS findingData

            WITH app, account, email, user, auth_types, passwordReuseCount, one_month_ago_epoch, findingCount, findingData,
                 ANY(data IN findingData WHERE data.hasInteraction = true) AS interactionsExist,
                 apoc.map.fromPairs([data IN findingData WHERE data.action IS NOT NULL | [data.action, COALESCE(data.outcomeDesc, data.actionDesc)]]) AS actionCurrentState,
                 apoc.map.fromPairs([data IN findingData WHERE data.hasInteraction = true AND data.ruleName IS NOT NULL | [data.ruleName, true]]) AS ruleInteractionMap

            OPTIONAL MATCH (app)-[has:HAS_APP_SETTINGS]-(tenant:TENANT {id: $tenant}) 
            OPTIONAL MATCH (user)-[:HAS_DEPARTMENT]->(department:DEPARTMENT) 
            OPTIONAL MATCH (user)-[:BELONGS_TO]->(group:GROUP {userDefined: true}) 
            OPTIONAL MATCH (app)-[:HAS_APP_CATEGORY]->(app_category:APP_CATEGORY)

            CALL { 
              WITH account 
              MATCH (account)-[:HAS_FINDING]-(f)-[]-(:RULE)-[]-(b:BEHAVIOR) 
              WHERE b.id IN ['BID_06', 'BID_07', 'BID_08', 'BID_11'] 
              RETURN COUNT(DISTINCT CASE WHEN b.id = 'BID_06' THEN f.id END) AS noMFAUsed, 
                     COUNT(DISTINCT CASE WHEN b.id = 'BID_07' THEN f.id END) AS weakMFAUsed, 
                     COUNT(DISTINCT CASE WHEN b.id = 'BID_08' THEN f.id END) AS compromisedPasswords, 
                     COUNT(DISTINCT CASE WHEN b.id = 'BID_11' THEN f.id END) AS weakPasswords 
            }

            WITH email.id AS userMail,
                 user.displayName AS userName,
                 COALESCE(app.name, app.domain, app.id) AS appName,
                 user.profilePicUrl AS userProfilePicUrl,
                 app.logoUrl AS appLogoUrl,
                 has.approval_status AS appStatus,
                 account.id AS accountId,
                 app.isMfaSupported as isMfaSupported,
                 one_month_ago_epoch,
                 COLLECT(DISTINCT department.name) AS departments,
                 COLLECT(DISTINCT group.displayName) AS groups,
                 COLLECT(DISTINCT app_category.name) AS appCategories,
                 MAX(findingCount) AS totalFindingCount,
                 MAX(passwordReuseCount) AS totalPasswordReuseCount,
                 SUM(weakPasswords) AS totalWeakPasswords,
                 SUM(compromisedPasswords) AS totalCompromisedPasswords,
                 SUM(noMFAUsed) AS totalNoMFAUsed,
                 SUM(weakMFAUsed) AS totalWeakMFAUsed,
                 COLLECT(actionCurrentState) AS allActionStates,
                 COLLECT(ruleInteractionMap) AS allRuleInteractions,
                 apoc.coll.contains(COLLECT(interactionsExist), true) AS hasAnyInteractions,
                 apoc.coll.min([auth IN apoc.coll.flatten(COLLECT(auth_types)) | auth.creationTime]) AS firstAccessed,
                 apoc.coll.max([auth IN apoc.coll.flatten(COLLECT(auth_types)) | auth.last_access_time]) AS lastAccessed

            WHERE appName IS NOT NULL AND toLower(userMail) =~ toLower('.*{searchText}.*') 
                  {placeholder}

            RETURN userMail,
                   userName,
                   appName,
                   userProfilePicUrl,
                   departments,
                   groups,
                   appLogoUrl,
                   appCategories,
                   appStatus,
                   accountId,
                   firstAccessed AS firstAccessTime,
                   lastAccessed AS lastAccessTime,
                   totalFindingCount AS findingCount,
                   apoc.map.mergeList(allActionStates) AS actionCurrentState,
                   totalPasswordReuseCount AS passwordReuseCount,
                   apoc.map.fromPairs([
                     ['Weak Passwords', totalWeakPasswords], 
                     ['Compromised Passwords', totalCompromisedPasswords]
                   ]) AS passwordHygiene,
                   CASE 
                     WHEN isMfaSupported <> true THEN null 
                     ELSE apoc.map.fromPairs([
                       ['No MFA', totalNoMFAUsed], 
                       ['Weak MFA', totalWeakMFAUsed]
                     ])
                   END AS mfaStatus,
                   hasAnyInteractions AS interactionsExist,
                   apoc.map.mergeList(allRuleInteractions) AS ruleInteractionMap,
                   firstAccessed < one_month_ago_epoch AS newlyDiscovered
            ORDER BY lastAccessTime DESC"
    pagination_query: "MATCH (app:APPLICATION) WHERE app.id_ IN [$appId] 
                       MATCH (app)<-[using_app:USING_APP]-(account:ACCOUNT {tenant: $tenant}) 
                       MATCH (account)-[:HAS_FINDING]->(finding:FINDING)<-[:EVALUATED_TO]-(rule:RULE)-[:BELONGS_TO]->(behavior:BEHAVIOR {id: $behavior}) 
                       MATCH (account)<-[auth_type]-(email:EMAIL)<-[:HAS_EMAIL]-(user:USER) 

                       WITH app, account, email, user, 
                            COLLECT(DISTINCT auth_type) AS auth_types,
                            COLLECT(DISTINCT finding) AS findings,
                            COLLECT(DISTINCT rule) AS rules,
                            datetime.truncate('day', datetime() - duration('P1M')).epochMillis AS one_month_ago_epoch

                       OPTIONAL MATCH (account)-[:HAS_CRED_FINGERPRINT]-(cred:CRED_FINGERPRINT)-[]-(same_password_account:ACCOUNT {tenant: $tenant}) 
                       WHERE same_password_account <> account AND same_password_account.email = account.email

                       WITH app, account, email, user, auth_types, findings, rules, one_month_ago_epoch,
                            COUNT(DISTINCT same_password_account.id) as passwordReuseCount,
                            SIZE(findings) AS findingCount

                       UNWIND findings AS finding
                       UNWIND rules AS rule
                       WITH app, account, email, user, auth_types, passwordReuseCount, one_month_ago_epoch, finding, findingCount, rule
                       WHERE (finding)<-[:EVALUATED_TO]-(rule)

                       OPTIONAL MATCH (finding)-[:TRIGGERED]->(action:ACTION) 
                       OPTIONAL MATCH (action)-[:RESULTED_IN]-(outcome:OUTCOME)
                       OPTIONAL MATCH (action)-[:HAS_INTERACTION]->(interaction:INTERACTION)

                       WITH app, account, email, user, auth_types, passwordReuseCount, one_month_ago_epoch, findingCount,
                            COLLECT(DISTINCT {
                              findingId: finding.id, 
                              ruleName: rule.name,
                              action: action.name, 
                              outcomeDesc: outcome.description, 
                              actionDesc: action.description, 
                              hasInteraction: CASE WHEN interaction IS NOT NULL THEN true ELSE false END 
                            }) AS findingData

                       WITH app, account, email, user, auth_types, passwordReuseCount, one_month_ago_epoch, findingCount, findingData,
                            ANY(data IN findingData WHERE data.hasInteraction = true) AS interactionsExist,
                            apoc.map.fromPairs([data IN findingData WHERE data.action IS NOT NULL | [data.action, COALESCE(data.outcomeDesc, data.actionDesc)]]) AS actionCurrentState,
                            apoc.map.fromPairs([data IN findingData WHERE data.hasInteraction = true AND data.ruleName IS NOT NULL | [data.ruleName, true]]) AS ruleInteractionMap

                       OPTIONAL MATCH (app)-[has:HAS_APP_SETTINGS]-(tenant:TENANT {id: $tenant}) 
                       OPTIONAL MATCH (user)-[:HAS_DEPARTMENT]->(department:DEPARTMENT) 
                       OPTIONAL MATCH (user)-[:BELONGS_TO]->(group:GROUP {userDefined: true}) 
                       OPTIONAL MATCH (app)-[:HAS_APP_CATEGORY]->(app_category:APP_CATEGORY)

                       CALL { 
                         WITH account 
                         MATCH (account)-[:HAS_FINDING]-(f)-[]-(:RULE)-[]-(b:BEHAVIOR) 
                         WHERE b.id IN ['BID_06', 'BID_07', 'BID_08', 'BID_11'] 
                         RETURN COUNT(DISTINCT CASE WHEN b.id = 'BID_06' THEN f.id END) AS noMFAUsed, 
                                COUNT(DISTINCT CASE WHEN b.id = 'BID_07' THEN f.id END) AS weakMFAUsed, 
                                COUNT(DISTINCT CASE WHEN b.id = 'BID_08' THEN f.id END) AS compromisedPasswords, 
                                COUNT(DISTINCT CASE WHEN b.id = 'BID_11' THEN f.id END) AS weakPasswords 
                       }

                       WITH email.id AS userMail,
                            user.displayName AS userName,
                            COALESCE(app.name, app.domain, app.id) AS appName,
                            user.profilePicUrl AS userProfilePicUrl,
                            app.logoUrl AS appLogoUrl,
                            has.approval_status AS appStatus,
                            account.id AS accountId,
                            app.isMfaSupported as isMfaSupported,
                            one_month_ago_epoch,
                            COLLECT(DISTINCT department.name) AS departments,
                            COLLECT(DISTINCT group.displayName) AS groups,
                            COLLECT(DISTINCT app_category.name) AS appCategories,
                            MAX(findingCount) AS totalFindingCount,
                            MAX(passwordReuseCount) AS totalPasswordReuseCount,
                            SUM(weakPasswords) AS totalWeakPasswords,
                            SUM(compromisedPasswords) AS totalCompromisedPasswords,
                            SUM(noMFAUsed) AS totalNoMFAUsed,
                            SUM(weakMFAUsed) AS totalWeakMFAUsed,
                            COLLECT(actionCurrentState) AS allActionStates,
                            COLLECT(ruleInteractionMap) AS allRuleInteractions,
                            apoc.coll.contains(COLLECT(interactionsExist), true) AS hasAnyInteractions,
                            apoc.coll.min([auth IN apoc.coll.flatten(COLLECT(auth_types)) | auth.creationTime]) AS firstAccessed,
                            apoc.coll.max([auth IN apoc.coll.flatten(COLLECT(auth_types)) | auth.last_access_time]) AS lastAccessed

                       WHERE appName IS NOT NULL AND toLower(userMail) =~ toLower('.*{searchText}.*') 
                             {placeholder}

                       WITH userMail,
                              userName,
                              appName,
                              userProfilePicUrl,
                              departments,
                              groups,
                              appLogoUrl,
                              appCategories,
                              appStatus,
                              accountId,
                              firstAccessed AS firstAccessTime,
                              lastAccessed AS lastAccessTime,
                              totalFindingCount AS findingCount,
                              apoc.map.mergeList(allActionStates) AS actionCurrentState,
                              totalPasswordReuseCount AS passwordReuseCount,
                              apoc.map.fromPairs([
                                ['Weak Passwords', totalWeakPasswords], 
                                ['Compromised Passwords', totalCompromisedPasswords]
                              ]) AS passwordHygiene,
                              CASE 
                                WHEN isMfaSupported <> true THEN null 
                                ELSE apoc.map.fromPairs([
                                  ['No MFA', totalNoMFAUsed], 
                                  ['Weak MFA', totalWeakMFAUsed]
                                ])
                              END AS mfaStatus,
                              hasAnyInteractions AS interactionsExist,
                              apoc.map.mergeList(allRuleInteractions) AS ruleInteractionMap,
                              firstAccessed < one_month_ago_epoch AS newlyDiscovered

                              RETURN COUNT(*) AS totalCount"
  - id: BID_07_detailed
    name: "Weak MFA used Drilldown Table"
    input_params:
      appId: $appId
      behavior: $behavior
      group: AND toLower(group.displayName) IN [ x IN [$group] | toLower(x) ]
      department: AND toLower(department.name) IN [ x IN [$department] | toLower(x) ]
      appname: AND toLower(COALESCE(app.name, app.domain, app.id)) IN [ x IN [$appname] | toLower(x) ]
      app_category: AND toLower(app_category.name) IN [ x IN [$app_category] | toLower(x) ]
      criticality: AND toLower(COALESCE(has.criticality, app.criticality)) IN [ x IN [$criticality] | toLower(x) ]
      approval_status: AND toLower(has.approval_status) IN [ x IN [$approval_status] | toLower(x) ]
      password_hygiene: AND passwordHygiene[$password_hygiene] > 0
      mfa_status: AND CASE WHEN $mfa_status = 'null' THEN mfaStatus IS NULL ELSE mfaStatus[$mfa_status] > 0 END
    dataSourceType: "knowledgegraph"
    enabled: true
    allowed_params: true
    sortOrder: ""
    sortColumn: ""
    position: null
    template: null
    className: null
    multi_value_params:
      - id: appId
        delimiter: ","
      - id: group
        delimiter: ","
      - id: department
        delimiter: ","
      - id: appname
        delimiter: ","
      - id: app_category
        delimiter: ","
      - id: criticality
        delimiter: ","
      - id: approval_status
        delimiter: ","
    query: "MATCH (app:APPLICATION) WHERE app.id_ IN [$appId] 
            MATCH (app)<-[using_app:USING_APP]-(account:ACCOUNT {tenant: $tenant}) 
            MATCH (account)-[:HAS_FINDING]->(finding:FINDING)<-[:EVALUATED_TO]-(rule:RULE)-[:BELONGS_TO]->(behavior:BEHAVIOR {id: $behavior}) 
            MATCH (account)<-[auth_type]-(email:EMAIL)<-[:HAS_EMAIL]-(user:USER) 

            WITH app, account, email, user, 
                 COLLECT(DISTINCT auth_type) AS auth_types,
                 COLLECT(DISTINCT finding) AS findings,
                 COLLECT(DISTINCT rule) AS rules,
                 datetime.truncate('day', datetime() - duration('P1M')).epochMillis AS one_month_ago_epoch

            OPTIONAL MATCH (account)-[:HAS_CRED_FINGERPRINT]-(cred:CRED_FINGERPRINT)-[]-(same_password_account:ACCOUNT {tenant: $tenant}) 
            WHERE same_password_account <> account AND same_password_account.email = account.email

            WITH app, account, email, user, auth_types, findings, rules, one_month_ago_epoch,
                 COUNT(DISTINCT same_password_account.id) as passwordReuseCount,
                 SIZE(findings) AS findingCount

            UNWIND findings AS finding
            UNWIND rules AS rule
            WITH app, account, email, user, auth_types, passwordReuseCount, one_month_ago_epoch, finding, findingCount, rule
            WHERE (finding)<-[:EVALUATED_TO]-(rule)

            OPTIONAL MATCH (finding)-[:TRIGGERED]->(action:ACTION) 
            OPTIONAL MATCH (action)-[:RESULTED_IN]-(outcome:OUTCOME)
            OPTIONAL MATCH (action)-[:HAS_INTERACTION]->(interaction:INTERACTION)

            WITH app, account, email, user, auth_types, passwordReuseCount, one_month_ago_epoch, findingCount,
                 COLLECT(DISTINCT {
                   findingId: finding.id, 
                   ruleName: rule.name,
                   action: action.name, 
                   outcomeDesc: outcome.description, 
                   actionDesc: action.description, 
                   hasInteraction: CASE WHEN interaction IS NOT NULL THEN true ELSE false END 
                 }) AS findingData

            WITH app, account, email, user, auth_types, passwordReuseCount, one_month_ago_epoch, findingCount, findingData,
                 ANY(data IN findingData WHERE data.hasInteraction = true) AS interactionsExist,
                 apoc.map.fromPairs([data IN findingData WHERE data.action IS NOT NULL | [data.action, COALESCE(data.outcomeDesc, data.actionDesc)]]) AS actionCurrentState,
                 apoc.map.fromPairs([data IN findingData WHERE data.hasInteraction = true AND data.ruleName IS NOT NULL | [data.ruleName, true]]) AS ruleInteractionMap

            OPTIONAL MATCH (app)-[has:HAS_APP_SETTINGS]-(tenant:TENANT {id: $tenant}) 
            OPTIONAL MATCH (user)-[:HAS_DEPARTMENT]->(department:DEPARTMENT) 
            OPTIONAL MATCH (user)-[:BELONGS_TO]->(group:GROUP {userDefined: true}) 
            OPTIONAL MATCH (app)-[:HAS_APP_CATEGORY]->(app_category:APP_CATEGORY)

            CALL { 
              WITH account 
              MATCH (account)-[:HAS_FINDING]-(f)-[]-(:RULE)-[]-(b:BEHAVIOR) 
              WHERE b.id IN ['BID_06', 'BID_07', 'BID_08', 'BID_11'] 
              RETURN COUNT(DISTINCT CASE WHEN b.id = 'BID_06' THEN f.id END) AS noMFAUsed, 
                     COUNT(DISTINCT CASE WHEN b.id = 'BID_07' THEN f.id END) AS weakMFAUsed, 
                     COUNT(DISTINCT CASE WHEN b.id = 'BID_08' THEN f.id END) AS compromisedPasswords, 
                     COUNT(DISTINCT CASE WHEN b.id = 'BID_11' THEN f.id END) AS weakPasswords 
            }

            WITH email.id AS userMail,
                 user.displayName AS userName,
                 COALESCE(app.name, app.domain, app.id) AS appName,
                 user.profilePicUrl AS userProfilePicUrl,
                 app.logoUrl AS appLogoUrl,
                 has.approval_status AS appStatus,
                 account.id AS accountId,
                 app.isMfaSupported as isMfaSupported,
                 one_month_ago_epoch,
                 COLLECT(DISTINCT department.name) AS departments,
                 COLLECT(DISTINCT group.displayName) AS groups,
                 COLLECT(DISTINCT app_category.name) AS appCategories,
                 MAX(findingCount) AS totalFindingCount,
                 MAX(passwordReuseCount) AS totalPasswordReuseCount,
                 SUM(weakPasswords) AS totalWeakPasswords,
                 SUM(compromisedPasswords) AS totalCompromisedPasswords,
                 SUM(noMFAUsed) AS totalNoMFAUsed,
                 SUM(weakMFAUsed) AS totalWeakMFAUsed,
                 COLLECT(actionCurrentState) AS allActionStates,
                 COLLECT(ruleInteractionMap) AS allRuleInteractions,
                 apoc.coll.contains(COLLECT(interactionsExist), true) AS hasAnyInteractions,
                 apoc.coll.min([auth IN apoc.coll.flatten(COLLECT(auth_types)) | auth.creationTime]) AS firstAccessed,
                 apoc.coll.max([auth IN apoc.coll.flatten(COLLECT(auth_types)) | auth.last_access_time]) AS lastAccessed

            WHERE appName IS NOT NULL AND toLower(userMail) =~ toLower('.*{searchText}.*') 
                  {placeholder}

            RETURN userMail,
                   userName,
                   appName,
                   userProfilePicUrl,
                   departments,
                   groups,
                   appLogoUrl,
                   appCategories,
                   appStatus,
                   accountId,
                   firstAccessed AS firstAccessTime,
                   lastAccessed AS lastAccessTime,
                   totalFindingCount AS findingCount,
                   apoc.map.mergeList(allActionStates) AS actionCurrentState,
                   totalPasswordReuseCount AS passwordReuseCount,
                   apoc.map.fromPairs([
                     ['Weak Passwords', totalWeakPasswords], 
                     ['Compromised Passwords', totalCompromisedPasswords]
                   ]) AS passwordHygiene,
                   CASE 
                     WHEN isMfaSupported <> true THEN null 
                     ELSE apoc.map.fromPairs([
                       ['No MFA', totalNoMFAUsed], 
                       ['Weak MFA', totalWeakMFAUsed]
                     ])
                   END AS mfaStatus,
                   hasAnyInteractions AS interactionsExist,
                   apoc.map.mergeList(allRuleInteractions) AS ruleInteractionMap,
                   firstAccessed < one_month_ago_epoch AS newlyDiscovered
            ORDER BY lastAccessTime DESC"
    pagination_query: "MATCH (app:APPLICATION) WHERE app.id_ IN [$appId] 
                       MATCH (app)<-[using_app:USING_APP]-(account:ACCOUNT {tenant: $tenant}) 
                       MATCH (account)-[:HAS_FINDING]->(finding:FINDING)<-[:EVALUATED_TO]-(rule:RULE)-[:BELONGS_TO]->(behavior:BEHAVIOR {id: $behavior}) 
                       MATCH (account)<-[auth_type]-(email:EMAIL)<-[:HAS_EMAIL]-(user:USER) 

                       WITH app, account, email, user, 
                            COLLECT(DISTINCT auth_type) AS auth_types,
                            COLLECT(DISTINCT finding) AS findings,
                            COLLECT(DISTINCT rule) AS rules,
                            datetime.truncate('day', datetime() - duration('P1M')).epochMillis AS one_month_ago_epoch

                       OPTIONAL MATCH (account)-[:HAS_CRED_FINGERPRINT]-(cred:CRED_FINGERPRINT)-[]-(same_password_account:ACCOUNT {tenant: $tenant}) 
                       WHERE same_password_account <> account AND same_password_account.email = account.email

                       WITH app, account, email, user, auth_types, findings, rules, one_month_ago_epoch,
                            COUNT(DISTINCT same_password_account.id) as passwordReuseCount,
                            SIZE(findings) AS findingCount

                       UNWIND findings AS finding
                       UNWIND rules AS rule
                       WITH app, account, email, user, auth_types, passwordReuseCount, one_month_ago_epoch, finding, findingCount, rule
                       WHERE (finding)<-[:EVALUATED_TO]-(rule)

                       OPTIONAL MATCH (finding)-[:TRIGGERED]->(action:ACTION) 
                       OPTIONAL MATCH (action)-[:RESULTED_IN]-(outcome:OUTCOME)
                       OPTIONAL MATCH (action)-[:HAS_INTERACTION]->(interaction:INTERACTION)

                       WITH app, account, email, user, auth_types, passwordReuseCount, one_month_ago_epoch, findingCount,
                            COLLECT(DISTINCT {
                              findingId: finding.id, 
                              ruleName: rule.name,
                              action: action.name, 
                              outcomeDesc: outcome.description, 
                              actionDesc: action.description, 
                              hasInteraction: CASE WHEN interaction IS NOT NULL THEN true ELSE false END 
                            }) AS findingData

                       WITH app, account, email, user, auth_types, passwordReuseCount, one_month_ago_epoch, findingCount, findingData,
                            ANY(data IN findingData WHERE data.hasInteraction = true) AS interactionsExist,
                            apoc.map.fromPairs([data IN findingData WHERE data.action IS NOT NULL | [data.action, COALESCE(data.outcomeDesc, data.actionDesc)]]) AS actionCurrentState,
                            apoc.map.fromPairs([data IN findingData WHERE data.hasInteraction = true AND data.ruleName IS NOT NULL | [data.ruleName, true]]) AS ruleInteractionMap

                       OPTIONAL MATCH (app)-[has:HAS_APP_SETTINGS]-(tenant:TENANT {id: $tenant}) 
                       OPTIONAL MATCH (user)-[:HAS_DEPARTMENT]->(department:DEPARTMENT) 
                       OPTIONAL MATCH (user)-[:BELONGS_TO]->(group:GROUP {userDefined: true}) 
                       OPTIONAL MATCH (app)-[:HAS_APP_CATEGORY]->(app_category:APP_CATEGORY)

                       CALL { 
                         WITH account 
                         MATCH (account)-[:HAS_FINDING]-(f)-[]-(:RULE)-[]-(b:BEHAVIOR) 
                         WHERE b.id IN ['BID_06', 'BID_07', 'BID_08', 'BID_11'] 
                         RETURN COUNT(DISTINCT CASE WHEN b.id = 'BID_06' THEN f.id END) AS noMFAUsed, 
                                COUNT(DISTINCT CASE WHEN b.id = 'BID_07' THEN f.id END) AS weakMFAUsed, 
                                COUNT(DISTINCT CASE WHEN b.id = 'BID_08' THEN f.id END) AS compromisedPasswords, 
                                COUNT(DISTINCT CASE WHEN b.id = 'BID_11' THEN f.id END) AS weakPasswords 
                       }

                       WITH email.id AS userMail,
                            user.displayName AS userName,
                            COALESCE(app.name, app.domain, app.id) AS appName,
                            user.profilePicUrl AS userProfilePicUrl,
                            app.logoUrl AS appLogoUrl,
                            has.approval_status AS appStatus,
                            account.id AS accountId,
                            app.isMfaSupported as isMfaSupported,
                            one_month_ago_epoch,
                            COLLECT(DISTINCT department.name) AS departments,
                            COLLECT(DISTINCT group.displayName) AS groups,
                            COLLECT(DISTINCT app_category.name) AS appCategories,
                            MAX(findingCount) AS totalFindingCount,
                            MAX(passwordReuseCount) AS totalPasswordReuseCount,
                            SUM(weakPasswords) AS totalWeakPasswords,
                            SUM(compromisedPasswords) AS totalCompromisedPasswords,
                            SUM(noMFAUsed) AS totalNoMFAUsed,
                            SUM(weakMFAUsed) AS totalWeakMFAUsed,
                            COLLECT(actionCurrentState) AS allActionStates,
                            COLLECT(ruleInteractionMap) AS allRuleInteractions,
                            apoc.coll.contains(COLLECT(interactionsExist), true) AS hasAnyInteractions,
                            apoc.coll.min([auth IN apoc.coll.flatten(COLLECT(auth_types)) | auth.creationTime]) AS firstAccessed,
                            apoc.coll.max([auth IN apoc.coll.flatten(COLLECT(auth_types)) | auth.last_access_time]) AS lastAccessed

                       WHERE appName IS NOT NULL AND toLower(userMail) =~ toLower('.*{searchText}.*') 
                             {placeholder}

                       WITH userMail,
                              userName,
                              appName,
                              userProfilePicUrl,
                              departments,
                              groups,
                              appLogoUrl,
                              appCategories,
                              appStatus,
                              accountId,
                              firstAccessed AS firstAccessTime,
                              lastAccessed AS lastAccessTime,
                              totalFindingCount AS findingCount,
                              apoc.map.mergeList(allActionStates) AS actionCurrentState,
                              totalPasswordReuseCount AS passwordReuseCount,
                              apoc.map.fromPairs([
                                ['Weak Passwords', totalWeakPasswords], 
                                ['Compromised Passwords', totalCompromisedPasswords]
                              ]) AS passwordHygiene,
                              CASE 
                                WHEN isMfaSupported <> true THEN null 
                                ELSE apoc.map.fromPairs([
                                  ['No MFA', totalNoMFAUsed], 
                                  ['Weak MFA', totalWeakMFAUsed]
                                ])
                              END AS mfaStatus,
                              hasAnyInteractions AS interactionsExist,
                              apoc.map.mergeList(allRuleInteractions) AS ruleInteractionMap,
                              firstAccessed < one_month_ago_epoch AS newlyDiscovered

                              RETURN COUNT(*) AS totalCount"
  - id: BID_08_detailed
    name: "Compromised Password Drilldown Table"
    input_params:
      appId: $appId
      behavior: $behavior
      group: AND toLower(group.displayName) IN [ x IN [$group] | toLower(x) ]
      department: AND toLower(department.name) IN [ x IN [$department] | toLower(x) ]
      appname: AND toLower(COALESCE(app.name, app.domain, app.id)) IN [ x IN [$appname] | toLower(x) ]
      app_category: AND toLower(app_category.name) IN [ x IN [$app_category] | toLower(x) ]
      criticality: AND toLower(COALESCE(has.criticality, app.criticality)) IN [ x IN [$criticality] | toLower(x) ]
      approval_status: AND toLower(has.approval_status) IN [ x IN [$approval_status] | toLower(x) ]
      password_hygiene: AND passwordHygiene[$password_hygiene] > 0
      mfa_status: AND CASE WHEN $mfa_status = 'null' THEN mfaStatus IS NULL ELSE mfaStatus[$mfa_status] > 0 END
    dataSourceType: "knowledgegraph"
    enabled: true
    allowed_params: true
    sortOrder: ""
    sortColumn: ""
    position: null
    template: null
    className: null
    multi_value_params:
      - id: appId
        delimiter: ","
      - id: group
        delimiter: ","
      - id: department
        delimiter: ","
      - id: appname
        delimiter: ","
      - id: app_category
        delimiter: ","
      - id: criticality
        delimiter: ","
      - id: approval_status
        delimiter: ","
    query: "MATCH (app:APPLICATION)
            WHERE app.id_ IN [$appId]
            MATCH (app)<-[using_app:USING_APP]-(account:ACCOUNT {tenant: $tenant})
            MATCH (account)-[:HAS_FINDING]->(finding:FINDING)<-[:EVALUATED_TO]-(rule:RULE)-[:BELONGS_TO]->(behavior:BEHAVIOR {id: $behavior})
            MATCH (account)<-[auth_type]-(email:EMAIL)<-[:HAS_EMAIL]-(user:USER)
            
            WITH app, account, email, user,
                 COLLECT(DISTINCT auth_type) AS auth_types,
                 COLLECT(DISTINCT finding) AS findings,
                 COLLECT(DISTINCT rule) AS rules,
                 datetime.truncate('day', datetime() - duration('P1M')).epochMillis AS one_month_ago_epoch
            
            OPTIONAL MATCH (account)-[:HAS_CRED_FINGERPRINT]-(cred:CRED_FINGERPRINT)-[]-(same_password_account:ACCOUNT {tenant: $tenant})
            WHERE same_password_account <> account AND same_password_account.email = account.email
            
            WITH app, account, email, user, auth_types, findings, rules, one_month_ago_epoch,
                 COUNT(DISTINCT same_password_account.id) as passwordReuseCount
            
            OPTIONAL MATCH (app)-[has:HAS_APP_SETTINGS]-(tenant:TENANT {id: $tenant})
            OPTIONAL MATCH (user)-[:HAS_DEPARTMENT]->(department:DEPARTMENT)
            OPTIONAL MATCH (user)-[:BELONGS_TO]->(group:GROUP {userDefined: true})
            OPTIONAL MATCH (app)-[:HAS_APP_CATEGORY]->(app_category:APP_CATEGORY)
            
            CALL {
                WITH account
                MATCH (account)-[:HAS_FINDING]-(f)-[]-(:RULE)-[]-(b:BEHAVIOR)
                WHERE b.id IN ['BID_06', 'BID_07', 'BID_08', 'BID_11']
                RETURN
                    COUNT(DISTINCT CASE WHEN b.id = 'BID_06' THEN f.id END) AS noMFAUsed,
                    COUNT(DISTINCT CASE WHEN b.id = 'BID_07' THEN f.id END) AS weakMFAUsed,
                    COUNT(DISTINCT CASE WHEN b.id = 'BID_08' THEN f.id END) AS compromisedPasswords,
                    COUNT(DISTINCT CASE WHEN b.id = 'BID_11' THEN f.id END) AS weakPasswords
            }
            
            UNWIND findings AS finding
            UNWIND rules AS rule
            WITH app, has, department, group, app_category, account, auth_types, email, user, 
                 passwordReuseCount, one_month_ago_epoch, finding, rule,
                 weakPasswords, compromisedPasswords, app.isMfaSupported as isMfaSupported, noMFAUsed, weakMFAUsed
            WHERE (finding)<-[:EVALUATED_TO]-(rule)
            
            OPTIONAL MATCH (finding)-[:TRIGGERED]->(action:ACTION)
            OPTIONAL MATCH (action)-[:RESULTED_IN]-(outcome:OUTCOME)
            OPTIONAL MATCH (action)-[:HAS_INTERACTION]->(interaction:INTERACTION)
            
            WITH app, has, department, group, app_category, account, auth_types, email, user,
                 passwordReuseCount, one_month_ago_epoch, isMfaSupported,
                 weakPasswords, compromisedPasswords, noMFAUsed, weakMFAUsed,
                 COUNT(DISTINCT finding.id) AS findingCount,
                 COLLECT(DISTINCT {
                     findingId: finding.id,
                     ruleName: rule.name,
                     action: action.name,
                     outcomeDesc: outcome.description,
                     actionDesc: action.description,
                     hasInteraction: CASE WHEN interaction IS NOT NULL THEN true ELSE false END
                 }) AS findingData
            
            WITH app, has, department, group, app_category, account, auth_types, email, user,
                 passwordReuseCount, one_month_ago_epoch, findingCount, findingData, isMfaSupported,
                 weakPasswords, compromisedPasswords, noMFAUsed, weakMFAUsed,
                 ANY(data IN findingData WHERE data.hasInteraction = true) AS interactionsExist,
                 apoc.map.fromPairs([data IN findingData WHERE data.action IS NOT NULL | [data.action, COALESCE(data.outcomeDesc, data.actionDesc)]]) AS actionCurrentState,
                 apoc.map.fromPairs([data IN findingData WHERE data.hasInteraction = true AND data.ruleName IS NOT NULL | [data.ruleName, true]]) AS ruleInteractionMap
            
            WITH app, has, department, group, app_category, account, auth_types, email, user,
                 passwordReuseCount, one_month_ago_epoch, findingCount, findingData, actionCurrentState, 
                 interactionsExist, ruleInteractionMap, isMfaSupported, weakPasswords, compromisedPasswords, noMFAUsed, weakMFAUsed,
                 (EXISTS((app)-[:WHITELISTED_FOR]->(:BEHAVIOR {id: $behavior})) OR EXISTS((account)-[:WHITELISTED_FOR]->(:BEHAVIOR {id: $behavior}))) AS is_whitelisted
            
            WHERE app.name IS NOT NULL AND toLower(email.id) =~ toLower('.*{searchText}.*')
            {placeholder}
            
            WITH email.id AS userMail,
                 user.displayName AS userName,
                 COALESCE(app.name, app.domain, app.id) AS appName,
                 user.profilePicUrl AS userProfilePicUrl,
                 app.logoUrl AS appLogoUrl,
                 has.approval_status AS appStatus,
                 account.id AS accountId,
                 app.id_ as appId,
                 is_whitelisted,
                 one_month_ago_epoch,
                 isMfaSupported,
                 COLLECT(DISTINCT department.name) AS departments,
                 COLLECT(DISTINCT group.displayName) AS groups,
                 COLLECT(DISTINCT app_category.name) AS appCategories,
                 MAX(findingCount) AS totalFindingCount,
                 MAX(passwordReuseCount) AS totalPasswordReuseCount,
                 MAX(weakPasswords) AS totalWeakPasswords,
                 MAX(compromisedPasswords) AS totalCompromisedPasswords,
                 MAX(noMFAUsed) AS totalNoMFAUsed,
                 MAX(weakMFAUsed) AS totalWeakMFAUsed,
                 apoc.map.mergeList(COLLECT(actionCurrentState)) AS finalActionCurrentState,
                 apoc.map.mergeList(COLLECT(ruleInteractionMap)) AS finalRuleInteractionMap,
                 apoc.coll.contains(COLLECT(interactionsExist), true) AS hasAnyInteractions,
                 apoc.coll.flatten(COLLECT(auth_types)) AS allAuthTypes,
                 MIN(CASE WHEN account.creationTime = '-' THEN NULL ELSE account.creationTime END) AS firstAccessTime,
                 apoc.coll.contains([auth IN apoc.coll.flatten(COLLECT(auth_types)) | auth.creationTime < one_month_ago_epoch], true) AS newlyDiscovered
            
            WITH userMail, userName, appName, userProfilePicUrl, appLogoUrl, appStatus, accountId, appId, is_whitelisted, one_month_ago_epoch,
                 departments, groups, appCategories, totalFindingCount, totalPasswordReuseCount, totalWeakPasswords, totalCompromisedPasswords,
                 totalNoMFAUsed, totalWeakMFAUsed, finalActionCurrentState, finalRuleInteractionMap, hasAnyInteractions, allAuthTypes,
                 firstAccessTime, newlyDiscovered, isMfaSupported,
                 apoc.coll.max([auth IN allAuthTypes | COALESCE(auth.last_access_time, 0)]) AS lastAccessTime
            
            RETURN userMail,
                   userName,
                   appName,
                   userProfilePicUrl,
                   departments,
                   groups,
                   is_whitelisted,
                   accountId,
                   appId,
                   appLogoUrl,
                   appCategories,
                   appStatus,
                   firstAccessTime,
                   lastAccessTime,
                   totalFindingCount AS findingCount,
                   finalActionCurrentState AS actionCurrentState,
                   totalPasswordReuseCount AS passwordReuseCount,
                   apoc.map.fromPairs([
                       ['Weak Passwords', totalWeakPasswords],
                       ['Compromised Passwords', totalCompromisedPasswords]
                   ]) AS passwordHygiene,
                   CASE
                       WHEN isMfaSupported <> true THEN null
                       ELSE apoc.map.fromPairs([
                           ['No MFA', totalNoMFAUsed],
                           ['Weak MFA', totalWeakMFAUsed]
                       ])
                   END AS mfaStatus,
                   hasAnyInteractions AS interactionsExist,
                   finalRuleInteractionMap AS ruleInteractionMap,
                   newlyDiscovered
            ORDER BY lastAccessTime DESC"
    pagination_query: "MATCH (app:APPLICATION)
             WHERE app.id_ IN [$appId]
             MATCH (app)<-[using_app:USING_APP]-(account:ACCOUNT {tenant: $tenant})
             MATCH (account)-[:HAS_FINDING]->(finding:FINDING)<-[:EVALUATED_TO]-(rule:RULE)-[:BELONGS_TO]->(behavior:BEHAVIOR {id: $behavior})
             MATCH (account)<-[auth_type]-(email:EMAIL)<-[:HAS_EMAIL]-(user:USER)
             
             WITH app, account, email, user,
                  COLLECT(DISTINCT auth_type) AS auth_types,
                  COLLECT(DISTINCT finding) AS findings,
                  COLLECT(DISTINCT rule) AS rules,
                  datetime.truncate('day', datetime() - duration('P1M')).epochMillis AS one_month_ago_epoch
             
             OPTIONAL MATCH (account)-[:HAS_CRED_FINGERPRINT]-(cred:CRED_FINGERPRINT)-[]-(same_password_account:ACCOUNT {tenant: $tenant})
             WHERE same_password_account <> account AND same_password_account.email = account.email
             
             WITH app, account, email, user, auth_types, findings, rules, one_month_ago_epoch,
                  COUNT(DISTINCT same_password_account.id) as passwordReuseCount
             
             OPTIONAL MATCH (app)-[has:HAS_APP_SETTINGS]-(tenant:TENANT {id: $tenant})
             OPTIONAL MATCH (user)-[:HAS_DEPARTMENT]->(department:DEPARTMENT)
             OPTIONAL MATCH (user)-[:BELONGS_TO]->(group:GROUP {userDefined: true})
             OPTIONAL MATCH (app)-[:HAS_APP_CATEGORY]->(app_category:APP_CATEGORY)
             
             CALL {
                 WITH account
                 MATCH (account)-[:HAS_FINDING]-(f)-[]-(:RULE)-[]-(b:BEHAVIOR)
                 WHERE b.id IN ['BID_06', 'BID_07', 'BID_08', 'BID_11']
                 RETURN
                     COUNT(DISTINCT CASE WHEN b.id = 'BID_06' THEN f.id END) AS noMFAUsed,
                     COUNT(DISTINCT CASE WHEN b.id = 'BID_07' THEN f.id END) AS weakMFAUsed,
                     COUNT(DISTINCT CASE WHEN b.id = 'BID_08' THEN f.id END) AS compromisedPasswords,
                     COUNT(DISTINCT CASE WHEN b.id = 'BID_11' THEN f.id END) AS weakPasswords
             }
             
             UNWIND findings AS finding
             UNWIND rules AS rule
             WITH app, has, department, group, app_category, account, auth_types, email, user, 
                  passwordReuseCount, one_month_ago_epoch, finding, rule,
                  weakPasswords, compromisedPasswords, app.isMfaSupported as isMfaSupported, noMFAUsed, weakMFAUsed
             WHERE (finding)<-[:EVALUATED_TO]-(rule)
             
             OPTIONAL MATCH (finding)-[:TRIGGERED]->(action:ACTION)
             OPTIONAL MATCH (action)-[:RESULTED_IN]-(outcome:OUTCOME)
             OPTIONAL MATCH (action)-[:HAS_INTERACTION]->(interaction:INTERACTION)
             
             WITH app, has, department, group, app_category, account, auth_types, email, user,
                  passwordReuseCount, one_month_ago_epoch, isMfaSupported,
                  weakPasswords, compromisedPasswords, noMFAUsed, weakMFAUsed,
                  COUNT(DISTINCT finding.id) AS findingCount,
                  COLLECT(DISTINCT {
                      findingId: finding.id,
                      ruleName: rule.name,
                      action: action.name,
                      outcomeDesc: outcome.description,
                      actionDesc: action.description,
                      hasInteraction: CASE WHEN interaction IS NOT NULL THEN true ELSE false END
                  }) AS findingData
             
             WITH app, has, department, group, app_category, account, auth_types, email, user,
                  passwordReuseCount, one_month_ago_epoch, findingCount, findingData, isMfaSupported,
                  weakPasswords, compromisedPasswords, noMFAUsed, weakMFAUsed,
                  ANY(data IN findingData WHERE data.hasInteraction = true) AS interactionsExist,
                  apoc.map.fromPairs([data IN findingData WHERE data.action IS NOT NULL | [data.action, COALESCE(data.outcomeDesc, data.actionDesc)]]) AS actionCurrentState,
                  apoc.map.fromPairs([data IN findingData WHERE data.hasInteraction = true AND data.ruleName IS NOT NULL | [data.ruleName, true]]) AS ruleInteractionMap
             
             WITH app, has, department, group, app_category, account, auth_types, email, user,
                  passwordReuseCount, one_month_ago_epoch, findingCount, findingData, actionCurrentState, 
                  interactionsExist, ruleInteractionMap, isMfaSupported, weakPasswords, compromisedPasswords, noMFAUsed, weakMFAUsed,
                  (EXISTS((app)-[:WHITELISTED_FOR]->(:BEHAVIOR {id: $behavior})) OR EXISTS((account)-[:WHITELISTED_FOR]->(:BEHAVIOR {id: $behavior}))) AS is_whitelisted
             
             WHERE app.name IS NOT NULL AND toLower(email.id) =~ toLower('.*{searchText}.*')
             {placeholder}
             
             WITH email.id AS userMail,
                  user.displayName AS userName,
                  COALESCE(app.name, app.domain, app.id) AS appName,
                  user.profilePicUrl AS userProfilePicUrl,
                  app.logoUrl AS appLogoUrl,
                  has.approval_status AS appStatus,
                  account.id AS accountId,
                  app.id_ as appId,
                  is_whitelisted,
                  one_month_ago_epoch,
                  isMfaSupported,
                  COLLECT(DISTINCT department.name) AS departments,
                  COLLECT(DISTINCT group.displayName) AS groups,
                  COLLECT(DISTINCT app_category.name) AS appCategories,
                  MAX(findingCount) AS totalFindingCount,
                  MAX(passwordReuseCount) AS totalPasswordReuseCount,
                  MAX(weakPasswords) AS totalWeakPasswords,
                  MAX(compromisedPasswords) AS totalCompromisedPasswords,
                  MAX(noMFAUsed) AS totalNoMFAUsed,
                  MAX(weakMFAUsed) AS totalWeakMFAUsed,
                  apoc.map.mergeList(COLLECT(actionCurrentState)) AS finalActionCurrentState,
                  apoc.map.mergeList(COLLECT(ruleInteractionMap)) AS finalRuleInteractionMap,
                  apoc.coll.contains(COLLECT(interactionsExist), true) AS hasAnyInteractions,
                  apoc.coll.flatten(COLLECT(auth_types)) AS allAuthTypes,
                  MIN(CASE WHEN account.creationTime = '-' THEN NULL ELSE account.creationTime END) AS firstAccessTime,
                  apoc.coll.contains([auth IN apoc.coll.flatten(COLLECT(auth_types)) | auth.creationTime < one_month_ago_epoch], true) AS newlyDiscovered
             
             WITH userMail, userName, appName, userProfilePicUrl, appLogoUrl, appStatus, accountId, appId, is_whitelisted, one_month_ago_epoch,
                  departments, groups, appCategories, totalFindingCount, totalPasswordReuseCount, totalWeakPasswords, totalCompromisedPasswords,
                  totalNoMFAUsed, totalWeakMFAUsed, finalActionCurrentState, finalRuleInteractionMap, hasAnyInteractions, allAuthTypes,
                  firstAccessTime, newlyDiscovered, isMfaSupported,
                  apoc.coll.max([auth IN allAuthTypes | COALESCE(auth.last_access_time, 0)]) AS lastAccessTime
             
             WITH userMail,
                    userName,
                    appName,
                    userProfilePicUrl,
                    departments,
                    groups,
                    is_whitelisted,
                    accountId,
                    appId,
                    appLogoUrl,
                    appCategories,
                    appStatus,
                    firstAccessTime,
                    lastAccessTime,
                    totalFindingCount AS findingCount,
                    finalActionCurrentState AS actionCurrentState,
                    totalPasswordReuseCount AS passwordReuseCount,
                    apoc.map.fromPairs([
                        ['Weak Passwords', totalWeakPasswords],
                        ['Compromised Passwords', totalCompromisedPasswords]
                    ]) AS passwordHygiene,
                    CASE
                        WHEN isMfaSupported <> true THEN null
                        ELSE apoc.map.fromPairs([
                            ['No MFA', totalNoMFAUsed],
                            ['Weak MFA', totalWeakMFAUsed]
                        ])
                    END AS mfaStatus,
                    hasAnyInteractions AS interactionsExist,
                    finalRuleInteractionMap AS ruleInteractionMap,
                    newlyDiscovered
                     
                    RETURN COUNT(*) AS totalCount"
  - id: BID_09_detailed
    name: "Credential Sharing Drilldown Table"
    input_params:
      accountId: $accountId
      behavior: $behavior
      group: AND toLower(group.displayName) IN [ x IN [$group] | toLower(x) ]
      department: AND toLower(department.name) IN [ x IN [$department] | toLower(x) ]
      appname: AND toLower(COALESCE(app.name, app.domain, app.id)) IN [ x IN [$appname] | toLower(x) ]
      app_category: AND toLower(app_category.name) IN [ x IN [$app_category] | toLower(x) ]
      criticality: AND toLower(COALESCE(has.criticality, app.criticality)) IN [ x IN [$criticality] | toLower(x) ]
      approval_status: AND toLower(has.approval_status) IN [ x IN [$approval_status] | toLower(x) ]
      password_hygiene: AND passwordHygiene[$password_hygiene] > 0
      mfa_status: AND CASE WHEN $mfa_status = 'null' THEN mfaStatus IS NULL ELSE mfaStatus[$mfa_status] > 0 END
    dataSourceType: "knowledgegraph"
    enabled: true
    allowed_params: true
    sortOrder: ""
    sortColumn: ""
    position: null
    template: null
    className: null
    multi_value_params:
      - id: appId
        delimiter: ","
      - id: group
        delimiter: ","
      - id: department
        delimiter: ","
      - id: appname
        delimiter: ","
      - id: app_category
        delimiter: ","
      - id: criticality
        delimiter: ","
      - id: approval_status
        delimiter: ","
    query: "MATCH (app:APPLICATION)<-[using_app:USING_APP]-(shared_account:ACCOUNT {id: $accountId, subscriber: $subscriber, tenant: $tenant})
            MATCH (shared_account)<-[auth_type:CREDSBASED_ACCOUNT]-(shared_email:EMAIL)
            OPTIONAL MATCH (shared_email)<-[:HAS_EMAIL]-(shared_user:USER)
            MATCH (shared_account)<-[:CREDENTIAL_SHARED]-(account:ACCOUNT {tenant: $tenant})
            WHERE toLower(shared_account.email) <> toLower(account.email)
            MATCH (account)<-[auth_type_target:CREDSBASED_ACCOUNT]-(email:EMAIL)
            OPTIONAL MATCH (email)<-[:HAS_EMAIL]-(user:USER)
            MATCH (account)-[:HAS_FINDING]->(finding:FINDING)<-[:EVALUATED_TO]-(rule:RULE)-[:BELONGS_TO]->(behavior:BEHAVIOR {id: $behavior})
            WHERE finding.sharedAccountId = shared_account.id
            
            WITH app, shared_account, shared_email, shared_user, account, email, user,
                 COLLECT(DISTINCT finding) AS findings,
                 COLLECT(DISTINCT rule) AS rules,
                 auth_type_target.last_access_time AS event_time
            
            OPTIONAL MATCH (app)-[has:HAS_APP_SETTINGS]-(tenant:TENANT {id: $tenant})
            OPTIONAL MATCH (shared_user)-[:HAS_DEPARTMENT]->(department:DEPARTMENT)
            OPTIONAL MATCH (app)-[:HAS_APP_CATEGORY]->(app_category:APP_CATEGORY)
            OPTIONAL MATCH (shared_user)-[:BELONGS_TO]->(group:GROUP {userDefined: true})
            
            WITH app, has, department, app_category, group, shared_account, shared_email, shared_user, account, email, user,
                 findings, rules, event_time,
                 (EXISTS((app)-[:WHITELISTED_FOR]->(:BEHAVIOR {id: $behavior})) OR EXISTS((account)-[:CRED_SHARING_APPROVED_FOR]->(shared_account))) AS is_whitelisted
            
            WHERE app.name IS NOT NULL AND NOT EXISTS((user)-[:SAME_USER]-(shared_user))
            AND toLower(user.displayName) =~ toLower('.*{searchText}.*')
            {placeholder}
            
            UNWIND findings AS finding
            UNWIND rules AS rule
            WITH app, has, department, app_category, group, shared_account, shared_email, shared_user, account, email, user,
                 event_time, is_whitelisted, finding, rule
            WHERE (finding)<-[:EVALUATED_TO]-(rule)
            
            OPTIONAL MATCH (finding)-[:TRIGGERED]->(action:ACTION)
            OPTIONAL MATCH (action)-[:HAS_INTERACTION]->(interaction:INTERACTION) 
            OPTIONAL MATCH (action)-[:RESULTED_IN]-(outcome:OUTCOME)
            
            WITH app, has, department, app_category, group, shared_account, shared_email, shared_user, account, email, user,
                 event_time, is_whitelisted,
                 COUNT(DISTINCT finding.id) AS findingCount,
                 COLLECT(DISTINCT {
                     findingId: finding.id,
                     ruleName: rule.name,
                     action: action.name,
                     outcomeDesc: outcome.description,
                     actionDesc: action.description,
                     hasInteraction: CASE WHEN interaction IS NOT NULL THEN true ELSE false END
                 }) AS findingData
            
            WITH app, has, department, app_category, group, shared_account, shared_email, shared_user, account, email, user,
                 event_time, is_whitelisted, findingCount, findingData,
                 SIZE([data IN findingData WHERE data.hasInteraction = true]) > 0 AS interactionsExist,
                 apoc.map.fromPairs([data IN findingData WHERE data.action IS NOT NULL | [data.action, COALESCE(data.outcomeDesc, data.actionDesc)]]) AS actionCurrentState,
                 apoc.map.fromPairs([data IN findingData WHERE data.hasInteraction = true AND data.ruleName IS NOT NULL | [data.ruleName, true]]) AS ruleInteractionMap
            
            WITH event_time,
                 shared_account.id AS shared_account_id,
                 shared_email.id AS shared_user_mail,
                 shared_user.displayName AS shared_user_name,
                 shared_user.profilePicUrl AS shared_user_profilePic,
                 COLLECT(DISTINCT group.displayName) AS groups,
                 is_whitelisted,
                 account.id AS shared_with_accountId,
                 account.id AS accountId,
                 account.email AS shared_with_mail,
                 user.displayName AS shared_with_name,
                 user.profilePicUrl AS shared_with_profilePic,
                 app.id_ AS app_id,
                 app.name AS app_name,
                 MAX(findingCount) AS totalFindingCount,
                 apoc.map.mergeList(COLLECT(actionCurrentState)) AS finalActionCurrentState,
                 apoc.map.mergeList(COLLECT(ruleInteractionMap)) AS finalRuleInteractionMap,
                 apoc.coll.contains(COLLECT(interactionsExist), true) AS hasAnyInteractions
            
            RETURN DISTINCT
                   MAX(event_time) AS event_time,
                   shared_account_id,
                   shared_user_mail,
                   shared_user_name,
                   shared_user_profilePic,
                   groups,
                   is_whitelisted,
                   shared_with_accountId,
                   accountId,
                   shared_with_mail,
                   shared_with_name,
                   shared_with_profilePic,
                   app_id,
                   app_name,
                   totalFindingCount AS findingCount,
                   finalActionCurrentState AS actionCurrentState,
                   hasAnyInteractions AS interactionsExist,
                   finalRuleInteractionMap AS ruleInteractionMap
            ORDER BY event_time DESC"
    pagination_query: "MATCH (app:APPLICATION)<-[using_app:USING_APP]-(shared_account:ACCOUNT {id: $accountId, subscriber: $subscriber, tenant: $tenant})
            MATCH (shared_account)<-[auth_type:CREDSBASED_ACCOUNT]-(shared_email:EMAIL)
            OPTIONAL MATCH (shared_email)<-[:HAS_EMAIL]-(shared_user:USER)
            MATCH (shared_account)<-[:CREDENTIAL_SHARED]-(account:ACCOUNT {tenant: $tenant})
            WHERE toLower(shared_account.email) <> toLower(account.email)
            MATCH (account)<-[auth_type_target:CREDSBASED_ACCOUNT]-(email:EMAIL)
            OPTIONAL MATCH (email)<-[:HAS_EMAIL]-(user:USER)
            MATCH (account)-[:HAS_FINDING]->(finding:FINDING)<-[:EVALUATED_TO]-(rule:RULE)-[:BELONGS_TO]->(behavior:BEHAVIOR {id: $behavior})
            WHERE finding.sharedAccountId = shared_account.id
            
            WITH app, shared_account, shared_email, shared_user, account, email, user,
                 COLLECT(DISTINCT finding) AS findings,
                 COLLECT(DISTINCT rule) AS rules,
                 auth_type_target.last_access_time AS event_time
            
            OPTIONAL MATCH (app)-[has:HAS_APP_SETTINGS]-(tenant:TENANT {id: $tenant})
            OPTIONAL MATCH (shared_user)-[:HAS_DEPARTMENT]->(department:DEPARTMENT)
            OPTIONAL MATCH (app)-[:HAS_APP_CATEGORY]->(app_category:APP_CATEGORY)
            OPTIONAL MATCH (shared_user)-[:BELONGS_TO]->(group:GROUP {userDefined: true})
            
            WITH app, has, department, app_category, group, shared_account, shared_email, shared_user, account, email, user,
                 findings, rules, event_time,
                 (EXISTS((app)-[:WHITELISTED_FOR]->(:BEHAVIOR {id: $behavior})) OR EXISTS((account)-[:CRED_SHARING_APPROVED_FOR]->(shared_account))) AS is_whitelisted
            
            WHERE app.name IS NOT NULL AND NOT EXISTS((user)-[:SAME_USER]-(shared_user))
            AND toLower(user.displayName) =~ toLower('.*{searchText}.*')
            {placeholder}
            
            UNWIND findings AS finding
            UNWIND rules AS rule
            WITH app, has, department, app_category, group, shared_account, shared_email, shared_user, account, email, user,
                 event_time, is_whitelisted, finding, rule
            WHERE (finding)<-[:EVALUATED_TO]-(rule)
            
            OPTIONAL MATCH (finding)-[:TRIGGERED]->(action:ACTION)
            OPTIONAL MATCH (action)-[:HAS_INTERACTION]->(interaction:INTERACTION) 
            OPTIONAL MATCH (action)-[:RESULTED_IN]-(outcome:OUTCOME)
            
            WITH app, has, department, app_category, group, shared_account, shared_email, shared_user, account, email, user,
                 event_time, is_whitelisted,
                 COUNT(DISTINCT finding.id) AS findingCount,
                 COLLECT(DISTINCT {
                     findingId: finding.id,
                     ruleName: rule.name,
                     action: action.name,
                     outcomeDesc: outcome.description,
                     actionDesc: action.description,
                     hasInteraction: CASE WHEN interaction IS NOT NULL THEN true ELSE false END
                 }) AS findingData
            
            WITH app, has, department, app_category, group, shared_account, shared_email, shared_user, account, email, user,
                 event_time, is_whitelisted, findingCount, findingData,
                 SIZE([data IN findingData WHERE data.hasInteraction = true]) > 0 AS interactionsExist,
                 apoc.map.fromPairs([data IN findingData WHERE data.action IS NOT NULL | [data.action, COALESCE(data.outcomeDesc, data.actionDesc)]]) AS actionCurrentState,
                 apoc.map.fromPairs([data IN findingData WHERE data.hasInteraction = true AND data.ruleName IS NOT NULL | [data.ruleName, true]]) AS ruleInteractionMap
            
            WITH event_time,
                 shared_account.id AS shared_account_id,
                 shared_email.id AS shared_user_mail,
                 shared_user.displayName AS shared_user_name,
                 shared_user.profilePicUrl AS shared_user_profilePic,
                 COLLECT(DISTINCT group.displayName) AS groups,
                 is_whitelisted,
                 account.id AS shared_with_accountId,
                 account.id AS accountId,
                 account.email AS shared_with_mail,
                 user.displayName AS shared_with_name,
                 user.profilePicUrl AS shared_with_profilePic,
                 app.id_ AS app_id,
                 app.name AS app_name,
                 MAX(findingCount) AS totalFindingCount,
                 apoc.map.mergeList(COLLECT(actionCurrentState)) AS finalActionCurrentState,
                 apoc.map.mergeList(COLLECT(ruleInteractionMap)) AS finalRuleInteractionMap,
                 apoc.coll.contains(COLLECT(interactionsExist), true) AS hasAnyInteractions
            
            WITH DISTINCT
                   MAX(event_time) AS event_time,
                   shared_account_id,
                   shared_user_mail,
                   shared_user_name,
                   shared_user_profilePic,
                   groups,
                   is_whitelisted,
                   shared_with_accountId,
                   accountId,
                   shared_with_mail,
                   shared_with_name,
                   shared_with_profilePic,
                   app_id,
                   app_name,
                   totalFindingCount AS findingCount,
                   finalActionCurrentState AS actionCurrentState,
                   hasAnyInteractions AS interactionsExist,
                   finalRuleInteractionMap AS ruleInteractionMap
            
                   RETURN COUNT(*) AS totalCount"
  - id: BID_10_detailed
    name: "Password reuse Drilldown Table"
    input_params:
      appId: $appId
      behavior: $behavior
      group: AND toLower(group.displayName) IN [ x IN [$group] | toLower(x) ]
      department: AND toLower(department.name) IN [ x IN [$department] | toLower(x) ]
      appname: AND toLower(COALESCE(app.name, app.domain, app.id)) IN [ x IN [$appname] | toLower(x) ]
      app_category: AND toLower(app_category.name) IN [ x IN [$app_category] | toLower(x) ]
      criticality: AND toLower(COALESCE(has.criticality, app.criticality)) IN [ x IN [$criticality] | toLower(x) ]
      approval_status: AND toLower(has.approval_status) IN [ x IN [$approval_status] | toLower(x) ]
      password_hygiene: AND passwordHygiene[$password_hygiene] > 0
      mfa_status: AND CASE WHEN $mfa_status = 'null' THEN mfaStatus IS NULL ELSE mfaStatus[$mfa_status] > 0 END
    dataSourceType: "knowledgegraph"
    enabled: true
    allowed_params: true
    sortOrder: ""
    sortColumn: ""
    position: null
    template: null
    className: null
    multi_value_params:
      - id: appId
        delimiter: ","
      - id: group
        delimiter: ","
      - id: department
        delimiter: ","
      - id: appname
        delimiter: ","
      - id: app_category
        delimiter: ","
      - id: criticality
        delimiter: ","
      - id: approval_status
        delimiter: ","
    query: "MATCH (app:APPLICATION)
            WHERE app.id_ IN [$appId]
            MATCH (app)<-[using_app:USING_APP]-(account:ACCOUNT {tenant: $tenant})
            MATCH (account)-[:HAS_FINDING]->(finding:FINDING)<-[:EVALUATED_TO]-(rule:RULE)-[:BELONGS_TO]->(behavior:BEHAVIOR {id: $behavior})
            MATCH (account)<-[auth_type]-(email:EMAIL)<-[:HAS_EMAIL]-(user:USER)
            
            WITH app, account, email, user,
                 COLLECT(DISTINCT auth_type) AS auth_types,
                 COLLECT(DISTINCT finding) AS findings,
                 COLLECT(DISTINCT rule) AS rules,
                 datetime.truncate('day', datetime() - duration('P1M')).epochMillis AS one_month_ago_epoch
            
            MATCH (account)-[:HAS_CRED_FINGERPRINT]-(cred:CRED_FINGERPRINT)-[]-(same_password_account:ACCOUNT {tenant: $tenant})-[:USING_APP]->(same_password_app)
            WHERE same_password_account <> account AND same_password_account.email = account.email
            
            WITH app, account, email, user, auth_types, findings, rules, one_month_ago_epoch,
                 COUNT(DISTINCT same_password_account.id) as passwordReuseCount
            
            OPTIONAL MATCH (app)-[has:HAS_APP_SETTINGS]-(tenant:TENANT {id: $tenant})
            OPTIONAL MATCH (user)-[:HAS_DEPARTMENT]->(department:DEPARTMENT)
            OPTIONAL MATCH (user)-[:BELONGS_TO]->(group:GROUP {userDefined: true})
            OPTIONAL MATCH (app)-[:HAS_APP_CATEGORY]->(app_category:APP_CATEGORY)
            
            CALL {
                WITH account
                MATCH (account)-[:HAS_FINDING]-(f)-[]-(:RULE)-[]-(b:BEHAVIOR)
                WHERE b.id IN ['BID_06', 'BID_07', 'BID_08', 'BID_11']
                RETURN
                    COUNT(DISTINCT CASE WHEN b.id = 'BID_06' THEN f.id END) AS noMFAUsed,
                    COUNT(DISTINCT CASE WHEN b.id = 'BID_07' THEN f.id END) AS weakMFAUsed,
                    COUNT(DISTINCT CASE WHEN b.id = 'BID_08' THEN f.id END) AS compromisedPasswords,
                    COUNT(DISTINCT CASE WHEN b.id = 'BID_11' THEN f.id END) AS weakPasswords
            }
            
            UNWIND findings AS finding
            UNWIND rules AS rule
            WITH app, has, department, group, app_category, account, auth_types, email, user, 
                 passwordReuseCount, one_month_ago_epoch, finding, rule,
                 weakPasswords, compromisedPasswords, app.isMfaSupported as isMfaSupported, noMFAUsed, weakMFAUsed
            WHERE (finding)<-[:EVALUATED_TO]-(rule)
            
            OPTIONAL MATCH (finding)-[:TRIGGERED]->(action:ACTION)
            OPTIONAL MATCH (action)-[:RESULTED_IN]-(outcome:OUTCOME)
            OPTIONAL MATCH (action)-[:HAS_INTERACTION]->(interaction:INTERACTION)
            
            WITH app, has, department, group, app_category, account, auth_types, email, user,
                 passwordReuseCount, one_month_ago_epoch, isMfaSupported,
                 weakPasswords, compromisedPasswords, noMFAUsed, weakMFAUsed,
                 COUNT(DISTINCT finding.id) AS findingCount,
                 COLLECT(DISTINCT {
                     findingId: finding.id,
                     ruleName: rule.name,
                     action: action.name,
                     outcomeDesc: outcome.description,
                     actionDesc: action.description,
                     hasInteraction: CASE WHEN interaction IS NOT NULL THEN true ELSE false END
                 }) AS findingData
            
            WITH app, has, department, group, app_category, account, auth_types, email, user,
                 passwordReuseCount, one_month_ago_epoch, findingCount, findingData, isMfaSupported,
                 weakPasswords, compromisedPasswords, noMFAUsed, weakMFAUsed,
                 SIZE([data IN findingData WHERE data.hasInteraction = true]) > 0 AS interactionsExist,
                 apoc.map.fromPairs([data IN findingData WHERE data.action IS NOT NULL | [data.action, COALESCE(data.outcomeDesc, data.actionDesc)]]) AS actionCurrentState,
                 apoc.map.fromPairs([data IN findingData WHERE data.hasInteraction = true AND data.ruleName IS NOT NULL | [data.ruleName, true]]) AS ruleInteractionMap
            
            WITH app, has, department, group, app_category, account, auth_types, email, user,
                 passwordReuseCount, one_month_ago_epoch, findingCount, actionCurrentState, 
                 interactionsExist, ruleInteractionMap, isMfaSupported, weakPasswords, compromisedPasswords, noMFAUsed, weakMFAUsed,
                 (EXISTS((app)-[:WHITELISTED_FOR]->(:BEHAVIOR {id: $behavior})) OR EXISTS((account)-[:WHITELISTED_FOR]->(:BEHAVIOR {id: $behavior}))) AS is_whitelisted
            
            WHERE app.name IS NOT NULL AND toLower(email.id) =~ toLower('.*{searchText}.*')
            {placeholder}
            
            WITH email.id AS userMail,
                 user.id AS userId,
                 user.displayName AS userName,
                 COALESCE(app.name, app.domain, app.id) AS appName,
                 user.profilePicUrl AS userProfilePicUrl,
                 app.logoUrl AS appLogoUrl,
                 has.approval_status AS appStatus,
                 app.id_ as appId,
                 account.id AS accountId,
                 is_whitelisted,
                 one_month_ago_epoch,
                 isMfaSupported,
                 COLLECT(DISTINCT department.name) AS departments,
                 COLLECT(DISTINCT group.displayName) AS groups,
                 COLLECT(DISTINCT app_category.name) AS appCategories,
                 MAX(findingCount) AS totalFindingCount,
                 MAX(passwordReuseCount) AS totalPasswordReuseCount,
                 MAX(weakPasswords) AS totalWeakPasswords,
                 MAX(compromisedPasswords) AS totalCompromisedPasswords,
                 MAX(noMFAUsed) AS totalNoMFAUsed,
                 MAX(weakMFAUsed) AS totalWeakMFAUsed,
                 apoc.map.mergeList(COLLECT(actionCurrentState)) AS finalActionCurrentState,
                 apoc.map.mergeList(COLLECT(ruleInteractionMap)) AS finalRuleInteractionMap,
                 apoc.coll.contains(COLLECT(interactionsExist), true) AS hasAnyInteractions,
                 apoc.coll.flatten(COLLECT(auth_types)) AS allAuthTypes,
                 MIN(CASE WHEN account.creationTime = '-' THEN NULL ELSE account.creationTime END) AS firstAccessTime,
                 apoc.coll.contains([auth IN apoc.coll.flatten(COLLECT(auth_types)) | auth.creationTime < one_month_ago_epoch], true) AS newlyDiscovered
            
            WITH userMail, userId, userName, appName, userProfilePicUrl, appLogoUrl, appStatus, appId, accountId, is_whitelisted, one_month_ago_epoch,
                 departments, groups, appCategories, totalFindingCount, totalPasswordReuseCount, totalWeakPasswords, totalCompromisedPasswords,
                 totalNoMFAUsed, totalWeakMFAUsed, finalActionCurrentState, finalRuleInteractionMap, hasAnyInteractions, allAuthTypes,
                 firstAccessTime, newlyDiscovered, isMfaSupported,
                 apoc.coll.max([auth IN allAuthTypes | COALESCE(auth.last_access_time, 0)]) AS lastAccessTime
            
            RETURN userMail,
                   userId,
                   userName,
                   appName,
                   userProfilePicUrl,
                   departments,
                   groups,
                   is_whitelisted,
                   appId,
                   appLogoUrl,
                   accountId,
                   appCategories,
                   appStatus,
                   firstAccessTime,
                   lastAccessTime,
                   totalFindingCount AS findingCount,
                   finalActionCurrentState AS actionCurrentState,
                   totalPasswordReuseCount AS passwordReuseCount,
                   apoc.map.fromPairs([
                       ['Weak Passwords', totalWeakPasswords],
                       ['Compromised Passwords', totalCompromisedPasswords]
                   ]) AS passwordHygiene,
                   CASE
                       WHEN isMfaSupported <> true THEN null
                       ELSE apoc.map.fromPairs([
                           ['No MFA', totalNoMFAUsed],
                           ['Weak MFA', totalWeakMFAUsed]
                       ])
                   END AS mfaStatus,
                   hasAnyInteractions AS interactionsExist,
                   finalRuleInteractionMap AS ruleInteractionMap,
                   newlyDiscovered
            ORDER BY lastAccessTime DESC"
    pagination_query: "
            MATCH (app:APPLICATION)
            WHERE app.id_ IN [$appId]
            MATCH (app)<-[using_app:USING_APP]-(account:ACCOUNT {tenant: $tenant})
            MATCH (account)-[:HAS_FINDING]->(finding:FINDING)<-[:EVALUATED_TO]-(rule:RULE)-[:BELONGS_TO]->(behavior:BEHAVIOR {id: $behavior})
            MATCH (account)<-[auth_type]-(email:EMAIL)<-[:HAS_EMAIL]-(user:USER)
            
            WITH app, account, email, user,
                 COLLECT(DISTINCT auth_type) AS auth_types,
                 COLLECT(DISTINCT finding) AS findings,
                 COLLECT(DISTINCT rule) AS rules,
                 datetime.truncate('day', datetime() - duration('P1M')).epochMillis AS one_month_ago_epoch
            
            MATCH (account)-[:HAS_CRED_FINGERPRINT]-(cred:CRED_FINGERPRINT)-[]-(same_password_account:ACCOUNT {tenant: $tenant})-[:USING_APP]->(same_password_app)
            WHERE same_password_account <> account AND same_password_account.email = account.email
            
            WITH app, account, email, user, auth_types, findings, rules, one_month_ago_epoch,
                 COUNT(DISTINCT same_password_account.id) as passwordReuseCount
            
            OPTIONAL MATCH (app)-[has:HAS_APP_SETTINGS]-(tenant:TENANT {id: $tenant})
            OPTIONAL MATCH (user)-[:HAS_DEPARTMENT]->(department:DEPARTMENT)
            OPTIONAL MATCH (user)-[:BELONGS_TO]->(group:GROUP {userDefined: true})
            OPTIONAL MATCH (app)-[:HAS_APP_CATEGORY]->(app_category:APP_CATEGORY)
            
            CALL {
                WITH account
                MATCH (account)-[:HAS_FINDING]-(f)-[]-(:RULE)-[]-(b:BEHAVIOR)
                WHERE b.id IN ['BID_06', 'BID_07', 'BID_08', 'BID_11']
                RETURN
                    COUNT(DISTINCT CASE WHEN b.id = 'BID_06' THEN f.id END) AS noMFAUsed,
                    COUNT(DISTINCT CASE WHEN b.id = 'BID_07' THEN f.id END) AS weakMFAUsed,
                    COUNT(DISTINCT CASE WHEN b.id = 'BID_08' THEN f.id END) AS compromisedPasswords,
                    COUNT(DISTINCT CASE WHEN b.id = 'BID_11' THEN f.id END) AS weakPasswords
            }
            
            UNWIND findings AS finding
            UNWIND rules AS rule
            WITH app, has, department, group, app_category, account, auth_types, email, user, 
                 passwordReuseCount, one_month_ago_epoch, finding, rule,
                 weakPasswords, compromisedPasswords, app.isMfaSupported as isMfaSupported, noMFAUsed, weakMFAUsed
            WHERE (finding)<-[:EVALUATED_TO]-(rule)
            
            OPTIONAL MATCH (finding)-[:TRIGGERED]->(action:ACTION)
            OPTIONAL MATCH (action)-[:RESULTED_IN]-(outcome:OUTCOME)
            OPTIONAL MATCH (action)-[:HAS_INTERACTION]->(interaction:INTERACTION)
            
            WITH app, has, department, group, app_category, account, auth_types, email, user,
                 passwordReuseCount, one_month_ago_epoch, isMfaSupported,
                 weakPasswords, compromisedPasswords, noMFAUsed, weakMFAUsed,
                 COUNT(DISTINCT finding.id) AS findingCount,
                 COLLECT(DISTINCT {
                     findingId: finding.id,
                     ruleName: rule.name,
                     action: action.name,
                     outcomeDesc: outcome.description,
                     actionDesc: action.description,
                     hasInteraction: CASE WHEN interaction IS NOT NULL THEN true ELSE false END
                 }) AS findingData
            
            WITH app, has, department, group, app_category, account, auth_types, email, user,
                 passwordReuseCount, one_month_ago_epoch, findingCount, findingData, isMfaSupported,
                 weakPasswords, compromisedPasswords, noMFAUsed, weakMFAUsed,
                 SIZE([data IN findingData WHERE data.hasInteraction = true]) > 0 AS interactionsExist,
                 apoc.map.fromPairs([data IN findingData WHERE data.action IS NOT NULL | [data.action, COALESCE(data.outcomeDesc, data.actionDesc)]]) AS actionCurrentState,
                 apoc.map.fromPairs([data IN findingData WHERE data.hasInteraction = true AND data.ruleName IS NOT NULL | [data.ruleName, true]]) AS ruleInteractionMap
            
            WITH app, has, department, group, app_category, account, auth_types, email, user,
                 passwordReuseCount, one_month_ago_epoch, findingCount, actionCurrentState, 
                 interactionsExist, ruleInteractionMap, isMfaSupported, weakPasswords, compromisedPasswords, noMFAUsed, weakMFAUsed,
                 (EXISTS((app)-[:WHITELISTED_FOR]->(:BEHAVIOR {id: $behavior})) OR EXISTS((account)-[:WHITELISTED_FOR]->(:BEHAVIOR {id: $behavior}))) AS is_whitelisted
            
            WHERE app.name IS NOT NULL AND toLower(email.id) =~ toLower('.*{searchText}.*')
            {placeholder}
            
            WITH email.id AS userMail,
                 user.id AS userId,
                 user.displayName AS userName,
                 COALESCE(app.name, app.domain, app.id) AS appName,
                 user.profilePicUrl AS userProfilePicUrl,
                 app.logoUrl AS appLogoUrl,
                 has.approval_status AS appStatus,
                 app.id_ as appId,
                 account.id AS accountId,
                 is_whitelisted,
                 one_month_ago_epoch,
                 isMfaSupported,
                 COLLECT(DISTINCT department.name) AS departments,
                 COLLECT(DISTINCT group.displayName) AS groups,
                 COLLECT(DISTINCT app_category.name) AS appCategories,
                 MAX(findingCount) AS totalFindingCount,
                 MAX(passwordReuseCount) AS totalPasswordReuseCount,
                 MAX(weakPasswords) AS totalWeakPasswords,
                 MAX(compromisedPasswords) AS totalCompromisedPasswords,
                 MAX(noMFAUsed) AS totalNoMFAUsed,
                 MAX(weakMFAUsed) AS totalWeakMFAUsed,
                 apoc.map.mergeList(COLLECT(actionCurrentState)) AS finalActionCurrentState,
                 apoc.map.mergeList(COLLECT(ruleInteractionMap)) AS finalRuleInteractionMap,
                 apoc.coll.contains(COLLECT(interactionsExist), true) AS hasAnyInteractions,
                 apoc.coll.flatten(COLLECT(auth_types)) AS allAuthTypes,
                 MIN(CASE WHEN account.creationTime = '-' THEN NULL ELSE account.creationTime END) AS firstAccessTime,
                 apoc.coll.contains([auth IN apoc.coll.flatten(COLLECT(auth_types)) | auth.creationTime < one_month_ago_epoch], true) AS newlyDiscovered
            
            WITH userMail, userId, userName, appName, userProfilePicUrl, appLogoUrl, appStatus, appId, accountId, is_whitelisted, one_month_ago_epoch,
                 departments, groups, appCategories, totalFindingCount, totalPasswordReuseCount, totalWeakPasswords, totalCompromisedPasswords,
                 totalNoMFAUsed, totalWeakMFAUsed, finalActionCurrentState, finalRuleInteractionMap, hasAnyInteractions, allAuthTypes,
                 firstAccessTime, newlyDiscovered, isMfaSupported,
                 apoc.coll.max([auth IN allAuthTypes | COALESCE(auth.last_access_time, 0)]) AS lastAccessTime
            
            WITH userMail,
                   userId,
                   userName,
                   appName,
                   userProfilePicUrl,
                   departments,
                   groups,
                   is_whitelisted,
                   appId,
                   appLogoUrl,
                   accountId,
                   appCategories,
                   appStatus,
                   firstAccessTime,
                   lastAccessTime,
                   totalFindingCount AS findingCount,
                   finalActionCurrentState AS actionCurrentState,
                   totalPasswordReuseCount AS passwordReuseCount,
                   apoc.map.fromPairs([
                       ['Weak Passwords', totalWeakPasswords],
                       ['Compromised Passwords', totalCompromisedPasswords]
                   ]) AS passwordHygiene,
                   CASE
                       WHEN isMfaSupported <> true THEN null
                       ELSE apoc.map.fromPairs([
                           ['No MFA', totalNoMFAUsed],
                           ['Weak MFA', totalWeakMFAUsed]
                       ])
                   END AS mfaStatus,
                   hasAnyInteractions AS interactionsExist,
                   finalRuleInteractionMap AS ruleInteractionMap,
                   newlyDiscovered
            
            RETURN COUNT(*) AS totalCount"
  - id: BID_11_detailed
    name: "Weak Password Drilldown Table"
    input_params:
      appId: $appId
      behavior: $behavior
      group: AND toLower(group.displayName) IN [ x IN [$group] | toLower(x) ]
      department: AND toLower(department.name) IN [ x IN [$department] | toLower(x) ]
      appname: AND toLower(COALESCE(app.name, app.domain, app.id)) IN [ x IN [$appname] | toLower(x) ]
      app_category: AND toLower(app_category.name) IN [ x IN [$app_category] | toLower(x) ]
      criticality: AND toLower(COALESCE(has.criticality, app.criticality)) IN [ x IN [$criticality] | toLower(x) ]
      approval_status: AND toLower(has.approval_status) IN [ x IN [$approval_status] | toLower(x) ]
      password_hygiene: AND passwordHygiene[$password_hygiene] > 0
      mfa_status: AND CASE WHEN $mfa_status = 'null' THEN mfaStatus IS NULL ELSE mfaStatus[$mfa_status] > 0 END
    dataSourceType: "knowledgegraph"
    enabled: true
    allowed_params: true
    sortOrder: ""
    sortColumn: ""
    position: null
    template: null
    className: null
    multi_value_params:
      - id: appId
        delimiter: ","
      - id: group
        delimiter: ","
      - id: department
        delimiter: ","
      - id: appname
        delimiter: ","
      - id: app_category
        delimiter: ","
      - id: criticality
        delimiter: ","
      - id: approval_status
        delimiter: ","
    query: "MATCH (app:APPLICATION)
            WHERE app.id_ IN [$appId]
            MATCH (app)<-[using_app:USING_APP]-(account:ACCOUNT {tenant: $tenant})
            MATCH (account)-[:HAS_FINDING]->(finding:FINDING)<-[:EVALUATED_TO]-(rule:RULE)-[:BELONGS_TO]->(behavior:BEHAVIOR {id: $behavior})
            MATCH (account)<-[auth_type]-(email:EMAIL)<-[:HAS_EMAIL]-(user:USER)
            
            WITH app, account, email, user,
                 COLLECT(DISTINCT auth_type) AS auth_types,
                 COLLECT(DISTINCT finding) AS findings,
                 COLLECT(DISTINCT rule) AS rules,
                 datetime.truncate('day', datetime() - duration('P1M')).epochMillis AS one_month_ago_epoch
            
            OPTIONAL MATCH (account)-[:HAS_CRED_FINGERPRINT]-(cred:CRED_FINGERPRINT)-[]-(same_password_account:ACCOUNT {tenant: $tenant})
            WHERE same_password_account <> account AND same_password_account.email = account.email
            
            WITH app, account, email, user, auth_types, findings, rules, one_month_ago_epoch,
                 COUNT(DISTINCT same_password_account.id) as passwordReuseCount
            
            OPTIONAL MATCH (app)-[has:HAS_APP_SETTINGS]-(tenant:TENANT {id: $tenant})
            OPTIONAL MATCH (user)-[:HAS_DEPARTMENT]->(department:DEPARTMENT)
            OPTIONAL MATCH (user)-[:BELONGS_TO]->(group:GROUP {userDefined: true})
            OPTIONAL MATCH (app)-[:HAS_APP_CATEGORY]->(app_category:APP_CATEGORY)
            
            CALL {
                WITH account
                MATCH (account)-[:HAS_FINDING]-(f)-[]-(:RULE)-[]-(b:BEHAVIOR)
                WHERE b.id IN ['BID_06', 'BID_07', 'BID_08', 'BID_11']
                RETURN
                    COUNT(DISTINCT CASE WHEN b.id = 'BID_06' THEN f.id END) AS noMFAUsed,
                    COUNT(DISTINCT CASE WHEN b.id = 'BID_07' THEN f.id END) AS weakMFAUsed,
                    COUNT(DISTINCT CASE WHEN b.id = 'BID_08' THEN f.id END) AS compromisedPasswords,
                    COUNT(DISTINCT CASE WHEN b.id = 'BID_11' THEN f.id END) AS weakPasswords
            }
            
            UNWIND findings AS finding
            UNWIND rules AS rule
            WITH app, has, department, group, app_category, account, auth_types, email, user, 
                 passwordReuseCount, one_month_ago_epoch, finding, rule,
                 weakPasswords, compromisedPasswords, app.isMfaSupported as isMfaSupported, noMFAUsed, weakMFAUsed
            WHERE (finding)<-[:EVALUATED_TO]-(rule)
            
            OPTIONAL MATCH (finding)-[:TRIGGERED]->(action:ACTION)
            OPTIONAL MATCH (action)-[:RESULTED_IN]-(outcome:OUTCOME)
            OPTIONAL MATCH (action)-[:HAS_INTERACTION]->(interaction:INTERACTION)
            
            WITH app, has, department, group, app_category, account, auth_types, email, user,
                 passwordReuseCount, one_month_ago_epoch, isMfaSupported,
                 weakPasswords, compromisedPasswords, noMFAUsed, weakMFAUsed,
                 COUNT(DISTINCT finding.id) AS findingCount,
                 COLLECT(DISTINCT {
                     findingId: finding.id,
                     ruleName: rule.name,
                     action: action.name,
                     outcomeDesc: outcome.description,
                     actionDesc: action.description,
                     hasInteraction: CASE WHEN interaction IS NOT NULL THEN true ELSE false END
                 }) AS findingData
            
            WITH app, has, department, group, app_category, account, auth_types, email, user,
                 passwordReuseCount, one_month_ago_epoch, findingCount, findingData, isMfaSupported,
                 weakPasswords, compromisedPasswords, noMFAUsed, weakMFAUsed,
                 SIZE([data IN findingData WHERE data.hasInteraction = true]) > 0 AS interactionsExist,
                 apoc.map.fromPairs([data IN findingData WHERE data.action IS NOT NULL | [data.action, COALESCE(data.outcomeDesc, data.actionDesc)]]) AS actionCurrentState,
                 apoc.map.fromPairs([data IN findingData WHERE data.hasInteraction = true AND data.ruleName IS NOT NULL | [data.ruleName, true]]) AS ruleInteractionMap
            
            WITH app, has, department, group, app_category, account, auth_types, email, user,
                 passwordReuseCount, one_month_ago_epoch, findingCount, actionCurrentState, 
                 interactionsExist, ruleInteractionMap, isMfaSupported, weakPasswords, compromisedPasswords, noMFAUsed, weakMFAUsed,
                 (EXISTS((app)-[:WHITELISTED_FOR]->(:BEHAVIOR {id: $behavior})) OR EXISTS((account)-[:WHITELISTED_FOR]->(:BEHAVIOR {id: $behavior}))) AS is_whitelisted
            
            WHERE app.name IS NOT NULL AND toLower(email.id) =~ toLower('.*{searchText}.*')
            {placeholder}
            
            WITH email.id AS userMail,
                 user.displayName AS userName,
                 COALESCE(app.name, app.domain, app.id) AS appName,
                 user.profilePicUrl AS userProfilePicUrl,
                 app.logoUrl AS appLogoUrl,
                 has.approval_status AS appStatus,
                 account.id AS accountId,
                 app.id_ as appId,
                 is_whitelisted,
                 one_month_ago_epoch,
                 isMfaSupported,
                 COLLECT(DISTINCT department.name) AS departments,
                 COLLECT(DISTINCT group.displayName) AS groups,
                 COLLECT(DISTINCT app_category.name) AS appCategories,
                 MAX(findingCount) AS totalFindingCount,
                 MAX(passwordReuseCount) AS totalPasswordReuseCount,
                 MAX(weakPasswords) AS totalWeakPasswords,
                 MAX(compromisedPasswords) AS totalCompromisedPasswords,
                 MAX(noMFAUsed) AS totalNoMFAUsed,
                 MAX(weakMFAUsed) AS totalWeakMFAUsed,
                 apoc.map.mergeList(COLLECT(actionCurrentState)) AS finalActionCurrentState,
                 apoc.map.mergeList(COLLECT(ruleInteractionMap)) AS finalRuleInteractionMap,
                 apoc.coll.contains(COLLECT(interactionsExist), true) AS hasAnyInteractions,
                 apoc.coll.flatten(COLLECT(auth_types)) AS allAuthTypes,
                 MIN(CASE WHEN account.creationTime = '-' THEN NULL ELSE account.creationTime END) AS firstAccessTime,
                 apoc.coll.contains([auth IN apoc.coll.flatten(COLLECT(auth_types)) | auth.creationTime < one_month_ago_epoch], true) AS newlyDiscovered
            
            WITH userMail, userName, appName, userProfilePicUrl, appLogoUrl, appStatus, accountId, appId, is_whitelisted, one_month_ago_epoch,
                 departments, groups, appCategories, totalFindingCount, totalPasswordReuseCount, totalWeakPasswords, totalCompromisedPasswords,
                 totalNoMFAUsed, totalWeakMFAUsed, finalActionCurrentState, finalRuleInteractionMap, hasAnyInteractions, allAuthTypes,
                 firstAccessTime, newlyDiscovered, isMfaSupported,
                 apoc.coll.max([auth IN allAuthTypes | COALESCE(auth.last_access_time, 0)]) AS lastAccessTime
            
            RETURN userMail,
                   userName,
                   appName,
                   userProfilePicUrl,
                   departments,
                   groups,
                   is_whitelisted,
                   accountId,
                   appId,
                   appLogoUrl,
                   appCategories,
                   appStatus,
                   firstAccessTime,
                   lastAccessTime,
                   totalFindingCount AS findingCount,
                   finalActionCurrentState AS actionCurrentState,
                   totalPasswordReuseCount AS passwordReuseCount,
                   apoc.map.fromPairs([
                       ['Weak Passwords', totalWeakPasswords],
                       ['Compromised Passwords', totalCompromisedPasswords]
                   ]) AS passwordHygiene,
                   CASE
                       WHEN isMfaSupported <> true THEN null
                       ELSE apoc.map.fromPairs([
                           ['No MFA', totalNoMFAUsed],
                           ['Weak MFA', totalWeakMFAUsed]
                       ])
                   END AS mfaStatus,
                   hasAnyInteractions AS interactionsExist,
                   finalRuleInteractionMap AS ruleInteractionMap,
                   newlyDiscovered
            ORDER BY lastAccessTime DESC"
    pagination_query: "
            MATCH (app:APPLICATION)
            WHERE app.id_ IN [$appId]
            MATCH (app)<-[using_app:USING_APP]-(account:ACCOUNT {tenant: $tenant})
            MATCH (account)-[:HAS_FINDING]->(finding:FINDING)<-[:EVALUATED_TO]-(rule:RULE)-[:BELONGS_TO]->(behavior:BEHAVIOR {id: $behavior})
            MATCH (account)<-[auth_type]-(email:EMAIL)<-[:HAS_EMAIL]-(user:USER)
            
            WITH app, account, email, user,
                 COLLECT(DISTINCT auth_type) AS auth_types,
                 COLLECT(DISTINCT finding) AS findings,
                 COLLECT(DISTINCT rule) AS rules,
                 datetime.truncate('day', datetime() - duration('P1M')).epochMillis AS one_month_ago_epoch
            
            OPTIONAL MATCH (account)-[:HAS_CRED_FINGERPRINT]-(cred:CRED_FINGERPRINT)-[]-(same_password_account:ACCOUNT {tenant: $tenant})
            WHERE same_password_account <> account AND same_password_account.email = account.email
            
            WITH app, account, email, user, auth_types, findings, rules, one_month_ago_epoch,
                 COUNT(DISTINCT same_password_account.id) as passwordReuseCount
            
            OPTIONAL MATCH (app)-[has:HAS_APP_SETTINGS]-(tenant:TENANT {id: $tenant})
            OPTIONAL MATCH (user)-[:HAS_DEPARTMENT]->(department:DEPARTMENT)
            OPTIONAL MATCH (user)-[:BELONGS_TO]->(group:GROUP {userDefined: true})
            OPTIONAL MATCH (app)-[:HAS_APP_CATEGORY]->(app_category:APP_CATEGORY)
            
            CALL {
                WITH account
                MATCH (account)-[:HAS_FINDING]-(f)-[]-(:RULE)-[]-(b:BEHAVIOR)
                WHERE b.id IN ['BID_06', 'BID_07', 'BID_08', 'BID_11']
                RETURN
                    COUNT(DISTINCT CASE WHEN b.id = 'BID_06' THEN f.id END) AS noMFAUsed,
                    COUNT(DISTINCT CASE WHEN b.id = 'BID_07' THEN f.id END) AS weakMFAUsed,
                    COUNT(DISTINCT CASE WHEN b.id = 'BID_08' THEN f.id END) AS compromisedPasswords,
                    COUNT(DISTINCT CASE WHEN b.id = 'BID_11' THEN f.id END) AS weakPasswords
            }
            
            UNWIND findings AS finding
            UNWIND rules AS rule
            WITH app, has, department, group, app_category, account, auth_types, email, user, 
                 passwordReuseCount, one_month_ago_epoch, finding, rule,
                 weakPasswords, compromisedPasswords, app.isMfaSupported as isMfaSupported, noMFAUsed, weakMFAUsed
            WHERE (finding)<-[:EVALUATED_TO]-(rule)
            
            OPTIONAL MATCH (finding)-[:TRIGGERED]->(action:ACTION)
            OPTIONAL MATCH (action)-[:RESULTED_IN]-(outcome:OUTCOME)
            OPTIONAL MATCH (action)-[:HAS_INTERACTION]->(interaction:INTERACTION)
            
            WITH app, has, department, group, app_category, account, auth_types, email, user,
                 passwordReuseCount, one_month_ago_epoch, isMfaSupported,
                 weakPasswords, compromisedPasswords, noMFAUsed, weakMFAUsed,
                 COUNT(DISTINCT finding.id) AS findingCount,
                 COLLECT(DISTINCT {
                     findingId: finding.id,
                     ruleName: rule.name,
                     action: action.name,
                     outcomeDesc: outcome.description,
                     actionDesc: action.description,
                     hasInteraction: CASE WHEN interaction IS NOT NULL THEN true ELSE false END
                 }) AS findingData
            
            WITH app, has, department, group, app_category, account, auth_types, email, user,
                 passwordReuseCount, one_month_ago_epoch, findingCount, findingData, isMfaSupported,
                 weakPasswords, compromisedPasswords, noMFAUsed, weakMFAUsed,
                 SIZE([data IN findingData WHERE data.hasInteraction = true]) > 0 AS interactionsExist,
                 apoc.map.fromPairs([data IN findingData WHERE data.action IS NOT NULL | [data.action, COALESCE(data.outcomeDesc, data.actionDesc)]]) AS actionCurrentState,
                 apoc.map.fromPairs([data IN findingData WHERE data.hasInteraction = true AND data.ruleName IS NOT NULL | [data.ruleName, true]]) AS ruleInteractionMap
            
            WITH app, has, department, group, app_category, account, auth_types, email, user,
                 passwordReuseCount, one_month_ago_epoch, findingCount, actionCurrentState, 
                 interactionsExist, ruleInteractionMap, isMfaSupported, weakPasswords, compromisedPasswords, noMFAUsed, weakMFAUsed,
                 (EXISTS((app)-[:WHITELISTED_FOR]->(:BEHAVIOR {id: $behavior})) OR EXISTS((account)-[:WHITELISTED_FOR]->(:BEHAVIOR {id: $behavior}))) AS is_whitelisted
            
            WHERE app.name IS NOT NULL AND toLower(email.id) =~ toLower('.*{searchText}.*')
            {placeholder}
            
            WITH email.id AS userMail,
                 user.displayName AS userName,
                 COALESCE(app.name, app.domain, app.id) AS appName,
                 user.profilePicUrl AS userProfilePicUrl,
                 app.logoUrl AS appLogoUrl,
                 has.approval_status AS appStatus,
                 account.id AS accountId,
                 app.id_ as appId,
                 is_whitelisted,
                 one_month_ago_epoch,
                 isMfaSupported,
                 COLLECT(DISTINCT department.name) AS departments,
                 COLLECT(DISTINCT group.displayName) AS groups,
                 COLLECT(DISTINCT app_category.name) AS appCategories,
                 MAX(findingCount) AS totalFindingCount,
                 MAX(passwordReuseCount) AS totalPasswordReuseCount,
                 MAX(weakPasswords) AS totalWeakPasswords,
                 MAX(compromisedPasswords) AS totalCompromisedPasswords,
                 MAX(noMFAUsed) AS totalNoMFAUsed,
                 MAX(weakMFAUsed) AS totalWeakMFAUsed,
                 apoc.map.mergeList(COLLECT(actionCurrentState)) AS finalActionCurrentState,
                 apoc.map.mergeList(COLLECT(ruleInteractionMap)) AS finalRuleInteractionMap,
                 apoc.coll.contains(COLLECT(interactionsExist), true) AS hasAnyInteractions,
                 apoc.coll.flatten(COLLECT(auth_types)) AS allAuthTypes,
                 MIN(CASE WHEN account.creationTime = '-' THEN NULL ELSE account.creationTime END) AS firstAccessTime,
                 apoc.coll.contains([auth IN apoc.coll.flatten(COLLECT(auth_types)) | auth.creationTime < one_month_ago_epoch], true) AS newlyDiscovered
            
            WITH userMail, userName, appName, userProfilePicUrl, appLogoUrl, appStatus, accountId, appId, is_whitelisted, one_month_ago_epoch,
                 departments, groups, appCategories, totalFindingCount, totalPasswordReuseCount, totalWeakPasswords, totalCompromisedPasswords,
                 totalNoMFAUsed, totalWeakMFAUsed, finalActionCurrentState, finalRuleInteractionMap, hasAnyInteractions, allAuthTypes,
                 firstAccessTime, newlyDiscovered, isMfaSupported,
                 apoc.coll.max([auth IN allAuthTypes | COALESCE(auth.last_access_time, 0)]) AS lastAccessTime
            
            WITH userMail,
                   userName,
                   appName,
                   userProfilePicUrl,
                   departments,
                   groups,
                   is_whitelisted,
                   accountId,
                   appId,
                   appLogoUrl,
                   appCategories,
                   appStatus,
                   firstAccessTime,
                   lastAccessTime,
                   totalFindingCount AS findingCount,
                   finalActionCurrentState AS actionCurrentState,
                   totalPasswordReuseCount AS passwordReuseCount,
                   apoc.map.fromPairs([
                       ['Weak Passwords', totalWeakPasswords],
                       ['Compromised Passwords', totalCompromisedPasswords]
                   ]) AS passwordHygiene,
                   CASE
                       WHEN isMfaSupported <> true THEN null
                       ELSE apoc.map.fromPairs([
                           ['No MFA', totalNoMFAUsed],
                           ['Weak MFA', totalWeakMFAUsed]
                       ])
                   END AS mfaStatus,
                   hasAnyInteractions AS interactionsExist,
                   finalRuleInteractionMap AS ruleInteractionMap,
                   newlyDiscovered
            
            RETURN COUNT(*) AS totalCount"
  - id: password_reuse_overview
    name: "Password Reuse Overview Popup"
    input_params:
      appId: $appId
      accountId: AND account.id = $accountId
    dataSourceType: "knowledgegraph"
    enabled: true
    allowed_params: true
    sortOrder: ""
    sortColumn: ""
    position: null
    template: null
    className: null
    multi_value_params: []
    query: "
            MATCH (u:USER {tenant: $tenant})-[:HAS_EMAIL]->(email:EMAIL)-[AUTH_TYPE]->(account:ACCOUNT)-[:USING_APP]->(app:APPLICATION {id_: $appId})
            MATCH (account)-[:HAS_FINDING]->(finding:FINDING)<-[:EVALUATED_TO]-(rule:RULE)-[:BELONGS_TO]->(behavior:BEHAVIOR {id: 'BID_10'})
            MATCH (account)-[:HAS_CRED_FINGERPRINT]-(cred:CRED_FINGERPRINT)-[]-(same_password_account:ACCOUNT {tenant: $tenant})-[:USING_APP]->(same_password_app)
            WHERE same_password_account <> account AND same_password_account.email = account.email
            
            WITH account, app, same_password_account, same_password_app, u, email,
                EXISTS((same_password_app)-[:WHITELISTED_FOR]->(:BEHAVIOR {id: 'BID_10'})) AS is_whitelisted
                
            WHERE toLower(COALESCE(same_password_app.name, same_password_app.domain, same_password_app.id_)) =~ toLower('.*{searchText}.*')
            {placeholder}
            
            RETURN DISTINCT
                same_password_app.id_ AS same_password_app_id,
                same_password_app.name AS same_password_app_name,
                same_password_app.domain AS same_password_app_domain,
                same_password_app.logoUrl AS same_password_app_logo,
                is_whitelisted,
                COLLECT(DISTINCT
                    {
                        user_id: u.id,
                        user_name: u.displayName,
                        account_id: account.id,
                        email: u.mail,
                        profile_pic: u.profilePicUrl
                    }
                ) AS users
            ORDER BY same_password_app_name"
    pagination_query: "
            MATCH (u:USER {tenant: $tenant})-[:HAS_EMAIL]->(email:EMAIL)-[AUTH_TYPE]->(account:ACCOUNT)
            MATCH (account)-[:USING_APP]->(app:APPLICATION {id_: $appId})-[:HAS_APP_CATEGORY]->(category:APP_CATEGORY)
            MATCH (account)-[:HAS_CRED_FINGERPRINT]-(cred:CRED_FINGERPRINT)-[]-(same_password_account:ACCOUNT {tenant: $tenant})-[:USING_APP]-(same_password_app)
            WHERE same_password_account <> account AND same_password_account.email = account.email
            
            WITH account, app, same_password_account, same_password_app, u, email, category
                
            WHERE toLower(COALESCE(same_password_app.name, same_password_app.domain, same_password_app.id_)) =~ toLower('.*{searchText}.*')
            {placeholder}
            
            RETURN COUNT(DISTINCT same_password_app) AS totalCount"
  - id: credential_sharing_overview
    name: "Credential Sharing Overview Popup"
    input_params:
      appId: $appId
      accountId: AND shared_account.id = $accountId
    dataSourceType: "knowledgegraph"
    enabled: true
    allowed_params: true
    sortOrder: ""
    sortColumn: ""
    position: null
    template: null
    className: null
    multi_value_params: []
    query: "
            MATCH (app:APPLICATION {id_: $appId})<-[:USING_APP]-(shared_account:ACCOUNT {id: $accountId, subscriber: $subscriber, tenant: $tenant})
            MATCH (shared_account)<-[auth_type]-(shared_email:EMAIL)
            OPTIONAL MATCH (shared_email)<-[:HAS_EMAIL]-(shared_user:USER)
            MATCH (shared_account)<-[:CREDENTIAL_SHARED]-(account:ACCOUNT {tenant: $tenant})
            WHERE toLower(shared_account.email) <> toLower(account.email)
            MATCH (account)<-[auth_type_target:CREDSBASED_ACCOUNT]-(email:EMAIL)
            OPTIONAL MATCH (email)<-[:HAS_EMAIL]-(user:USER)
            MATCH (account)-[:HAS_FINDING]->(finding:FINDING)<-[:EVALUATED_TO]-(rule:RULE)-[:BELONGS_TO]->(behavior:BEHAVIOR {id: 'BID_09'})
            WHERE finding.sharedAccountId = shared_account.id

            OPTIONAL MATCH (user)-[:HAS_DEPARTMENT]->(department:DEPARTMENT)
            OPTIONAL MATCH (user)-[:BELONGS_TO]->(group:GROUP {userDefined: true})

            WITH department, account, auth_type, email, user, finding, group, shared_account, shared_email, shared_user,
                EXISTS((account)-[:CRED_SHARING_APPROVED_FOR]->(shared_account)) AS is_whitelisted

            WHERE toLower(COALESCE(user.displayName, user.mail)) =~ toLower('.*{searchText}.*')
            {placeholder}

            RETURN DISTINCT
                user.id AS user_id,
                user.displayName AS user_name,
                account.id AS account_id,
                user.mail AS email,
                is_whitelisted,
                user.profilePicUrl AS profile_pic,
                COLLECT(DISTINCT department.name) AS departments,
                COLLECT(DISTINCT group.displayName) AS groups"
    pagination_query: "
            MATCH (app:APPLICATION {id_: $appId})<-[:USING_APP]-(shared_account:ACCOUNT {id: $accountId, subscriber: $subscriber, tenant: $tenant})
            MATCH (shared_account)<-[auth_type]-(shared_email:EMAIL)
            OPTIONAL MATCH (shared_email)<-[:HAS_EMAIL]-(shared_user:USER)
            MATCH (shared_account)<-[:CREDENTIAL_SHARED]-(account:ACCOUNT {tenant: $tenant})
            WHERE toLower(shared_account.email) <> toLower(account.email)
            MATCH (account)<-[auth_type_target:CREDSBASED_ACCOUNT]-(email:EMAIL)
            OPTIONAL MATCH (email)<-[:HAS_EMAIL]-(user:USER)
            MATCH (account)-[:HAS_FINDING]->(finding:FINDING)<-[:EVALUATED_TO]-(rule:RULE)-[:BELONGS_TO]->(behavior:BEHAVIOR {id: 'BID_09'})
            WHERE finding.sharedAccountId = shared_account.id

            OPTIONAL MATCH (user)-[:HAS_DEPARTMENT]->(department:DEPARTMENT)
            OPTIONAL MATCH (user)-[:BELONGS_TO]->(group:GROUP {userDefined: true})

            WITH department, account, auth_type, email, user, finding, group, shared_account, shared_email, shared_user

            WHERE toLower(COALESCE(user.displayName, user.mail)) =~ toLower('.*{searchText}.*')
            {placeholder}
            
            RETURN COUNT(DISTINCT user) AS totalCount"
  - id: interactions_metadata
    query: "MATCH (account:ACCOUNT {id: $accountId, subscriber: $subscriber, tenant: $tenant})
            WITH account,
                 CASE WHEN $behavior = 'BID_09' THEN $sharedAccountId ELSE null END as shared_account_id
            OPTIONAL MATCH (shared_account:ACCOUNT {id: shared_account_id, subscriber: $subscriber, tenant: $tenant})
            WHERE shared_account_id IS NOT NULL 
              AND exists((shared_account)<-[:CREDENTIAL_SHARED]-(account))
              AND toLower(shared_account.email) <> toLower(account.email)
            
            OPTIONAL MATCH (account)<-[:CREDSBASED_ACCOUNT]-(cred_email:EMAIL)
            WHERE $behavior = 'BID_09'
            
            OPTIONAL MATCH (account)<-[:auth_type]-(user_email:EMAIL)<-[:HAS_EMAIL]-(user:USER)
            WHERE $behavior <> 'BID_09'
            
            OPTIONAL MATCH (account)-[:HAS_CRED_FINGERPRINT]-(cred:CRED_FINGERPRINT)-[]-(same_password_account:ACCOUNT {tenant: $tenant})
            WHERE $behavior <> 'BID_09' 
              AND same_password_account <> account 
              AND same_password_account.email = account.email
            
            MATCH (account)-[:HAS_FINDING]->(finding:FINDING)<-[:EVALUATED_TO]-(rule:RULE)-[:BELONGS_TO]->(behavior:BEHAVIOR {id: $behavior})
            
            WHERE ($behavior = 'BID_09' AND shared_account IS NOT NULL AND finding.sharedAccountId = shared_account.id)
               OR ($behavior <> 'BID_09')
            
            OPTIONAL MATCH (finding)-[:TRIGGERED]->(action:ACTION)-[:HAS_INTERACTION]->(interaction:INTERACTION)
            WHERE interaction IS NOT NULL
            {placeholder}
            WITH rule, interaction, action
            WHERE interaction IS NOT NULL 
              AND action IS NOT NULL
              AND interaction.messageTime IS NOT NULL
              AND btrim(COALESCE(interaction.message, apoc.text.join([interaction.header, interaction.title, interaction.description], ' '))) <> ''
              AND btrim(COALESCE(interaction.message, apoc.text.join([interaction.header, interaction.title, interaction.description], ' '))) IS NOT NULL
            
            RETURN DISTINCT 
                rule.name AS ruleName,
                btrim(COALESCE(interaction.message, apoc.text.join([interaction.header, interaction.title, interaction.description], ' '))) AS message,
                interaction.messageTime AS messageTime,
                interaction.initiator AS initiator, 
                action.name AS action, 
                interaction.channel AS channel, 
                interaction.mode AS mode
            ORDER BY interaction.messageTime ASC"
    input_params:
      behavior: $behavior
      accountId: $accountId
      sharedAccountId: $sharedAccountId
      ruleName: AND tolower(rule.name) = tolower($ruleName)
    dataSourceType: "knowledgegraph"
    enabled: true
    allowed_params: true
    sortOrder: ""
    sortColumn: ""
    requestType: POST
    name: "Interaction Metadata"
    position: null
    template: null
    className: null
    multi_value_params: []
    pagination_query: "MATCH (account:ACCOUNT {id: $accountId, subscriber: $subscriber, tenant: $tenant})
            WITH account,
                 CASE WHEN $behavior = 'BID_09' THEN $sharedAccountId ELSE null END as shared_account_id
            OPTIONAL MATCH (shared_account:ACCOUNT {id: shared_account_id, subscriber: $subscriber, tenant: $tenant})
            WHERE shared_account_id IS NOT NULL 
              AND exists((shared_account)<-[:CREDENTIAL_SHARED]-(account))
              AND toLower(shared_account.email) <> toLower(account.email)
            
            OPTIONAL MATCH (account)<-[:CREDSBASED_ACCOUNT]-(cred_email:EMAIL)
            WHERE $behavior = 'BID_09'
            
            OPTIONAL MATCH (account)<-[:auth_type]-(user_email:EMAIL)<-[:HAS_EMAIL]-(user:USER)
            WHERE $behavior <> 'BID_09'
            
            OPTIONAL MATCH (account)-[:HAS_CRED_FINGERPRINT]-(cred:CRED_FINGERPRINT)-[]-(same_password_account:ACCOUNT {tenant: $tenant})
            WHERE $behavior <> 'BID_09' 
              AND same_password_account <> account 
              AND same_password_account.email = account.email
            
            MATCH (account)-[:HAS_FINDING]->(finding:FINDING)<-[:EVALUATED_TO]-(rule:RULE)-[:BELONGS_TO]->(behavior:BEHAVIOR {id: $behavior})
            
            WHERE ($behavior = 'BID_09' AND shared_account IS NOT NULL AND finding.sharedAccountId = shared_account.id)
               OR ($behavior <> 'BID_09')
            
            OPTIONAL MATCH (finding)-[:TRIGGERED]->(action:ACTION)-[:HAS_INTERACTION]->(interaction:INTERACTION)
            WHERE interaction IS NOT NULL
            {placeholder}
            WITH rule, interaction, action
            WHERE interaction IS NOT NULL 
              AND action IS NOT NULL
              AND interaction.messageTime IS NOT NULL
              AND btrim(COALESCE(interaction.message, apoc.text.join([interaction.header, interaction.title, interaction.description], ' '))) <> ''
              AND btrim(COALESCE(interaction.message, apoc.text.join([interaction.header, interaction.title, interaction.description], ' '))) IS NOT NULL
            
            WITH DISTINCT 
                rule.name AS ruleName,
                btrim(COALESCE(interaction.message, apoc.text.join([interaction.header, interaction.title, interaction.description], ' '))) AS message,
                interaction.messageTime AS messageTime,
                interaction.initiator AS initiator, 
                action.name AS action, 
                interaction.channel AS channel, 
                interaction.mode AS mode
            
            RETURN COUNT(*) AS totalCount"
view_by:
  - id: BID_05
    name: "MFA not supported"
    type: widget
    active: true
    defaultValue: null
    queryFilters: []
    className: ""
    query: "CALL {
              MATCH (finding:FINDING {tenant: $tenant})<-[:EVALUATED_TO]-(rule:RULE)-[:BELONGS_TO]->(behavior:BEHAVIOR {id: $behavior})
              MATCH (u:USER {tenant: $tenant})-[:HAS_EMAIL]->(email:EMAIL)-[AUTH_TYPE]->(account:ACCOUNT)-[:HAS_FINDING]->(finding)
              MATCH (account)-[:USING_APP]->(app:APPLICATION)
              OPTIONAL MATCH (app)-[:HAS_APP_CATEGORY]->(category:APP_CATEGORY)
          
              OPTIONAL MATCH (app)-[:HAS_ADMIN]->(owner:ACCOUNT {tenant: $tenant})
              OPTIONAL MATCH (finding)-[:TRIGGERED]->(action:ACTION)
              OPTIONAL MATCH (action)-[:RESULTED_IN]->(outcome:OUTCOME)
              OPTIONAL MATCH (t:TENANT {id: $tenant})-[hs:HAS_APP_SETTINGS]->(app)
          
              WITH app, owner, account, AUTH_TYPE, hs, category, finding, action,
              COALESCE(action.name, '-') AS actionName, COUNT(DISTINCT action.id) AS actionCount,
              CASE WHEN action IS NOT NULL AND outcome IS NULL THEN 'User Not Responded'
                  WHEN outcome IS NOT NULL THEN COALESCE(outcome.value, outcome.message, '-')
              END as outcomeValue,
              COUNT(DISTINCT action.id) as outcomeCount
          
              WITH app, owner, account, AUTH_TYPE, hs, category, finding, action,
              actionName, actionCount, apoc.map.fromPairs(COLLECT([outcomeValue, outcomeCount])) as outcomeMap
          
              CALL {
                  WITH app
                  MATCH (:APPLICATION {id_: app.id_})-[:USING_APP]-(a:ACCOUNT {tenant: $tenant})-[]-(:EMAIL)-[]-(:USER)
                  RETURN COUNT(DISTINCT a) AS totalAppAccounts
              }
          
              WITH 
                  app, hs,
                  COLLECT(DISTINCT owner.email) AS appAdmin, 
                  totalAppAccounts AS accounts,
                  COLLECT(DISTINCT {name: category.name, priority: category.priority}) AS categories, 
                  MIN(CASE WHEN account.creationTime = '-' THEN NULL ELSE account.creationTime END) AS firstAccessTime,
                  MAX(COALESCE(AUTH_TYPE.last_access_time, 0)) AS lastAccessTime,  
                  COALESCE(hs.approval_status, 'NEEDS REVIEW') AS status, 
                  app.logoUrl AS logo, 
                  COUNT(DISTINCT CASE WHEN finding IS NOT NULL THEN account.id END) AS accountsWithFindings,
                  apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, actionCount] END)) AS actionResults,
                  apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, outcomeMap] END)) AS actionOutcomes,
                  COUNT(DISTINCT CASE WHEN action IS NOT NULL THEN account.id END) AS accountsActioned,
                  CASE 
                      WHEN app.totalScore IN [1, 2] THEN 'Very High'
                      WHEN app.totalScore IN [3, 4] THEN 'High'
                      WHEN app.totalScore IN [5, 6] THEN 'Moderate'
                      WHEN app.totalScore IN [7, 8] THEN 'Low'
                      WHEN app.totalScore IN [9, 10] THEN 'Very Low'
                      ELSE 'Unknown'
                  END AS appRiskLevel
          
              RETURN 
                  app, hs,
                  appAdmin, 
                  accounts,
                  categories, 
                  firstAccessTime,
                  lastAccessTime,  
                  status, 
                  logo, 
                  appRiskLevel,
                  accountsWithFindings,
                  actionResults,
                  actionOutcomes,
                  {
                      actioned: accountsActioned,
                      pending: accountsWithFindings - accountsActioned
                  } AS reviewStatus
          }
          
          WITH app, hs, appAdmin, appRiskLevel, categories, lastAccessTime, firstAccessTime, accountsWithFindings,
              status, logo, accounts AS totalAccounts, reviewStatus,
              datetime.truncate('day', datetime() - duration('P1M')).epochMillis AS one_month_ago_epoch, actionResults, actionOutcomes
          
          WHERE toLower(COALESCE(app.name, app.domain)) CONTAINS toLower('{searchText}')
          {placeholder}
          
          RETURN DISTINCT
              COALESCE(app.id_, app.internalId) AS id, 
              COALESCE(app.name, app.domain, app.id) AS app, 
              appRiskLevel,
              COALESCE(app.criticality, 'Not Set') AS criticality, 
              status, 
              COALESCE(firstAccessTime > one_month_ago_epoch, true) AS newlyDiscovered,
              logo, 
              [cat IN categories WHERE cat.priority = 2 | cat.name] AS highPriorityCategories, 
              totalAccounts, 
              accountsWithFindings, 
              lastAccessTime, 
              firstAccessTime,
              reviewStatus,
              actionResults,
              actionOutcomes
          ORDER BY 
            CASE
              WHEN newlyDiscovered = true THEN 1
              ELSE 0
            END DESC,
            lastAccessTime DESC"
    allowed_params: true
    input_params:
      behavior: $behavior
      risk_level: AND appRiskLevel = $risk_level
      criticality: AND toLower(COALESCE(hs.criticality, app.criticality)) = toLower($criticality)
      approval_status: AND toLower(status) = toLower($approval_status)
      number_of_accounts_greater_than: AND totalAccounts > $number_of_accounts_greater_than
      number_of_accounts_less_than: AND totalAccounts < $number_of_accounts_less_than
      technical_owner: AND appAdmin = $technical_owner
      newly_discovered: AND NOT status in ['APPROVED', 'UNAPPROVED'] AND COALESCE(firstAccessTime > one_month_ago_epoch, true) = $newly_discovered
      action_status: AND CASE WHEN toLower($action_status) = 'actioned' THEN reviewStatus['actioned'] > 0 ELSE reviewStatus['actioned'] = 0 END
      password_hygiene: AND passwordHygiene[$password_hygiene] > 0
      mfa_status: AND CASE WHEN $mfa_status = 'null' THEN mfaStatus IS NULL ELSE mfaStatus[$mfa_status] > 0 END
    dataSourceType: "knowledgegraph"
    pagination_query: "
          CALL {
              MATCH (finding:FINDING {tenant: $tenant})<-[:EVALUATED_TO]-(rule:RULE)-[:BELONGS_TO]->(behavior:BEHAVIOR {id: $behavior})
              MATCH (u:USER {tenant: $tenant})-[:HAS_EMAIL]->(email:EMAIL)-[AUTH_TYPE]->(account:ACCOUNT)-[:HAS_FINDING]->(finding)
              MATCH (account)-[:USING_APP]->(app:APPLICATION)
              OPTIONAL MATCH (app)-[:HAS_APP_CATEGORY]->(category:APP_CATEGORY)
          
              OPTIONAL MATCH (app)-[:HAS_ADMIN]->(owner:ACCOUNT {tenant: $tenant})
              OPTIONAL MATCH (finding)-[:TRIGGERED]->(action:ACTION)
              OPTIONAL MATCH (action)-[:RESULTED_IN]->(outcome:OUTCOME)
              OPTIONAL MATCH (t:TENANT {id: $tenant})-[hs:HAS_APP_SETTINGS]->(app)
          
              WITH app, owner, account, AUTH_TYPE, hs, category, finding, action,
              COALESCE(action.name, '-') AS actionName, COUNT(DISTINCT action.id) AS actionCount,
              CASE WHEN action IS NOT NULL AND outcome IS NULL THEN 'User Not Responded'
                  WHEN outcome IS NOT NULL THEN COALESCE(outcome.value, outcome.message, '-')
              END as outcomeValue,
              COUNT(DISTINCT action.id) as outcomeCount
          
              WITH app, owner, account, AUTH_TYPE, hs, category, finding, action,
              actionName, actionCount, apoc.map.fromPairs(COLLECT([outcomeValue, outcomeCount])) as outcomeMap
          
              CALL {
                  WITH app
                  MATCH (:APPLICATION {id_: app.id_})-[:USING_APP]-(a:ACCOUNT {tenant: $tenant})-[]-(:EMAIL)-[]-(:USER)
                  RETURN COUNT(DISTINCT a) AS totalAppAccounts
              }
          
              WITH 
                  app, hs,
                  COLLECT(DISTINCT owner.email) AS appAdmin, 
                  totalAppAccounts AS accounts,
                  COLLECT(DISTINCT {name: category.name, priority: category.priority}) AS categories, 
                  MIN(CASE WHEN account.creationTime = '-' THEN NULL ELSE account.creationTime END) AS firstAccessTime,
                  MAX(COALESCE(AUTH_TYPE.last_access_time, 0)) AS lastAccessTime,  
                  COALESCE(hs.approval_status, 'NEEDS REVIEW') AS status, 
                  app.logoUrl AS logo, 
                  COUNT(DISTINCT CASE WHEN finding IS NOT NULL THEN account.id END) AS accountsWithFindings,
                  apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, actionCount] END)) AS actionResults,
                  apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, outcomeMap] END)) AS actionOutcomes,
                  COUNT(DISTINCT CASE WHEN action IS NOT NULL THEN account.id END) AS accountsActioned,
                  CASE 
                      WHEN app.totalScore IN [1, 2] THEN 'Very High'
                      WHEN app.totalScore IN [3, 4] THEN 'High'
                      WHEN app.totalScore IN [5, 6] THEN 'Moderate'
                      WHEN app.totalScore IN [7, 8] THEN 'Low'
                      WHEN app.totalScore IN [9, 10] THEN 'Very Low'
                      ELSE 'Unknown'
                  END AS appRiskLevel
          
              RETURN 
                  app, hs,
                  appAdmin, 
                  accounts,
                  categories, 
                  firstAccessTime,
                  lastAccessTime,  
                  status, 
                  logo, 
                  appRiskLevel,
                  accountsWithFindings,
                  actionResults,
                  actionOutcomes,
                  {
                      actioned: accountsActioned,
                      pending: accountsWithFindings - accountsActioned
                  } AS reviewStatus
          }
          
          WITH app, hs, appAdmin, appRiskLevel, categories, lastAccessTime, firstAccessTime, accountsWithFindings,
              status, logo, accounts AS totalAccounts, reviewStatus,
              datetime.truncate('day', datetime() - duration('P1M')).epochMillis AS one_month_ago_epoch, actionResults, actionOutcomes
          
          WHERE toLower(COALESCE(app.name, app.domain)) CONTAINS toLower('{searchText}')
          {placeholder}

          RETURN
              COUNT(DISTINCT COALESCE(app.id_, app.internalId)) AS totalCount"
  - id: BID_06
    name: "No MFA used"
    type: widget
    active: true
    defaultValue: null
    queryFilters: []
    className: ""
    query: "CALL {
              MATCH (finding:FINDING {tenant: $tenant})<-[:EVALUATED_TO]-(rule:RULE)-[:BELONGS_TO]->(behavior:BEHAVIOR {id: $behavior})
              MATCH (u:USER {tenant: $tenant})-[:HAS_EMAIL]->(email:EMAIL)-[AUTH_TYPE]->(account:ACCOUNT)-[:HAS_FINDING]->(finding)
              MATCH (account)-[:USING_APP]->(app:APPLICATION)
              OPTIONAL MATCH (app)-[:HAS_APP_CATEGORY]->(category:APP_CATEGORY)
          
              OPTIONAL MATCH (app)-[:HAS_ADMIN]->(owner:ACCOUNT {tenant: $tenant})
              OPTIONAL MATCH (finding)-[:TRIGGERED]->(action:ACTION)
              OPTIONAL MATCH (action)-[:RESULTED_IN]->(outcome:OUTCOME)
              OPTIONAL MATCH (t:TENANT {id: $tenant})-[hs:HAS_APP_SETTINGS]->(app)
          
              WITH app, owner, account, AUTH_TYPE, hs, category, finding, action,
              COALESCE(action.name, '-') AS actionName, COUNT(DISTINCT action.id) AS actionCount,
              CASE WHEN action IS NOT NULL AND outcome IS NULL THEN 'User Not Responded'
                  WHEN outcome IS NOT NULL THEN COALESCE(outcome.value, outcome.message, '-')
              END as outcomeValue,
              COUNT(DISTINCT action.id) as outcomeCount
          
              WITH app, owner, account, AUTH_TYPE, hs, category, finding, action,
              actionName, actionCount, apoc.map.fromPairs(COLLECT([outcomeValue, outcomeCount])) as outcomeMap
          
              CALL {
                  WITH app
                  MATCH (:APPLICATION {id_: app.id_})-[:USING_APP]-(a:ACCOUNT {tenant: $tenant})-[]-(:EMAIL)-[]-(:USER)
                  RETURN COUNT(DISTINCT a) AS totalAppAccounts
              }
          
              WITH 
                  app, hs,
                  COLLECT(DISTINCT owner.email) AS appAdmin, 
                  totalAppAccounts AS accounts,
                  COLLECT(DISTINCT {name: category.name, priority: category.priority}) AS categories, 
                  MIN(CASE WHEN account.creationTime = '-' THEN NULL ELSE account.creationTime END) AS firstAccessTime,
                  MAX(COALESCE(AUTH_TYPE.last_access_time, 0)) AS lastAccessTime,  
                  COALESCE(hs.approval_status, 'NEEDS REVIEW') AS status, 
                  app.logoUrl AS logo, 
                  COUNT(DISTINCT CASE WHEN finding IS NOT NULL THEN account.id END) AS accountsWithFindings,
                  apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, actionCount] END)) AS actionResults,
                  apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, outcomeMap] END)) AS actionOutcomes,
                  COUNT(DISTINCT CASE WHEN action IS NOT NULL THEN account.id END) AS accountsActioned,
                  CASE 
                      WHEN app.totalScore IN [1, 2] THEN 'Very High'
                      WHEN app.totalScore IN [3, 4] THEN 'High'
                      WHEN app.totalScore IN [5, 6] THEN 'Moderate'
                      WHEN app.totalScore IN [7, 8] THEN 'Low'
                      WHEN app.totalScore IN [9, 10] THEN 'Very Low'
                      ELSE 'Unknown'
                  END AS appRiskLevel
          
              RETURN 
                  app, hs,
                  appAdmin, 
                  accounts,
                  categories, 
                  firstAccessTime,
                  lastAccessTime,  
                  status, 
                  logo, 
                  appRiskLevel,
                  accountsWithFindings,
                  actionResults,
                  actionOutcomes,
                  {
                      actioned: accountsActioned,
                      pending: accountsWithFindings - accountsActioned
                  } AS reviewStatus
          }
          
          WITH app, hs, appAdmin, appRiskLevel, categories, lastAccessTime, firstAccessTime, accountsWithFindings,
              status, logo, accounts AS totalAccounts, reviewStatus,
              datetime.truncate('day', datetime() - duration('P1M')).epochMillis AS one_month_ago_epoch, actionResults, actionOutcomes
          
          WHERE toLower(COALESCE(app.name, app.domain)) CONTAINS toLower('{searchText}')
          {placeholder}
          
          RETURN DISTINCT
              COALESCE(app.id_, app.internalId) AS id, 
              COALESCE(app.name, app.domain, app.id) AS app, 
              appAdmin, 
              appRiskLevel,
              COALESCE(app.criticality, 'Not Set') AS criticality, 
              status, 
              COALESCE(firstAccessTime > one_month_ago_epoch, true) AS newlyDiscovered,
              logo, 
              [cat IN categories WHERE cat.priority = 2 | cat.name] AS highPriorityCategories, 
              totalAccounts, 
              accountsWithFindings, 
              lastAccessTime, 
              firstAccessTime,
              reviewStatus,
              actionResults,
              actionOutcomes
          ORDER BY 
            CASE
              WHEN newlyDiscovered = true THEN 1
              ELSE 0
            END DESC,
            lastAccessTime DESC"
    allowed_params: true
    input_params:
      behavior: $behavior
      risk_level: AND toLower(appRiskLevel) IN [ x IN [$risk_level] | toLower(x) ]
      criticality: AND (
        toLower($criticality) = 'not critical' AND toLower(COALESCE(app.criticality, 'Not Set')) <> 'critical'
        OR toLower($criticality) <> 'not critical' AND toLower(COALESCE(app.criticality, 'Not Set')) = toLower($criticality))
      approval_status: AND toLower(status) IN [ x IN [$approval_status] | toLower(x) ]
      number_of_accounts_greater_than: AND totalAccounts > $number_of_accounts_greater_than
      number_of_accounts_less_than: AND totalAccounts < $number_of_accounts_less_than
      technical_owner: AND appAdmin = $technical_owner
      newly_discovered: AND NOT status in ['APPROVED', 'UNAPPROVED'] AND COALESCE(firstAccessTime > one_month_ago_epoch, true) = $newly_discovered
      action_status: AND CASE WHEN toLower($action_status) = 'actioned' THEN reviewStatus['actioned'] > 0 ELSE reviewStatus['actioned'] = 0 END
      password_hygiene: AND passwordHygiene[$password_hygiene] > 0
      mfa_status: AND CASE WHEN $mfa_status = 'null' THEN mfaStatus IS NULL ELSE mfaStatus[$mfa_status] > 0 END
    dataSourceType: "knowledgegraph"
    multi_value_params:
      - id: risk_level
        delimiter: ","
      - id: approval_status
        delimiter: ","
    pagination_query: "
          CALL {
              MATCH (finding:FINDING {tenant: $tenant})<-[:EVALUATED_TO]-(rule:RULE)-[:BELONGS_TO]->(behavior:BEHAVIOR {id: $behavior})
              MATCH (u:USER {tenant: $tenant})-[:HAS_EMAIL]->(email:EMAIL)-[AUTH_TYPE]->(account:ACCOUNT)-[:HAS_FINDING]->(finding)
              MATCH (account)-[:USING_APP]->(app:APPLICATION)
              OPTIONAL MATCH (app)-[:HAS_APP_CATEGORY]->(category:APP_CATEGORY)
          
              OPTIONAL MATCH (app)-[:HAS_ADMIN]->(owner:ACCOUNT {tenant: $tenant})
              OPTIONAL MATCH (finding)-[:TRIGGERED]->(action:ACTION)
              OPTIONAL MATCH (action)-[:RESULTED_IN]->(outcome:OUTCOME)
              OPTIONAL MATCH (t:TENANT {id: $tenant})-[hs:HAS_APP_SETTINGS]->(app)
          
              WITH app, owner, account, AUTH_TYPE, hs, category, finding, action,
              COALESCE(action.name, '-') AS actionName, COUNT(DISTINCT action.id) AS actionCount,
              CASE WHEN action IS NOT NULL AND outcome IS NULL THEN 'User Not Responded'
                  WHEN outcome IS NOT NULL THEN COALESCE(outcome.value, outcome.message, '-')
              END as outcomeValue,
              COUNT(DISTINCT action.id) as outcomeCount
          
              WITH app, owner, account, AUTH_TYPE, hs, category, finding, action,
              actionName, actionCount, apoc.map.fromPairs(COLLECT([outcomeValue, outcomeCount])) as outcomeMap
          
              CALL {
                  WITH app
                  MATCH (:APPLICATION {id_: app.id_})-[:USING_APP]-(a:ACCOUNT {tenant: $tenant})-[]-(:EMAIL)-[]-(:USER)
                  RETURN COUNT(DISTINCT a) AS totalAppAccounts
              }
          
              WITH 
                  app, hs,
                  COLLECT(DISTINCT owner.email) AS appAdmin, 
                  totalAppAccounts AS accounts,
                  COLLECT(DISTINCT {name: category.name, priority: category.priority}) AS categories, 
                  MIN(CASE WHEN account.creationTime = '-' THEN NULL ELSE account.creationTime END) AS firstAccessTime,
                  MAX(COALESCE(AUTH_TYPE.last_access_time, 0)) AS lastAccessTime,  
                  COALESCE(hs.approval_status, 'NEEDS REVIEW') AS status, 
                  app.logoUrl AS logo, 
                  COUNT(DISTINCT CASE WHEN finding IS NOT NULL THEN account.id END) AS accountsWithFindings,
                  apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, actionCount] END)) AS actionResults,
                  apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, outcomeMap] END)) AS actionOutcomes,
                  COUNT(DISTINCT CASE WHEN action IS NOT NULL THEN account.id END) AS accountsActioned,
                  CASE 
                      WHEN app.totalScore IN [1, 2] THEN 'Very High'
                      WHEN app.totalScore IN [3, 4] THEN 'High'
                      WHEN app.totalScore IN [5, 6] THEN 'Moderate'
                      WHEN app.totalScore IN [7, 8] THEN 'Low'
                      WHEN app.totalScore IN [9, 10] THEN 'Very Low'
                      ELSE 'Unknown'
                  END AS appRiskLevel
          
              RETURN 
                  app, hs,
                  appAdmin, 
                  accounts,
                  categories, 
                  firstAccessTime,
                  lastAccessTime,  
                  status, 
                  logo, 
                  appRiskLevel,
                  accountsWithFindings,
                  actionResults,
                  actionOutcomes,
                  {
                      actioned: accountsActioned,
                      pending: accountsWithFindings - accountsActioned
                  } AS reviewStatus
          }
          
          WITH app, hs, appAdmin, appRiskLevel, categories, lastAccessTime, firstAccessTime, accountsWithFindings,
              status, logo, accounts AS totalAccounts, reviewStatus,
              datetime.truncate('day', datetime() - duration('P1M')).epochMillis AS one_month_ago_epoch, actionResults, actionOutcomes
          
          WHERE toLower(COALESCE(app.name, app.domain)) CONTAINS toLower('{searchText}')
          {placeholder}

          RETURN
              COUNT(DISTINCT COALESCE(app.id_, app.internalId)) AS totalCount"
  - id: BID_07
    name: "Weak MFA used"
    type: widget
    active: true
    defaultValue: null
    queryFilters: []
    className: ""
    query: "CALL {
              MATCH (finding:FINDING {tenant: $tenant})<-[:EVALUATED_TO]-(rule:RULE)-[:BELONGS_TO]->(behavior:BEHAVIOR {id: $behavior})
              MATCH (u:USER {tenant: $tenant})-[:HAS_EMAIL]->(email:EMAIL)-[AUTH_TYPE]->(account:ACCOUNT)-[:HAS_FINDING]->(finding)
              MATCH (account)-[:USING_APP]->(app:APPLICATION)
              OPTIONAL MATCH (app)-[:HAS_APP_CATEGORY]->(category:APP_CATEGORY)
          
              OPTIONAL MATCH (app)-[:HAS_ADMIN]->(owner:ACCOUNT {tenant: $tenant})
              OPTIONAL MATCH (finding)-[:TRIGGERED]->(action:ACTION)
              OPTIONAL MATCH (action)-[:RESULTED_IN]->(outcome:OUTCOME)
              OPTIONAL MATCH (t:TENANT {id: $tenant})-[hs:HAS_APP_SETTINGS]->(app)
          
              WITH app, owner, account, AUTH_TYPE, hs, category, finding, action,
              COALESCE(action.name, '-') AS actionName, COUNT(DISTINCT action.id) AS actionCount,
              CASE WHEN action IS NOT NULL AND outcome IS NULL THEN 'User Not Responded'
                  WHEN outcome IS NOT NULL THEN COALESCE(outcome.value, outcome.message, '-')
              END as outcomeValue,
              COUNT(DISTINCT action.id) as outcomeCount
          
              WITH app, owner, account, AUTH_TYPE, hs, category, finding, action,
              actionName, actionCount, apoc.map.fromPairs(COLLECT([outcomeValue, outcomeCount])) as outcomeMap
          
              CALL {
                  WITH app
                  MATCH (:APPLICATION {id_: app.id_})-[:USING_APP]-(a:ACCOUNT {tenant: $tenant})-[]-(:EMAIL)-[]-(:USER)
                  RETURN COUNT(DISTINCT a) AS totalAppAccounts
              }
          
              WITH 
                  app, hs,
                  COLLECT(DISTINCT owner.email) AS appAdmin, 
                  totalAppAccounts AS accounts,
                  COLLECT(DISTINCT {name: category.name, priority: category.priority}) AS categories, 
                  MIN(CASE WHEN account.creationTime = '-' THEN NULL ELSE account.creationTime END) AS firstAccessTime,
                  MAX(COALESCE(AUTH_TYPE.last_access_time, 0)) AS lastAccessTime,  
                  COALESCE(hs.approval_status, 'NEEDS REVIEW') AS status, 
                  app.logoUrl AS logo, 
                  COUNT(DISTINCT CASE WHEN finding IS NOT NULL THEN account.id END) AS accountsWithFindings,
                  apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, actionCount] END)) AS actionResults,
                  apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, outcomeMap] END)) AS actionOutcomes,
                  COUNT(DISTINCT CASE WHEN action IS NOT NULL THEN account.id END) AS accountsActioned,
                  CASE 
                      WHEN app.totalScore IN [1, 2] THEN 'Very High'
                      WHEN app.totalScore IN [3, 4] THEN 'High'
                      WHEN app.totalScore IN [5, 6] THEN 'Moderate'
                      WHEN app.totalScore IN [7, 8] THEN 'Low'
                      WHEN app.totalScore IN [9, 10] THEN 'Very Low'
                      ELSE 'Unknown'
                  END AS appRiskLevel
          
              RETURN 
                  app, hs,
                  appAdmin, 
                  accounts,
                  categories, 
                  firstAccessTime,
                  lastAccessTime,  
                  status, 
                  logo, 
                  appRiskLevel,
                  accountsWithFindings,
                  actionResults,
                  actionOutcomes,
                  {
                      actioned: accountsActioned,
                      pending: accountsWithFindings - accountsActioned
                  } AS reviewStatus
          }
          
          WITH app, hs, appAdmin, appRiskLevel, categories, lastAccessTime, firstAccessTime, accountsWithFindings,
              status, logo, accounts AS totalAccounts, reviewStatus,
              datetime.truncate('day', datetime() - duration('P1M')).epochMillis AS one_month_ago_epoch, actionResults, actionOutcomes
          
          WHERE toLower(COALESCE(app.name, app.domain)) CONTAINS toLower('{searchText}')
          {placeholder}
          
          RETURN DISTINCT
              COALESCE(app.id_, app.internalId) AS id, 
              COALESCE(app.name, app.domain, app.id) AS app, 
              appAdmin, 
              appRiskLevel,
              COALESCE(app.criticality, 'Not Set') AS criticality, 
              status, 
              COALESCE(firstAccessTime > one_month_ago_epoch, true) AS newlyDiscovered,
              logo, 
              [cat IN categories WHERE cat.priority = 2 | cat.name] AS highPriorityCategories, 
              totalAccounts, 
              accountsWithFindings,
              lastAccessTime, 
              firstAccessTime,
              reviewStatus,
              actionResults,
              actionOutcomes
          ORDER BY 
            CASE
              WHEN newlyDiscovered = true THEN 1
              ELSE 0
            END DESC,
            lastAccessTime DESC"
    allowed_params: true
    input_params:
      behavior: $behavior
      risk_level: AND appRiskLevel = $risk_level
      criticality: AND toLower(COALESCE(hs.criticality, app.criticality)) = toLower($criticality)
      approval_status: AND toLower(status) = toLower($approval_status)
      number_of_accounts_greater_than: AND totalAccounts > $number_of_accounts_greater_than
      number_of_accounts_less_than: AND totalAccounts < $number_of_accounts_less_than
      technical_owner: AND appAdmin = $technical_owner
      newly_discovered: AND NOT status in ['APPROVED', 'UNAPPROVED'] AND COALESCE(firstAccessTime > one_month_ago_epoch, true) = $newly_discovered
      action_status: AND CASE WHEN toLower($action_status) = 'actioned' THEN reviewStatus['actioned'] > 0 ELSE reviewStatus['actioned'] = 0 END
      password_hygiene: AND passwordHygiene[$password_hygiene] > 0
      mfa_status: AND CASE WHEN $mfa_status = 'null' THEN mfaStatus IS NULL ELSE mfaStatus[$mfa_status] > 0 END
    dataSourceType: "knowledgegraph"
    pagination_query: "
          CALL {
              MATCH (finding:FINDING {tenant: $tenant})<-[:EVALUATED_TO]-(rule:RULE)-[:BELONGS_TO]->(behavior:BEHAVIOR {id: $behavior})
              MATCH (u:USER {tenant: $tenant})-[:HAS_EMAIL]->(email:EMAIL)-[AUTH_TYPE]->(account:ACCOUNT)-[:HAS_FINDING]->(finding)
              MATCH (account)-[:USING_APP]->(app:APPLICATION)
              OPTIONAL MATCH (app)-[:HAS_APP_CATEGORY]->(category:APP_CATEGORY)
          
              OPTIONAL MATCH (app)-[:HAS_ADMIN]->(owner:ACCOUNT {tenant: $tenant})
              OPTIONAL MATCH (finding)-[:TRIGGERED]->(action:ACTION)
              OPTIONAL MATCH (action)-[:RESULTED_IN]->(outcome:OUTCOME)
              OPTIONAL MATCH (t:TENANT {id: $tenant})-[hs:HAS_APP_SETTINGS]->(app)
          
              WITH app, owner, account, AUTH_TYPE, hs, category, finding, action,
              COALESCE(action.name, '-') AS actionName, COUNT(DISTINCT action.id) AS actionCount,
              CASE WHEN action IS NOT NULL AND outcome IS NULL THEN 'User Not Responded'
                  WHEN outcome IS NOT NULL THEN COALESCE(outcome.value, outcome.message, '-')
              END as outcomeValue,
              COUNT(DISTINCT action.id) as outcomeCount
          
              WITH app, owner, account, AUTH_TYPE, hs, category, finding, action,
              actionName, actionCount, apoc.map.fromPairs(COLLECT([outcomeValue, outcomeCount])) as outcomeMap
          
              CALL {
                  WITH app
                  MATCH (:APPLICATION {id_: app.id_})-[:USING_APP]-(a:ACCOUNT {tenant: $tenant})-[]-(:EMAIL)-[]-(:USER)
                  RETURN COUNT(DISTINCT a) AS totalAppAccounts
              }
          
              WITH 
                  app, hs,
                  COLLECT(DISTINCT owner.email) AS appAdmin, 
                  totalAppAccounts AS accounts,
                  COLLECT(DISTINCT {name: category.name, priority: category.priority}) AS categories, 
                  MIN(CASE WHEN account.creationTime = '-' THEN NULL ELSE account.creationTime END) AS firstAccessTime,
                  MAX(COALESCE(AUTH_TYPE.last_access_time, 0)) AS lastAccessTime,  
                  COALESCE(hs.approval_status, 'NEEDS REVIEW') AS status, 
                  app.logoUrl AS logo, 
                  COUNT(DISTINCT CASE WHEN finding IS NOT NULL THEN account.id END) AS accountsWithFindings,
                  apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, actionCount] END)) AS actionResults,
                  apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, outcomeMap] END)) AS actionOutcomes,
                  COUNT(DISTINCT CASE WHEN action IS NOT NULL THEN account.id END) AS accountsActioned,
                  CASE 
                      WHEN app.totalScore IN [1, 2] THEN 'Very High'
                      WHEN app.totalScore IN [3, 4] THEN 'High'
                      WHEN app.totalScore IN [5, 6] THEN 'Moderate'
                      WHEN app.totalScore IN [7, 8] THEN 'Low'
                      WHEN app.totalScore IN [9, 10] THEN 'Very Low'
                      ELSE 'Unknown'
                  END AS appRiskLevel
          
              RETURN 
                  app, hs,
                  appAdmin, 
                  accounts,
                  categories, 
                  firstAccessTime,
                  lastAccessTime,  
                  status, 
                  logo, 
                  appRiskLevel,
                  accountsWithFindings,
                  actionResults,
                  actionOutcomes,
                  {
                      actioned: accountsActioned,
                      pending: accountsWithFindings - accountsActioned
                  } AS reviewStatus
          }
          
          WITH app, hs, appAdmin, appRiskLevel, categories, lastAccessTime, firstAccessTime, accountsWithFindings,
              status, logo, accounts AS totalAccounts, reviewStatus,
              datetime.truncate('day', datetime() - duration('P1M')).epochMillis AS one_month_ago_epoch, actionResults, actionOutcomes
          
          WHERE toLower(COALESCE(app.name, app.domain)) CONTAINS toLower('{searchText}')
          {placeholder}

          RETURN
              COUNT(DISTINCT COALESCE(app.id_, app.internalId)) AS totalCount"
  - id: BID_08
    name: "Compromised Password"
    type: widget
    active: true
    defaultValue: null
    queryFilters: []
    className: ""
    query: "CALL {
              MATCH (finding:FINDING {tenant: $tenant})<-[:EVALUATED_TO]-(rule:RULE)-[:BELONGS_TO]->(behavior:BEHAVIOR {id: $behavior})
              MATCH (u:USER {tenant: $tenant})-[:HAS_EMAIL]->(email:EMAIL)-[AUTH_TYPE]->(account:ACCOUNT)-[:HAS_FINDING]->(finding)
              MATCH (account)-[:USING_APP]->(app:APPLICATION)
              OPTIONAL MATCH (app)-[:HAS_APP_CATEGORY]->(category:APP_CATEGORY)
          
              OPTIONAL MATCH (app)-[:HAS_ADMIN]->(owner:ACCOUNT {tenant: $tenant})
              OPTIONAL MATCH (finding)-[:TRIGGERED]->(action:ACTION)
              OPTIONAL MATCH (action)-[:RESULTED_IN]->(outcome:OUTCOME)
              OPTIONAL MATCH (t:TENANT {id: $tenant})-[hs:HAS_APP_SETTINGS]->(app)
          
              WITH app, owner, account, AUTH_TYPE, hs, category, finding, action,
              COALESCE(action.name, '-') AS actionName, COUNT(DISTINCT action.id) AS actionCount,
              CASE WHEN action IS NOT NULL AND outcome IS NULL THEN 'User Not Responded'
                  WHEN outcome IS NOT NULL THEN COALESCE(outcome.value, outcome.message, '-')
              END as outcomeValue,
              COUNT(DISTINCT action.id) as outcomeCount
          
              WITH app, owner, account, AUTH_TYPE, hs, category, finding, action,
              actionName, actionCount, apoc.map.fromPairs(COLLECT([outcomeValue, outcomeCount])) as outcomeMap
          
              CALL {
                  WITH app
                  MATCH (:APPLICATION {id_: app.id_})-[:USING_APP]-(a:ACCOUNT {tenant: $tenant})-[]-(:EMAIL)-[]-(:USER)
                  RETURN COUNT(DISTINCT a) AS totalAppAccounts
              }
          
              WITH 
                  app, hs,
                  COLLECT(DISTINCT owner.email) AS appAdmin, 
                  totalAppAccounts AS accounts,
                  COLLECT(DISTINCT {name: category.name, priority: category.priority}) AS categories, 
                  MIN(CASE WHEN account.creationTime = '-' THEN NULL ELSE account.creationTime END) AS firstAccessTime,
                  MAX(COALESCE(AUTH_TYPE.last_access_time, 0)) AS lastAccessTime,  
                  COALESCE(hs.approval_status, 'NEEDS REVIEW') AS status, 
                  app.logoUrl AS logo, 
                  COUNT(DISTINCT CASE WHEN finding IS NOT NULL THEN account.id END) AS accountsWithFindings,
                  apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, actionCount] END)) AS actionResults,
                  apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, outcomeMap] END)) AS actionOutcomes,
                  COUNT(DISTINCT CASE WHEN action IS NOT NULL THEN account.id END) AS accountsActioned,
                  CASE 
                      WHEN app.totalScore IN [1, 2] THEN 'Very High'
                      WHEN app.totalScore IN [3, 4] THEN 'High'
                      WHEN app.totalScore IN [5, 6] THEN 'Moderate'
                      WHEN app.totalScore IN [7, 8] THEN 'Low'
                      WHEN app.totalScore IN [9, 10] THEN 'Very Low'
                      ELSE 'Unknown'
                  END AS appRiskLevel
          
              RETURN 
                  app, hs,
                  appAdmin, 
                  accounts,
                  categories, 
                  firstAccessTime,
                  lastAccessTime,  
                  status, 
                  logo, 
                  appRiskLevel,
                  accountsWithFindings,
                  actionResults,
                  actionOutcomes,
                  {
                      actioned: accountsActioned,
                      pending: accountsWithFindings - accountsActioned
                  } AS reviewStatus
          }
          
          WITH app, hs, appAdmin, appRiskLevel, categories, lastAccessTime, firstAccessTime, accountsWithFindings,
              status, logo, accounts AS totalAccounts, reviewStatus,
              datetime.truncate('day', datetime() - duration('P1M')).epochMillis AS one_month_ago_epoch, actionResults, actionOutcomes
          
          WHERE toLower(COALESCE(app.name, app.domain)) CONTAINS toLower('{searchText}')
          {placeholder}
          
          RETURN DISTINCT
              COALESCE(app.id_, app.internalId) AS id, 
              COALESCE(app.name, app.domain, app.id) AS app, 
              appAdmin, 
              appRiskLevel,
              COALESCE(app.criticality, 'Not Set') AS criticality, 
              status, 
              COALESCE(firstAccessTime > one_month_ago_epoch, true) AS newlyDiscovered,
              logo, 
              [cat IN categories WHERE cat.priority = 2 | cat.name] AS highPriorityCategories, 
              totalAccounts, 
              accountsWithFindings, 
              lastAccessTime, 
              firstAccessTime,
              reviewStatus,
              actionResults,
              actionOutcomes
          ORDER BY 
            CASE
              WHEN newlyDiscovered = true THEN 1
              ELSE 0
            END DESC,
            lastAccessTime DESC"
    allowed_params: true
    input_params:
      behavior: $behavior
      risk_level: AND toLower(appRiskLevel) IN [ x IN [$risk_level] | toLower(x) ]
      criticality: AND (
        toLower(COALESCE(hs.criticality, app.criticality)) = toLower($criticality)
        AND COALESCE(hs.criticality, app.criticality) IS NOT NULL)
      approval_status: AND toLower(status) IN [ x IN [$approval_status] | toLower(x) ]
      number_of_accounts_greater_than: AND totalAccounts > $number_of_accounts_greater_than
      number_of_accounts_less_than: AND totalAccounts < $number_of_accounts_less_than
      technical_owner: AND appAdmin = $technical_owner
      newly_discovered: AND NOT status in ['APPROVED', 'UNAPPROVED'] AND COALESCE(firstAccessTime > one_month_ago_epoch, true) = $newly_discovered
      action_status: AND CASE WHEN toLower($action_status) = 'actioned' THEN reviewStatus['actioned'] > 0 ELSE reviewStatus['actioned'] = 0 END
      password_hygiene: AND passwordHygiene[$password_hygiene] > 0
      mfa_status: AND CASE WHEN $mfa_status = 'null' THEN mfaStatus IS NULL ELSE mfaStatus[$mfa_status] > 0 END
    dataSourceType: "knowledgegraph"
    multi_value_params:
      - id: risk_level
        delimiter: ","
      - id: approval_status
        delimiter: ","
    pagination_query: "
          CALL {
              MATCH (finding:FINDING {tenant: $tenant})<-[:EVALUATED_TO]-(rule:RULE)-[:BELONGS_TO]->(behavior:BEHAVIOR {id: $behavior})
              MATCH (u:USER {tenant: $tenant})-[:HAS_EMAIL]->(email:EMAIL)-[AUTH_TYPE]->(account:ACCOUNT)-[:HAS_FINDING]->(finding)
              MATCH (account)-[:USING_APP]->(app:APPLICATION)
              OPTIONAL MATCH (app)-[:HAS_APP_CATEGORY]->(category:APP_CATEGORY)
          
              OPTIONAL MATCH (app)-[:HAS_ADMIN]->(owner:ACCOUNT {tenant: $tenant})
              OPTIONAL MATCH (finding)-[:TRIGGERED]->(action:ACTION)
              OPTIONAL MATCH (action)-[:RESULTED_IN]->(outcome:OUTCOME)
              OPTIONAL MATCH (t:TENANT {id: $tenant})-[hs:HAS_APP_SETTINGS]->(app)
          
              WITH app, owner, account, AUTH_TYPE, hs, category, finding, action,
              COALESCE(action.name, '-') AS actionName, COUNT(DISTINCT action.id) AS actionCount,
              CASE WHEN action IS NOT NULL AND outcome IS NULL THEN 'User Not Responded'
                  WHEN outcome IS NOT NULL THEN COALESCE(outcome.value, outcome.message, '-')
              END as outcomeValue,
              COUNT(DISTINCT action.id) as outcomeCount
          
              WITH app, owner, account, AUTH_TYPE, hs, category, finding, action,
              actionName, actionCount, apoc.map.fromPairs(COLLECT([outcomeValue, outcomeCount])) as outcomeMap
          
              CALL {
                  WITH app
                  MATCH (:APPLICATION {id_: app.id_})-[:USING_APP]-(a:ACCOUNT {tenant: $tenant})-[]-(:EMAIL)-[]-(:USER)
                  RETURN COUNT(DISTINCT a) AS totalAppAccounts
              }
          
              WITH 
                  app, hs,
                  COLLECT(DISTINCT owner.email) AS appAdmin, 
                  totalAppAccounts AS accounts,
                  COLLECT(DISTINCT {name: category.name, priority: category.priority}) AS categories, 
                  MIN(CASE WHEN account.creationTime = '-' THEN NULL ELSE account.creationTime END) AS firstAccessTime,
                  MAX(COALESCE(AUTH_TYPE.last_access_time, 0)) AS lastAccessTime,  
                  COALESCE(hs.approval_status, 'NEEDS REVIEW') AS status, 
                  app.logoUrl AS logo, 
                  COUNT(DISTINCT CASE WHEN finding IS NOT NULL THEN account.id END) AS accountsWithFindings,
                  apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, actionCount] END)) AS actionResults,
                  apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, outcomeMap] END)) AS actionOutcomes,
                  COUNT(DISTINCT CASE WHEN action IS NOT NULL THEN account.id END) AS accountsActioned,
                  CASE 
                      WHEN app.totalScore IN [1, 2] THEN 'Very High'
                      WHEN app.totalScore IN [3, 4] THEN 'High'
                      WHEN app.totalScore IN [5, 6] THEN 'Moderate'
                      WHEN app.totalScore IN [7, 8] THEN 'Low'
                      WHEN app.totalScore IN [9, 10] THEN 'Very Low'
                      ELSE 'Unknown'
                  END AS appRiskLevel
          
              RETURN 
                  app, hs,
                  appAdmin, 
                  accounts,
                  categories, 
                  firstAccessTime,
                  lastAccessTime,  
                  status, 
                  logo, 
                  appRiskLevel,
                  accountsWithFindings,
                  actionResults,
                  actionOutcomes,
                  {
                      actioned: accountsActioned,
                      pending: accountsWithFindings - accountsActioned
                  } AS reviewStatus
          }
          
          WITH app, hs, appAdmin, appRiskLevel, categories, lastAccessTime, firstAccessTime, accountsWithFindings,
              status, logo, accounts AS totalAccounts, reviewStatus,
              datetime.truncate('day', datetime() - duration('P1M')).epochMillis AS one_month_ago_epoch, actionResults, actionOutcomes
          
          WHERE toLower(COALESCE(app.name, app.domain)) CONTAINS toLower('{searchText}')
          {placeholder}

          RETURN
              COUNT(DISTINCT COALESCE(app.id_, app.internalId)) AS totalCount"
  - id: BID_09
    name: "Credential Sharing"
    type: widget
    active: true
    defaultValue: null
    queryFilters: []
    className: ""
    query: "MATCH (app:APPLICATION)<-[using_app:USING_APP]-(shared_account:ACCOUNT {subscriber: $subscriber, tenant: $tenant})
            MATCH (shared_account)<-[auth_type:CREDSBASED_ACCOUNT]-(shared_email:EMAIL)
            OPTIONAL MATCH (shared_email)<-[:HAS_EMAIL]-(shared_user:USER)
            MATCH (shared_account)<-[:CREDENTIAL_SHARED]-(account:ACCOUNT {tenant: $tenant})
            WHERE toLower(shared_account.email) <> toLower(account.email)
            MATCH (account)<-[auth_type_target:CREDSBASED_ACCOUNT]-(email:EMAIL)
            OPTIONAL MATCH (email)<-[:HAS_EMAIL]-(user:USER)
            MATCH (account)-[:HAS_FINDING]->(finding:FINDING)<-[:EVALUATED_TO]-(rule:RULE)-[:BELONGS_TO]->(behavior:BEHAVIOR {id: $behavior})
            WHERE finding.sharedAccountId = shared_account.id

            OPTIONAL MATCH (finding)-[:TRIGGERED]->(action:ACTION)
            OPTIONAL MATCH (app)-[has:HAS_APP_SETTINGS]-(tenant:TENANT {id: $tenant})
            OPTIONAL MATCH (shared_user)-[:HAS_DEPARTMENT]->(department:DEPARTMENT)
            OPTIONAL MATCH (app)-[:HAS_APP_CATEGORY]->(app_category:APP_CATEGORY)
            OPTIONAL MATCH (shared_user)-[:BELONGS_TO]->(group:GROUP {userDefined: true})

            WITH app, has, department, app_category, account, auth_type, auth_type_target, email, user, finding, action, group, shared_account, shared_email, 
            shared_user
            
            WHERE NOT EXISTS((user)-[:SAME_USER]-(shared_user))
            
            WITH DISTINCT
                shared_email.id AS userMail,
                shared_user.displayName AS userName,
                COLLECT(DISTINCT group.displayName) AS groups,
                shared_account.id AS accountId,
                COALESCE(app.id_, app.internalId) AS appId,
                COALESCE(app.name, app.domain, app.id) AS appName,
                shared_user.profilePicUrl AS userProfilePicUrl,
                COLLECT(DISTINCT department.name) AS departments,
                app.logoUrl AS appLogoUrl,
                COLLECT(DISTINCT app_category.name) AS appCategories,
                has.approval_status AS appStatus,
                {
                    actioned: COUNT(DISTINCT CASE WHEN action IS NOT NULL THEN finding.id END),
                    pending: COUNT(DISTINCT CASE WHEN action IS NULL THEN finding.id END)
                } AS actionStatus,
                MIN(shared_account.creationTime) AS firstAccessed,
                auth_type.last_access_time AS lastAccessed,
                COUNT(DISTINCT finding.id) AS findingsCount,
                COUNT(DISTINCT account.id) AS sharedWithCount,
                COLLECT(DISTINCT {
                  userMail: toLower(email.id),
                  userName: user.displayName,
                  userPicUrl: user.profilePicUrl,
                  accountId: account.id
                }) AS sharedWith

            WHERE (toLower(userMail) CONTAINS toLower('{searchText}') OR toLower(userName) CONTAINS toLower('{searchText}'))
            {placeholder}

            RETURN DISTINCT
                userMail,
                userName,
                groups,
                accountId,
                appId,
                appName,
                userProfilePicUrl,
                departments,
                appLogoUrl,
                appCategories,
                appStatus,
                actionStatus,
                firstAccessed,
                lastAccessed,
                findingsCount,
                sharedWithCount,
                sharedWith
            ORDER BY lastAccessed DESC"
    allowed_params: true
    input_params:
      behavior: $behavior
      risk_level: AND toLower(appRiskLevel) IN [ x IN [$risk_level] | toLower(x) ]
      criticality: AND toLower(COALESCE(hs.criticality, app.criticality)) = toLower($criticality)
      app_category: AND ANY (cat IN appCategories WHERE toLower(cat) IN [x IN [$app_category] | toLower(x) ])
      approval_status: AND toLower(appStatus) IN [ x IN [$approval_status] | toLower(x) ]
      number_of_accounts_greater_than: AND toInteger(sharedWithCount) > toInteger($number_of_accounts_greater_than)
      number_of_accounts_less_than: AND toInteger(sharedWithCount) < toInteger($number_of_accounts_less_than)
      department: AND ANY(dep IN departments WHERE toLower(dep) IN [ x IN [$department] | toLower(x) ])
      group: AND ANY(g IN groups WHERE toLower(g) IN [ x IN [$group] | toLower(x) ])
      technical_owner: AND appAdmin = $technical_owner
      newly_discovered: AND NOT status in ['APPROVED', 'UNAPPROVED'] AND COALESCE(firstAccessTime > one_month_ago_epoch, true) = $newly_discovered
      action_status: AND CASE WHEN toLower($action_status) = 'actioned' THEN actionStatus['actioned'] > 0 ELSE actionStatus['actioned'] = 0 END
      password_hygiene: AND passwordHygiene[$password_hygiene] > 0
      mfa_status: AND CASE WHEN $mfa_status = 'null' THEN mfaStatus IS NULL ELSE mfaStatus[$mfa_status] > 0 END
      app_name: AND toLower(appName) IN [ x IN [$appname] | toLower(x) ]
    dataSourceType: "knowledgegraph"
    multi_value_params:
      - id: risk_level
        delimiter: ","
      - id: approval_status
        delimiter: ","
      - id: app_category
        delimiter: ","
      - id: department
        delimiter: ","
      - id: group
        delimiter: ","
      - id: app_name
        delimiter: ","
    pagination_query: "
        MATCH (app:APPLICATION)<-[using_app:USING_APP]-(shared_account:ACCOUNT {subscriber: $subscriber, tenant: $tenant})
        MATCH (shared_account)<-[auth_type:CREDSBASED_ACCOUNT]-(shared_email:EMAIL)
        OPTIONAL MATCH (shared_email)<-[:HAS_EMAIL]-(shared_user:USER)
        MATCH (shared_account)<-[:CREDENTIAL_SHARED]-(account:ACCOUNT {tenant: $tenant})
        WHERE toLower(shared_account.email) <> toLower(account.email)
        MATCH (account)<-[auth_type_target:CREDSBASED_ACCOUNT]-(email:EMAIL)
        OPTIONAL MATCH (email)<-[:HAS_EMAIL]-(user:USER)
        MATCH (account)-[:HAS_FINDING]->(finding:FINDING)<-[:EVALUATED_TO]-(rule:RULE)-[:BELONGS_TO]->(behavior:BEHAVIOR {id: $behavior})
        WHERE finding.sharedAccountId = shared_account.id

        OPTIONAL MATCH (finding)-[:TRIGGERED]->(action:ACTION)
        OPTIONAL MATCH (app)-[has:HAS_APP_SETTINGS]-(tenant:TENANT {id: $tenant})
        OPTIONAL MATCH (shared_user)-[:HAS_DEPARTMENT]->(department:DEPARTMENT)
        OPTIONAL MATCH (app)-[:HAS_APP_CATEGORY]->(app_category:APP_CATEGORY)
        OPTIONAL MATCH (shared_user)-[:BELONGS_TO]->(group:GROUP {userDefined: true})

        WITH app, has, department, app_category, account, auth_type, auth_type_target, email, user, finding, action, group, shared_account, shared_email, shared_user
            
        WHERE NOT EXISTS((user)-[:SAME_USER]-(shared_user))
            
        WITH DISTINCT
            shared_email.id AS userMail,
            shared_user.displayName AS userName,
            COLLECT(DISTINCT group.displayName) AS groups,
            shared_account.id AS accountId,
            COALESCE(app.id_, app.internalId) AS appId,
            COALESCE(app.name, app.domain, app.id) AS appName,
            shared_user.profilePicUrl AS userProfilePicUrl,
            COLLECT(DISTINCT department.name) AS departments,
            app.logoUrl AS appLogoUrl,
            COLLECT(DISTINCT app_category.name) AS appCategories,
            has.approval_status AS appStatus,
            {
                actioned: COUNT(DISTINCT CASE WHEN action IS NOT NULL THEN finding.id END),
                pending: COUNT(DISTINCT CASE WHEN action IS NULL THEN finding.id END)
            } AS actionStatus,
            MIN(shared_account.creationTime) AS firstAccessed,
            auth_type.last_access_time AS lastAccessed,
            COUNT(DISTINCT finding.id) AS findingsCount,
            COUNT(DISTINCT account.id) AS sharedWithCount,
            COLLECT(DISTINCT {
              userMail: email.email,
              userName: user.displayName,
              userPicUrl: user.profilePicUrl,
              accountId: account.id
            }) AS sharedWith

        WHERE (toLower(userMail) CONTAINS toLower('{searchText}') OR toLower(userName) CONTAINS toLower('{searchText}'))
        {placeholder}

        RETURN
            COUNT(DISTINCT accountId) AS totalCount"
  - id: BID_10
    name: "Password Reuse"
    type: widget
    active: true
    defaultValue: null
    queryFilters: []
    className: ""
    query: "CALL {
              MATCH (finding:FINDING {tenant: $tenant})<-[:EVALUATED_TO]-(rule:RULE)-[:BELONGS_TO]->(behavior:BEHAVIOR {id: $behavior})
              MATCH (u:USER {tenant: $tenant})-[:HAS_EMAIL]->(email:EMAIL)-[AUTH_TYPE]->(account:ACCOUNT)-[:HAS_FINDING]->(finding)
              MATCH (account)-[:USING_APP]->(app:APPLICATION)
              OPTIONAL MATCH (app)-[:HAS_APP_CATEGORY]->(category:APP_CATEGORY)
              MATCH (account)-[:HAS_CRED_FINGERPRINT]-(cred:CRED_FINGERPRINT)-[]-(same_password_account:ACCOUNT {tenant: $tenant})-[:USING_APP]->(same_password_app)
              WHERE same_password_account <> account AND same_password_account.email = account.email
          
              OPTIONAL MATCH (app)-[:HAS_ADMIN]->(owner:ACCOUNT {tenant: $tenant})
              OPTIONAL MATCH (finding)-[:TRIGGERED]->(action:ACTION)
              OPTIONAL MATCH (action)-[:RESULTED_IN]->(outcome:OUTCOME)
              OPTIONAL MATCH (t:TENANT {id: $tenant})-[hs:HAS_APP_SETTINGS]->(app)
          
              WITH app, owner, account, AUTH_TYPE, hs, category, finding, action, same_password_account,
              COALESCE(action.name, '-') AS actionName, COUNT(DISTINCT action.id) AS actionCount,
              CASE WHEN action IS NOT NULL AND outcome IS NULL THEN 'User Not Responded'
                  WHEN outcome IS NOT NULL THEN COALESCE(outcome.value, outcome.message, '-')
              END as outcomeValue,
              COUNT(DISTINCT action.id) as outcomeCount
          
              WITH app, owner, account, AUTH_TYPE, hs, category, finding, action, same_password_account,
              actionName, actionCount, apoc.map.fromPairs(COLLECT([outcomeValue, outcomeCount])) as outcomeMap
          
              CALL {
                  WITH app
                  MATCH (:APPLICATION {id_: app.id_})-[:USING_APP]-(a:ACCOUNT {tenant: $tenant})-[]-(:EMAIL)-[]-(:USER)
                  RETURN COUNT(DISTINCT a) AS totalAppAccounts
              }
          
              WITH 
                  app, hs,
                  COLLECT(DISTINCT owner.email) AS appAdmin, 
                  totalAppAccounts AS accounts,
                  COLLECT(DISTINCT {name: category.name, priority: category.priority}) AS categories, 
                  MIN(CASE WHEN account.creationTime = '-' THEN NULL ELSE account.creationTime END) AS firstAccessTime,
                  MAX(COALESCE(AUTH_TYPE.last_access_time, 0)) AS lastAccessTime,  
                  COALESCE(hs.approval_status, 'NEEDS REVIEW') AS status, 
                  app.logoUrl AS logo, 
                  COUNT(DISTINCT CASE WHEN finding IS NOT NULL THEN account.id END) AS accountsWithFindings,
                  apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, actionCount] END)) AS actionResults,
                  apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, outcomeMap] END)) AS actionOutcomes,
                  COUNT(DISTINCT CASE WHEN action IS NOT NULL THEN account.id END) AS accountsActioned,
                  CASE 
                      WHEN app.totalScore IN [1, 2] THEN 'Very High'
                      WHEN app.totalScore IN [3, 4] THEN 'High'
                      WHEN app.totalScore IN [5, 6] THEN 'Moderate'
                      WHEN app.totalScore IN [7, 8] THEN 'Low'
                      WHEN app.totalScore IN [9, 10] THEN 'Very Low'
                      ELSE 'Unknown'
                  END AS appRiskLevel,
                  COUNT(DISTINCT same_password_account) as passwordReuseCount
          
              RETURN 
                  app, hs,
                  appAdmin, 
                  accounts,
                  categories, 
                  firstAccessTime,
                  lastAccessTime,  
                  status, 
                  logo, 
                  appRiskLevel,
                  accountsWithFindings,
                  actionResults,
                  actionOutcomes,
                  {
                      actioned: accountsActioned,
                      pending: accountsWithFindings - accountsActioned
                  } AS reviewStatus,
                  passwordReuseCount
          }
          
          WITH app, hs, appAdmin, appRiskLevel, categories, lastAccessTime, firstAccessTime, accountsWithFindings,
              status, logo, accounts AS totalAccounts, reviewStatus, passwordReuseCount,
              datetime.truncate('day', datetime() - duration('P1M')).epochMillis AS one_month_ago_epoch, actionResults, actionOutcomes
          
          WHERE toLower(COALESCE(app.name, app.domain)) CONTAINS toLower('{searchText}')
          {placeholder}
          
          RETURN DISTINCT
              COALESCE(app.id_, app.internalId) AS id, 
              COALESCE(app.name, app.domain, app.id) AS app, 
              appAdmin, 
              appRiskLevel,
              COALESCE(hs.criticality, 'Not Set') AS criticality, 
              status, 
              COALESCE(firstAccessTime > one_month_ago_epoch, true) AS newlyDiscovered,
              logo, 
              [cat IN categories WHERE cat.priority = 2 | cat.name] AS highPriorityCategories, 
              totalAccounts, 
              accountsWithFindings, 
              lastAccessTime, 
              firstAccessTime,
              reviewStatus,
              actionResults,
              actionOutcomes,
              passwordReuseCount
          ORDER BY 
          CASE
              WHEN newlyDiscovered = true THEN 1
              ELSE 0
          END DESC,
          lastAccessTime DESC"
    allowed_params: true
    input_params:
      behavior: $behavior
      risk_level: AND toLower(appRiskLevel) IN [ x IN [$risk_level] | toLower(x) ]
      criticality: AND (
        toLower($criticality) = 'critical' AND toLower(COALESCE(hs.criticality, app.criticality)) = 'critical'
        OR toLower($criticality) = 'not critical' AND COALESCE(hs.criticality, app.criticality) IS NOT NULL AND toLower(COALESCE(hs.criticality, app.criticality)) <> 'critical'
        OR toLower($criticality) = 'not set' AND COALESCE(hs.criticality, app.criticality) IS NULL)
      approval_status: AND toLower(status) IN [ x IN [$approval_status] | toLower(x) ]
      number_of_accounts_greater_than: AND totalAccounts > $number_of_accounts_greater_than
      number_of_accounts_less_than: AND totalAccounts < $number_of_accounts_less_than
      technical_owner: AND appAdmin = $technical_owner
      newly_discovered: AND NOT status in ['APPROVED', 'UNAPPROVED'] AND COALESCE(firstAccessTime > one_month_ago_epoch, true) = $newly_discovered
      action_status: AND CASE WHEN toLower($action_status) = 'actioned' THEN reviewStatus['actioned'] > 0 ELSE reviewStatus['actioned'] = 0 END
      password_hygiene: AND passwordHygiene[$password_hygiene] > 0
      mfa_status: AND CASE WHEN $mfa_status = 'null' THEN mfaStatus IS NULL ELSE mfaStatus[$mfa_status] > 0 END
    dataSourceType: "knowledgegraph"
    multi_value_params:
      - id: risk_level
        delimiter: ","
      - id: approval_status
        delimiter: ","
    pagination_query: "
          CALL {
              MATCH (finding:FINDING {tenant: $tenant})<-[:EVALUATED_TO]-(rule:RULE)-[:BELONGS_TO]->(behavior:BEHAVIOR {id: $behavior})
              MATCH (u:USER {tenant: $tenant})-[:HAS_EMAIL]->(email:EMAIL)-[AUTH_TYPE]->(account:ACCOUNT)-[:HAS_FINDING]->(finding)
              MATCH (account)-[:USING_APP]->(app:APPLICATION)
              OPTIONAL MATCH (app)-[:HAS_APP_CATEGORY]->(category:APP_CATEGORY)
              MATCH (account)-[:HAS_CRED_FINGERPRINT]-(cred:CRED_FINGERPRINT)-[]-(same_password_account:ACCOUNT {tenant: $tenant})-[:USING_APP]->(same_password_app)
              WHERE same_password_account <> account AND same_password_account.email = account.email
          
              OPTIONAL MATCH (app)-[:HAS_ADMIN]->(owner:ACCOUNT {tenant: $tenant})
              OPTIONAL MATCH (finding)-[:TRIGGERED]->(action:ACTION)
              OPTIONAL MATCH (action)-[:RESULTED_IN]->(outcome:OUTCOME)
              OPTIONAL MATCH (t:TENANT {id: $tenant})-[hs:HAS_APP_SETTINGS]->(app)
          
              WITH app, owner, account, AUTH_TYPE, hs, category, finding, action,
              COALESCE(action.name, '-') AS actionName, COUNT(DISTINCT action.id) AS actionCount,
              COUNT(DISTINCT same_password_account.id) as passwordReuseCount,
              CASE WHEN action IS NOT NULL AND outcome IS NULL THEN 'User Not Responded'
                  WHEN outcome IS NOT NULL THEN COALESCE(outcome.value, outcome.message, '-')
              END as outcomeValue,
              COUNT(DISTINCT action.id) as outcomeCount
          
              WITH app, owner, account, AUTH_TYPE, hs, category, finding, action, passwordReuseCount,
              actionName, actionCount, apoc.map.fromPairs(COLLECT([outcomeValue, outcomeCount])) as outcomeMap
          
              CALL {
                  WITH app
                  MATCH (:APPLICATION {id_: app.id_})-[:USING_APP]-(a:ACCOUNT {tenant: $tenant})-[]-(:EMAIL)-[]-(:USER)
                  RETURN COUNT(DISTINCT a) AS totalAppAccounts
              }
          
              WITH 
                  app, hs,
                  COLLECT(DISTINCT owner.email) AS appAdmin, 
                  totalAppAccounts AS accounts,
                  COLLECT(DISTINCT {name: category.name, priority: category.priority}) AS categories, 
                  MIN(CASE WHEN account.creationTime = '-' THEN NULL ELSE account.creationTime END) AS firstAccessTime,
                  MAX(COALESCE(AUTH_TYPE.last_access_time, 0)) AS lastAccessTime,  
                  COALESCE(hs.approval_status, 'NEEDS REVIEW') AS status, 
                  app.logoUrl AS logo, 
                  COUNT(DISTINCT CASE WHEN finding IS NOT NULL THEN account.id END) AS accountsWithFindings,
                  apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, actionCount] END)) AS actionResults,
                  apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, outcomeMap] END)) AS actionOutcomes,
                  COUNT(DISTINCT CASE WHEN action IS NOT NULL THEN account.id END) AS accountsActioned,
                  CASE 
                      WHEN app.totalScore IN [1, 2] THEN 'Very High'
                      WHEN app.totalScore IN [3, 4] THEN 'High'
                      WHEN app.totalScore IN [5, 6] THEN 'Moderate'
                      WHEN app.totalScore IN [7, 8] THEN 'Low'
                      WHEN app.totalScore IN [9, 10] THEN 'Very Low'
                      ELSE 'Unknown'
                  END AS appRiskLevel,
                  passwordReuseCount
          
              RETURN 
                  app, hs,
                  appAdmin, 
                  accounts,
                  categories, 
                  firstAccessTime,
                  lastAccessTime,  
                  status, 
                  logo, 
                  appRiskLevel,
                  accountsWithFindings,
                  actionResults,
                  actionOutcomes,
                  {
                      actioned: accountsActioned,
                      pending: accountsWithFindings - accountsActioned
                  } AS reviewStatus,
                  passwordReuseCount
          }
          
          WITH app, hs, appAdmin, appRiskLevel, categories, lastAccessTime, firstAccessTime, accountsWithFindings,
              status, logo, accounts AS totalAccounts, reviewStatus, passwordReuseCount,
              datetime.truncate('day', datetime() - duration('P1M')).epochMillis AS one_month_ago_epoch, actionResults, actionOutcomes
          
          WHERE toLower(COALESCE(app.name, app.domain)) CONTAINS toLower('{searchText}')
          {placeholder}

          RETURN
              COUNT(DISTINCT COALESCE(app.id_, app.internalId)) AS totalCount"
  - id: BID_11
    name: "Weak Password"
    type: widget
    active: true
    defaultValue: null
    queryFilters: []
    className: ""
    query: "CALL {
              MATCH (finding:FINDING {tenant: $tenant})<-[:EVALUATED_TO]-(rule:RULE)-[:BELONGS_TO]->(behavior:BEHAVIOR {id: $behavior})
              MATCH (u:USER {tenant: $tenant})-[:HAS_EMAIL]->(email:EMAIL)-[AUTH_TYPE]->(account:ACCOUNT)-[:HAS_FINDING]->(finding)
              MATCH (account)-[:USING_APP]->(app:APPLICATION)
          
              OPTIONAL MATCH (app)-[:HAS_APP_CATEGORY]->(category:APP_CATEGORY)
              OPTIONAL MATCH (app)-[:HAS_ADMIN]->(owner:ACCOUNT {tenant: $tenant})
              OPTIONAL MATCH (finding)-[:TRIGGERED]->(action:ACTION)
              OPTIONAL MATCH (action)-[:RESULTED_IN]->(outcome:OUTCOME)
              OPTIONAL MATCH (t:TENANT {id: $tenant})-[hs:HAS_APP_SETTINGS]->(app)
          
              WITH app, owner, account, AUTH_TYPE, hs, category, finding, action,
              COALESCE(action.name, '-') AS actionName, COUNT(DISTINCT action.id) AS actionCount,
              CASE WHEN action IS NOT NULL AND outcome IS NULL THEN 'User Not Responded'
                  WHEN outcome IS NOT NULL THEN COALESCE(outcome.value, outcome.message, '-')
              END as outcomeValue,
              COUNT(DISTINCT action.id) as outcomeCount
          
              WITH app, owner, account, AUTH_TYPE, hs, category, finding, action,
              actionName, actionCount, apoc.map.fromPairs(COLLECT([outcomeValue, outcomeCount])) as outcomeMap
          
              CALL {
                  WITH app
                  MATCH (:APPLICATION {id_: app.id_})-[:USING_APP]-(a:ACCOUNT {tenant: $tenant})-[]-(:EMAIL)-[]-(:USER)
                  RETURN COUNT(DISTINCT a) AS totalAppAccounts
              }
          
              WITH 
                  app, hs,
                  COLLECT(DISTINCT owner.email) AS appAdmin, 
                  totalAppAccounts AS accounts,
                  COLLECT(DISTINCT {name: category.name, priority: category.priority}) AS categories, 
                  MIN(CASE WHEN account.creationTime = '-' THEN NULL ELSE account.creationTime END) AS firstAccessTime,
                  MAX(COALESCE(AUTH_TYPE.last_access_time, 0)) AS lastAccessTime,  
                  COALESCE(hs.approval_status, 'NEEDS REVIEW') AS status, 
                  app.logoUrl AS logo, 
                  COUNT(DISTINCT CASE WHEN finding IS NOT NULL THEN account.id END) AS accountsWithFindings,
                  apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, actionCount] END)) AS actionResults,
                  apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, outcomeMap] END)) AS actionOutcomes,
                  COUNT(DISTINCT CASE WHEN action IS NOT NULL THEN account.id END) AS accountsActioned,
                  CASE 
                      WHEN app.totalScore IN [1, 2] THEN 'Very High'
                      WHEN app.totalScore IN [3, 4] THEN 'High'
                      WHEN app.totalScore IN [5, 6] THEN 'Moderate'
                      WHEN app.totalScore IN [7, 8] THEN 'Low'
                      WHEN app.totalScore IN [9, 10] THEN 'Very Low'
                      ELSE 'Unknown'
                  END AS appRiskLevel
          
              RETURN 
                  app, hs,
                  appAdmin, 
                  accounts,
                  categories, 
                  firstAccessTime,
                  lastAccessTime,  
                  status, 
                  logo, 
                  appRiskLevel,
                  accountsWithFindings,
                  actionResults,
                  actionOutcomes,
                  {
                      actioned: accountsActioned,
                      pending: accountsWithFindings - accountsActioned
                  } AS reviewStatus
          }
          
          WITH app, hs, appAdmin, appRiskLevel, categories, lastAccessTime, firstAccessTime, accountsWithFindings,
              status, logo, accounts AS totalAccounts, reviewStatus,
              datetime.truncate('day', datetime() - duration('P1M')).epochMillis AS one_month_ago_epoch, actionResults, actionOutcomes
          
          WHERE toLower(COALESCE(app.name, app.domain)) CONTAINS toLower('{searchText}')
          {placeholder}
          
          RETURN DISTINCT
              COALESCE(app.id_, app.internalId) AS id, 
              COALESCE(app.name, app.domain) AS app, 
              appAdmin, 
              appRiskLevel,
              COALESCE(hs.criticality, 'Not Set') AS criticality, 
              status, 
              COALESCE(firstAccessTime > one_month_ago_epoch, true) AS newlyDiscovered,
              logo, 
              [cat IN categories WHERE cat.priority = 2 | cat.name] AS highPriorityCategories, 
              totalAccounts, 
              accountsWithFindings, 
              lastAccessTime, 
              firstAccessTime,
              reviewStatus,
              actionResults,
              actionOutcomes
          ORDER BY 
          CASE
              WHEN newlyDiscovered = true THEN 1
              ELSE 0
          END DESC,
          lastAccessTime DESC"
    allowed_params: true
    input_params:
      behavior: $behavior
      risk_level: AND toLower(appRiskLevel) IN [ x IN [$risk_level] | toLower(x) ]
      criticality: AND toLower(COALESCE(hs.criticality, 'Not Set')) IN [$criticality]
      approval_status: AND toLower(status) IN [ x IN [$approval_status] | toLower(x) ]
      number_of_accounts_greater_than: AND totalAccounts > $number_of_accounts_greater_than
      number_of_accounts_less_than: AND totalAccounts < $number_of_accounts_less_than
      technical_owner: AND appAdmin = $technical_owner
      newly_discovered: AND NOT status in ['APPROVED', 'UNAPPROVED'] AND COALESCE(firstAccessTime > one_month_ago_epoch, true) = $newly_discovered
      action_status: AND CASE WHEN toLower($action_status) = 'actioned' THEN reviewStatus['actioned'] > 0 ELSE reviewStatus['actioned'] = 0 END
      password_hygiene: AND passwordHygiene[$password_hygiene] > 0
      mfa_status: AND CASE WHEN $mfa_status = 'null' THEN mfaStatus IS NULL ELSE mfaStatus[$mfa_status] > 0 END
    multi_value_params:
      - id: criticality
        delimiter: ","
      - id: risk_level
        delimiter: ","
      - id: approval_status
        delimiter: ","
    dataSourceType: "knowledgegraph"
    pagination_query: "
          CALL {
              MATCH (finding:FINDING {tenant: $tenant})<-[:EVALUATED_TO]-(rule:RULE)-[:BELONGS_TO]->(behavior:BEHAVIOR {id: $behavior})
              MATCH (u:USER {tenant: $tenant})-[:HAS_EMAIL]->(email:EMAIL)-[AUTH_TYPE]->(account:ACCOUNT)-[:HAS_FINDING]->(finding)
              MATCH (account)-[:USING_APP]->(app:APPLICATION)
              
              OPTIONAL MATCH (app)-[:HAS_APP_CATEGORY]->(category:APP_CATEGORY)
              OPTIONAL MATCH (app)-[:HAS_ADMIN]->(owner:ACCOUNT {tenant: $tenant})
              OPTIONAL MATCH (finding)-[:TRIGGERED]->(action:ACTION)
              OPTIONAL MATCH (action)-[:RESULTED_IN]->(outcome:OUTCOME)
              OPTIONAL MATCH (t:TENANT {id: $tenant})-[hs:HAS_APP_SETTINGS]->(app)
          
              WITH app, owner, account, AUTH_TYPE, hs, category, finding, action,
              COALESCE(action.name, '-') AS actionName, COUNT(DISTINCT action.id) AS actionCount,
              CASE WHEN action IS NOT NULL AND outcome IS NULL THEN 'User Not Responded'
                  WHEN outcome IS NOT NULL THEN COALESCE(outcome.value, outcome.message, '-')
              END as outcomeValue,
              COUNT(DISTINCT action.id) as outcomeCount
          
              WITH app, owner, account, AUTH_TYPE, hs, category, finding, action,
              actionName, actionCount, apoc.map.fromPairs(COLLECT([outcomeValue, outcomeCount])) as outcomeMap
          
              CALL {
                  WITH app
                  MATCH (:APPLICATION {id_: app.id_})-[:USING_APP]-(a:ACCOUNT {tenant: $tenant})-[]-(:EMAIL)-[]-(:USER)
                  RETURN COUNT(DISTINCT a) AS totalAppAccounts
              }
          
              WITH 
                  app, hs,
                  COLLECT(DISTINCT owner.email) AS appAdmin, 
                  totalAppAccounts AS accounts,
                  COLLECT(DISTINCT {name: category.name, priority: category.priority}) AS categories, 
                  MIN(CASE WHEN account.creationTime = '-' THEN NULL ELSE account.creationTime END) AS firstAccessTime,
                  MAX(COALESCE(AUTH_TYPE.last_access_time, 0)) AS lastAccessTime,  
                  COALESCE(hs.approval_status, 'NEEDS REVIEW') AS status, 
                  app.logoUrl AS logo, 
                  COUNT(DISTINCT CASE WHEN finding IS NOT NULL THEN account.id END) AS accountsWithFindings,
                  apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, actionCount] END)) AS actionResults,
                  apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, outcomeMap] END)) AS actionOutcomes,
                  COUNT(DISTINCT CASE WHEN action IS NOT NULL THEN account.id END) AS accountsActioned,
                  CASE 
                      WHEN app.totalScore IN [1, 2] THEN 'Very High'
                      WHEN app.totalScore IN [3, 4] THEN 'High'
                      WHEN app.totalScore IN [5, 6] THEN 'Moderate'
                      WHEN app.totalScore IN [7, 8] THEN 'Low'
                      WHEN app.totalScore IN [9, 10] THEN 'Very Low'
                      ELSE 'Unknown'
                  END AS appRiskLevel
          
              RETURN 
                  app, hs,
                  appAdmin, 
                  accounts,
                  categories, 
                  firstAccessTime,
                  lastAccessTime,  
                  status, 
                  logo, 
                  appRiskLevel,
                  accountsWithFindings,
                  actionResults,
                  actionOutcomes,
                  {
                      actioned: accountsActioned,
                      pending: accountsWithFindings - accountsActioned
                  } AS reviewStatus
          }
          
          WITH app, hs, appAdmin, appRiskLevel, categories, lastAccessTime, firstAccessTime, accountsWithFindings,
              status, logo, accounts AS totalAccounts, reviewStatus,
              datetime.truncate('day', datetime() - duration('P1M')).epochMillis AS one_month_ago_epoch, actionResults, actionOutcomes
          
          WHERE toLower(COALESCE(app.name, app.domain)) CONTAINS toLower('{searchText}')
          {placeholder}

          RETURN
              COUNT(DISTINCT COALESCE(app.id_, app.internalId)) AS totalCount"
table_filters:
  - id: risk_level
    name: Risk Level
    defaultValue:
    active: true
    view_by:
        - app
    optional: true
    defaultOptions:
        - 'Very High'
        - 'High'
        - 'Moderate'
        - 'Low'
        - 'Very Low'
    type: multiselect
    allowed_params: false
    dataSourceType: knowledgegraph
    input_params: null
    query: ""
  - id: criticality
    name: Criticality
    defaultValue:
    active: true
    view_by:
        - app
    optional: true
    defaultOptions:
        "Yes": "critical"
        "No": "not critical"
    type: single
    allowed_params: false
    dataSourceType: knowledgegraph
    input_params: null
    query: ""
  - id: approval_status
    name: Approval Status
    defaultValue:
    active: true
    view_by:
        - app
    optional: false
    defaultOptions:
        - "Approved"
        - "Unapproved"
        - "Needs Review"
        - "Tolerated"
    type: multiselect
    allowed_params: false
    dataSourceType: knowledgegraph
    input_params: null
    query: ""
  - id: number_of_accounts
    name: Number of Account
    defaultValue:
    active: true
    view_by:
        - app
        - account
    optional: false
    defaultOptions:
        - "greater_than"
        - "less_than"
    type: range
    allowed_params: false
    dataSourceType: knowledgegraph
    input_params: null
    query: ""
  - id: technical_owner
    name: Technical Owner
    defaultValue:
    active: true
    view_by:
        - app
        - account
        - BID_05
        - BID_06
        - BID_07
        - BID_08
        - BID_10
        - BID_11
    optional: true
    defaultOptions: []
    type: singleselect
    allowed_params: false
    dataSourceType: knowledgegraph
    input_params:
        search: true
    query: "MATCH (app:APPLICATION)-[:HAS_ADMIN]->(owner:ACCOUNT {subscriber: $subscriber, tenant: $tenant})-[]-(email:EMAIL)-[]-(user:USER)
            RETURN DISTINCT    user.id as id, user.displayName as label, user.mail as value"
  - id: newly_discovered
    name: Newly Discovered
    defaultValue:
    active: true
    view_by:
        - app
    optional: true
    defaultOptions:
        "Yes": true
        "No": false
    type: single
    allowed_params: false
    dataSourceType: knowledgegraph
    input_params: null
    query: ""
  - id: usage_level
    name: Usage Level
    defaultValue:
    active: false
    view_by:
        - app
    optional: true
    defaultOptions: []
    type: multiselect
    allowed_params: false
    dataSourceType: knowledgegraph
    input_params: null
    query: ""
  - id: action_status
    name: Action Status
    defaultValue:
    active: true
    view_by:
        - app
        - account
    optional: false
    defaultOptions:
        - "Actioned"
        - "Pending"
    type: single
    allowed_params: false
    dataSourceType: knowledgegraph
    input_params: null
    query: ""
  - id: department
    name: Department
    defaultValue:
    active: true
    view_by:
        - account
    optional: false
    defaultOptions: []
    type: multiselect
    allowed_params: false
    dataSourceType: knowledgegraph
    input_params: null
    query: "match(d:DEPARTMENT {subscriber: $subscriber, tenant: $tenant}) 
            return DISTINCT d.id AS id, d.name AS value , d.name AS label"
  - id: posture_risk_level
    name: Posture Risk Level
    defaultValue:
    active: true
    view_by:
        - account
    optional: false
    defaultOptions:
        - 'Very High'
        - 'High'
        - 'Moderate'
        - 'Low'
        - 'Very Low'
    type: multiselect
    allowed_params: false
    dataSourceType: knowledgegraph
    input_params: null
    query: ""
  - id: app_category
    name: App Category
    defaultValue:
    active: true
    view_by:
        - account
    optional: true
    defaultOptions: []
    type: multiselect
    allowed_params: false
    dataSourceType: knowledgegraph
    input_params: null
    query: "MATCH (email:EMAIL {subscriber: $subscriber, tenant: $tenant})-[]-(acc:ACCOUNT)-[:USING_APP]-(app:APPLICATION)-[:HAS_APP_CATEGORY]-(cat:APP_CATEGORY)WHERE cat.priority IS NULL OR cat.priority < 2
            RETURN DISTINCT    cat.name as label, 
                               cat.name as value, 
                               cat.name as id"
  - id: appname
    name: Appname
    defaultValue:
    active: true
    view_by:
        - account
    optional: false
    defaultOptions: []
    type: multiselect
    allowed_params: false
    dataSourceType: knowledgegraph
    input_params: null
    query: "MATCH (email:EMAIL {subscriber: $subscriber, tenant: $tenant})-[]-(acc:ACCOUNT)-[:USING_APP]-(app:APPLICATION)-[:HAS_APP_CATEGORY]-(cat:APP_CATEGORY)WHERE cat.priority IS NULL OR cat.priority < 2
            RETURN DISTINCT  app.id_ as id, app.id_ as value, app.name as label"
  - id: group
    name: Group
    defaultValue:
    active: true
    view_by:
        - account
    optional: false
    defaultOptions: []
    type: multiselect
    allowed_params: false
    dataSourceType: knowledgegraph
    input_params: null
    query: "MATCH (g:GROUP {subscriber: $subscriber, tenant: $tenant, userDefined: true}) 
            RETURN DISTINCT 
            g.id AS id, 
            g.displayName as label,
            g.displayName as value"
  - id: password_hygiene
    name: Password Hygiene
    defaultValue:
    active: true
    view_by:
        - BID_05
        - BID_06
        - BID_07
        - BID_08
        - BID_10
        - BID_11
    optional: false
    defaultOptions:
        - "Weak Passwords"
        - "Compromised Passwords"
    type: single
    allowed_params: false
    dataSourceType: knowledgegraph
    input_params: null
    query: ""
  - id: mfa_status
    name: MFA Status
    defaultValue:
    active: true
    view_by:
        - BID_05
        - BID_06
        - BID_07
        - BID_08
        - BID_10
        - BID_11
    optional: false
    defaultOptions:
        "No MFA": "No MFA"
        "Weak MFA": "MFA Enabled"
        "Strong MFA": "MFA Enabled"
        "MFA not supported": null
    type: single
    allowed_params: false
    dataSourceType: knowledgegraph
    input_params: null
    query: ""
widgets:
  - id: identity_risk
    name: "Identity Risk"
    label: Widget
    template: identity_risk
    enabled: true
    type: multi_linechart
    widget_type: insights_widget
    dataSourceType: datalake
    allowed_params: true
    className: col-span-1
    query_id: ""
    input_params:
      endtime: $endtime
      posture: $posture
    queryFilters:
    query: "select year, monthofyear, dayofmonth, alert_percentile*100 as risk_score, ROUND((alert_percentile*4)+1) as risk_index from kafka_connect.snowdata_schema.postureprofileaggregated where agg_type = 'organization' and agg_subtype = 'posture' and agg_subtype_name = $posture and subscriber = $subscriber and tenant = $tenant order by monthofyear, dayofmonth, agg_type_name, agg_subtype_name"
  - id: identity_metrics
    name: ""
    label: Widget
    template: "detailed_chart"
    enabled: true
    type: detailed
    widget_type: insights_widget
    dataSourceType: datalake
    allowed_params: true
    className: col-span-1
    query_id: ""
    dataLabels:
      - isDetail: true
        label: "Risk Level"
        dataIndex: "Risk_Level"
        percentageIndex: "Risk_Level_chane"
        widget: "risk_level"
      - isDetail: true
        label: "Total Accounts"
        dataIndex: "TOTAL_ACCOUNTS"
        percentageIndex: "TOTAL_ACCOUNTS_CHANGE"
      - isDetail: true
        label: "Total Employees"
        dataIndex: "TOTAL_USERS"
        percentageIndex: "TOTAL_USERS_CHANGE"
      - isDetail: true
        label: "Total Apps"
        dataIndex: "TOTAL_APPS"
        percentageIndex: "TOTAL_APPS_CHANGE"
    input_params:
      endtime: $endtime
    queryFilters:
    query:
      "SELECT * FROM kafka_connect.snowdata_schema.daily_org_analytics WHERE subscriber = $subscriber AND tenant = $tenant ORDER BY timestamp DESC"
  - id: risk_level
    name: ""
    label: Widget
    template: "detailed_chart"
    enabled: true
    type: detailed
    widget_type: insights_widget
    dataSourceType: datalake
    allowed_params: true
    className: col-span-1
    query_id: ""
    dataLabels:
      - isDetail: true
        label: "Risk Level"
        dataIndex: "avg_risk_level"
        percentageIndex: ""
    input_params:
      endtime: $endtime
    queryFilters:
    query: "WITH data AS (
                SELECT 
                    year, monthofyear, dayofmonth, agg_subtype_name, alert_percentile*100 as risk_score, ROUND((alert_percentile*4)+1) as risk_index 
                FROM kafka_connect.snowdata_schema.postureprofileaggregated 
                WHERE agg_type = 'organization' and agg_subtype = 'posture' and agg_subtype_name in ('MFA Risk', 'Password Hygiene') and tenant = $tenant
                ORDER BY year, monthofyear, dayofmonth, agg_subtype_name DESC 
                LIMIT 2
            ),
            risk_level AS (
                SELECT CEIL(AVG(risk_index)) value from data
            )
            SELECT 
                value avg_risk_index,
                CASE WHEN value = 1.0 THEN 'Very Low'
                WHEN value = 2.0 THEN 'Low'
                WHEN value = 3.0 THEN 'Moderate'
                END avg_risk_level
            FROM risk_level"
  - id: password_strength_distribution
    name: "Password Strength"
    label: "Widget"
    template: "passwordStrength"
    type: "bar_distribution"
    widget_type: insights_widget
    query_id: ""
    enabled: true
    queryFilters: []
    className: ""
    query: "MATCH (user:USER {subscriber: $subscriber, tenant: $tenant})-[]-(email:EMAIL)-[]-(account:ACCOUNT)-[:HAS_CRED_FINGERPRINT]-(cfp:CRED_FINGERPRINT)
            
            WITH DISTINCT account.id as accountId,
                CASE
                    WHEN cfp.password_strength > 3 THEN 'Strong'
                    WHEN cfp.password_strength = 3 THEN 'Moderate'
                    ELSE 'Weak'
                END as tag
            
            WITH tag, COUNT(accountId) as count
            ORDER BY 
                CASE tag
                    WHEN 'Strong' THEN 1
                    WHEN 'Moderate' THEN 2
                    WHEN 'Weak' THEN 3
                END
            
            RETURN tag, count"
    allowed_params: false
    input_params: null
    dataSourceType: "knowledgegraph"
  - id: password_manager
    name: "Password Manager Use"
    label: "Widget"
    template: "passwordManager"
    type: "bar_distribution"
    widget_type: insights_widget
    query_id: ""
    enabled: true
    queryFilters: []
    className: ""
    query: ""
    allowed_params: false
    input_params: null
    dataSourceType: "knowledgegraph"
  - id: vulnerable_identities
    name: "Vulnerable Identities"
    label: "Widget"
    template: "bardistribution"
    widget_type: insights_widget
    type: "risk_bar_chart"
    query_id: ""
    enabled: true
    queryFilters: []
    className: ""
    query: ""
    allowed_params: false
    input_params: null
    dataSourceType: "knowledgegraph"
  - id: BID_05
    name: "MFA not supported"
    label: "Widget"
    template: ""
    widget_type: behavior_widget
    type: behavior_widget
    query_id: ""
    enabled: true
    queryFilters: []
    className: ""
    query: "MATCH (user:USER {subscriber: $subscriber, tenant: $tenant})-[]-(email:EMAIL)-[]-(acc:ACCOUNT)-[:HAS_FINDING]-(finding:FINDING)-[]
            -(rule:RULE)-[]-(behavior:BEHAVIOR {id: $behavior})
            MATCH (acc)-[:USING_APP]->(app:APPLICATION)
            WHERE app.name IS NOT NULL
            OPTIONAL MATCH (finding)-[]-(action:ACTION)
            WITH app, CASE WHEN COUNT(action) > 0 THEN true ELSE false END as hasAction
            RETURN
                COUNT(DISTINCT app.id_) AS total,
                COUNT(DISTINCT CASE WHEN hasAction = true THEN app.id_ END) AS actioned,
                COUNT(DISTINCT CASE WHEN hasAction = false THEN app.id_ END) AS pending"
    allowed_params: true
    input_params:
      behavior: $behavior
    dataSourceType: "knowledgegraph"
  - id: BID_06
    name: "No MFA used"
    label: "Widget"
    template: ""
    widget_type: behavior_widget
    type: behavior_widget
    query_id: ""
    enabled: true
    queryFilters: []
    className: ""
    query: "MATCH (user:USER {subscriber: $subscriber, tenant: $tenant})-[]-(email:EMAIL)-[]-(acc:ACCOUNT)-[:HAS_FINDING]-(finding:FINDING)-[]
            -(rule:RULE)-[]-(behavior:BEHAVIOR {id: $behavior})
            MATCH (acc)-[:USING_APP]->(app:APPLICATION)
            WHERE app.name IS NOT NULL
            OPTIONAL MATCH (finding)-[]-(action:ACTION)
            WITH app, CASE WHEN COUNT(action) > 0 THEN true ELSE false END as hasAction
            RETURN
                COUNT(DISTINCT app.id_) AS total,
                COUNT(DISTINCT CASE WHEN hasAction = true THEN app.id_ END) AS actioned,
                COUNT(DISTINCT CASE WHEN hasAction = false THEN app.id_ END) AS pending"
    allowed_params: true
    input_params:
      behavior: $behavior
    dataSourceType: "knowledgegraph"
  - id: BID_07
    name: "Weak MFA used"
    label: "Widget"
    template: ""
    widget_type: behavior_widget
    type: behavior_widget
    query_id: ""
    enabled: true
    queryFilters: []
    className: ""
    query: "MATCH (user:USER {subscriber: $subscriber, tenant: $tenant})-[]-(email:EMAIL)-[]-(acc:ACCOUNT)-[:HAS_FINDING]-(finding:FINDING)-[]
            -(rule:RULE)-[]-(behavior:BEHAVIOR {id: $behavior})
            MATCH (acc)-[:USING_APP]->(app:APPLICATION)
            WHERE app.name IS NOT NULL
            OPTIONAL MATCH (finding)-[]-(action:ACTION)
            WITH app, CASE WHEN COUNT(action) > 0 THEN true ELSE false END as hasAction
            RETURN
                COUNT(DISTINCT app.id_) AS total,
                COUNT(DISTINCT CASE WHEN hasAction = true THEN app.id_ END) AS actioned,
                COUNT(DISTINCT CASE WHEN hasAction = false THEN app.id_ END) AS pending"
    allowed_params: true
    input_params:
      behavior: $behavior
    dataSourceType: "knowledgegraph"
  - id: BID_08
    name: "Compromised Password"
    label: "Widget"
    template: ""
    widget_type: behavior_widget
    type: behavior_widget
    query_id: ""
    enabled: true
    queryFilters: []
    className: ""
    query: "MATCH (user:USER {subscriber: $subscriber, tenant: $tenant})-[]-(email:EMAIL)-[]-(acc:ACCOUNT)-[:HAS_FINDING]-(finding:FINDING)-[]
            -(rule:RULE)-[]-(behavior:BEHAVIOR {id: $behavior})
            MATCH (acc)-[:USING_APP]->(app:APPLICATION)
            WHERE app.name IS NOT NULL
            OPTIONAL MATCH (finding)-[]-(action:ACTION)
            WITH app, CASE WHEN COUNT(action) > 0 THEN true ELSE false END as hasAction
            RETURN
                COUNT(DISTINCT app.id_) AS total,
                COUNT(DISTINCT CASE WHEN hasAction = true THEN app.id_ END) AS actioned,
                COUNT(DISTINCT CASE WHEN hasAction = false THEN app.id_ END) AS pending"
    allowed_params: true
    input_params:
      behavior: $behavior
    dataSourceType: "knowledgegraph"
  - id: BID_09
    name: "Credential Sharing"
    label: "Widget"
    template: ""
    widget_type: behavior_widget
    type: behavior_widget
    query_id: ""
    enabled: true
    queryFilters: []
    className: ""
    query: "MATCH (app:APPLICATION)<-[using_app:USING_APP]-(shared_account:ACCOUNT {subscriber: $subscriber, tenant: $tenant})
            MATCH (shared_account)<-[:CREDENTIAL_SHARED]-(account:ACCOUNT {tenant: $tenant})
            WHERE account <> shared_account AND toLower(account.email) <> toLower(shared_account.email)
            MATCH (shared_account)<-[auth_type]-(shared_email:EMAIL)
            OPTIONAL MATCH (shared_email)<-[:HAS_EMAIL]-(shared_user:USER)
            MATCH (account)<-[auth_type_target:CREDSBASED_ACCOUNT]-(email:EMAIL)
            OPTIONAL MATCH (email)<-[:HAS_EMAIL]-(user:USER)
            WITH app, shared_account, account, shared_email, email, shared_user, user
            WHERE NOT EXISTS((user)-[:SAME_USER]-(shared_user))
            MATCH (account)-[:HAS_FINDING]->(finding:FINDING)<-[]-(rule:RULE)-[]->(behavior:BEHAVIOR {id: $behavior})
            WHERE finding.sharedAccountId = shared_account.id
            OPTIONAL MATCH (finding)-[]-(action:ACTION {tenant: $tenant})
            WITH shared_account, CASE WHEN COUNT(action) > 0 THEN true ELSE false END as hasAction
            RETURN
                COUNT(DISTINCT shared_account.id) AS total,
                COUNT(DISTINCT CASE WHEN hasAction = true THEN shared_account.id END) AS actioned,
                COUNT(DISTINCT CASE WHEN hasAction = false THEN shared_account.id END) AS pending"
    allowed_params: true
    input_params:
      behavior: $behavior
    dataSourceType: "knowledgegraph"
  - id: BID_10
    name: "Password Reuse"
    label: "Widget"
    template: ""
    widget_type: behavior_widget
    type: behavior_widget
    query_id: ""
    enabled: true
    queryFilters: []
    className: ""
    query: "MATCH (user:USER {subscriber: $subscriber, tenant: $tenant})-[]-(email:EMAIL)-[]-(acc:ACCOUNT)-[:HAS_FINDING]-(finding:FINDING)-[]
            -(rule:RULE)-[]-(behavior:BEHAVIOR {id: $behavior})
            MATCH (acc)-[:HAS_CRED_FINGERPRINT]-(cred:CRED_FINGERPRINT)-[]-(same_password_account:ACCOUNT {tenant: $tenant})-[:USING_APP]->(same_password_app)
            WHERE same_password_account <> acc AND same_password_account.email = acc.email
            MATCH (acc)-[:USING_APP]->(app:APPLICATION)
            WHERE app.name IS NOT NULL
            OPTIONAL MATCH (finding)-[]-(action:ACTION)
            WITH app, CASE WHEN COUNT(action) > 0 THEN true ELSE false END as hasAction
            RETURN
                COUNT(DISTINCT app.id_) AS total,
                COUNT(DISTINCT CASE WHEN hasAction = true THEN app.id_ END) AS actioned,
                COUNT(DISTINCT CASE WHEN hasAction = false THEN app.id_ END) AS pending"
    allowed_params: true
    input_params:
      behavior: $behavior
    dataSourceType: "knowledgegraph"
  - id: BID_11
    name: "Weak Password"
    label: "Widget"
    template: ""
    widget_type: behavior_widget
    type: behavior_widget
    query_id: ""
    enabled: true
    queryFilters: []
    className: ""
    query: "MATCH (user:USER {subscriber: $subscriber, tenant: $tenant})-[]-(email:EMAIL)-[]-(acc:ACCOUNT)-[:HAS_FINDING]-(finding:FINDING)-[]
            -(rule:RULE)-[]-(behavior:BEHAVIOR {id: $behavior})
            MATCH (acc)-[:USING_APP]->(app:APPLICATION)
            WHERE app.name IS NOT NULL
            OPTIONAL MATCH (finding)-[]-(action:ACTION)
            WITH app, CASE WHEN COUNT(action) > 0 THEN true ELSE false END as hasAction
            RETURN
                COUNT(DISTINCT app.id_) AS total,
                COUNT(DISTINCT CASE WHEN hasAction = true THEN app.id_ END) AS actioned,
                COUNT(DISTINCT CASE WHEN hasAction = false THEN app.id_ END) AS pending"
    allowed_params: true
    input_params:
      behavior: $behavior
    dataSourceType: "knowledgegraph"
  - id: apps_detailed_BID_05
    name: "MFA not supported Detailed Widget"
    label: Widget
    template: this_template
    enabled: true
    type: drilldown_widget
    widget_type: drilldown_widget
    dataSourceType: knowledgegraph
    allowed_params: true
    className: col-span-1
    query_id: ""
    input_params:
      endtime: $endtime
      appId: $appId
      behavior: $behavior
    queryFilters: []
    query: "MATCH (user:USER {subscriber: $subscriber, tenant: $tenant})-[]-(email:EMAIL)-[auth_type]-(account:ACCOUNT)-[:HAS_FINDING]-(finding:FINDING)-[]-(rule:RULE)-[]-(behavior:BEHAVIOR {id: $behavior})
            MATCH (account)-[:USING_APP]-(app:APPLICATION {id_: $appId})
            
            OPTIONAL MATCH (app)-[:USING_APP]-(shared_account:ACCOUNT {tenant: $tenant})<-[:CREDENTIAL_SHARED]-(shared_with:ACCOUNT {tenant: $tenant})
            WHERE 
                EXISTS((shared_account)-[:HAS_FINDING]->(:FINDING)-[]-(:RULE)-[]-(:BEHAVIOR {id: 'BID_09'}))
                AND EXISTS((shared_account)-[]-(:EMAIL)-[]-(:USER))
            OPTIONAL MATCH (account)-[hcf:HAS_CRED_FINGERPRINT]-(cf:CRED_FINGERPRINT)-[same_hcf:HAS_CRED_FINGERPRINT]-(same_password_account:ACCOUNT {tenant: $tenant})
            WHERE same_password_account <> account AND same_password_account.email = account.email
            OPTIONAL MATCH (app)-[]-(grant:GRANT)-[]-(scope:SCOPE)
            WHERE toLower(scope.severity) IN ['high', 'medium', 'low']
            OPTIONAL MATCH (app)-[has:HAS_APP_SETTINGS]-(tenant:TENANT {id: $tenant})
            OPTIONAL MATCH (finding)-[:TRIGGERED]-(action:ACTION)
            OPTIONAL MATCH (action)-[:RESULTED_IN]-(outcome:OUTCOME)
            OPTIONAL MATCH (finding)-[:HAS_ARTIFACT]->(dlp:DLP_FINAL_CLASS | DLP_ORIGINAL_CLASS)
            
            WITH app, auth_type, account, hcf, cf, same_hcf, shared_account, same_password_account, COLLECT(DISTINCT scope.severity) as severities, has, finding, action, outcome, dlp
            
            WITH app, auth_type, account, hcf, cf, same_hcf, shared_account, same_password_account, severities, has, finding, action, dlp,
                COALESCE(action.name, '-') AS actionName,
                COUNT(DISTINCT action) AS actionCount,
                CASE WHEN action IS NOT NULL AND outcome IS NULL THEN 'Not Responded'
                    WHEN outcome IS NOT NULL THEN COALESCE(outcome.value, outcome.message, '-')
                END as outcomeValue
            WHERE actionName IS NOT NULL
            
            WITH app, auth_type, account, hcf, cf, same_hcf, shared_account, same_password_account, severities, has, finding, action, dlp, actionName, actionCount,
                outcomeValue, COUNT(outcomeValue) AS outcomeCount
            
            WITH app, auth_type, account, hcf, cf, same_hcf, shared_account, same_password_account, severities, has, finding, action, dlp, actionName, actionCount,
                apoc.map.fromPairs(COLLECT([outcomeValue, outcomeCount])) as outcomeMap
            
            WITH app, severities, has,
                COUNT(DISTINCT CASE WHEN cf.compromised_password_status = true THEN account.id END) as compromised_passwords,
                COUNT(DISTINCT CASE WHEN cf.password_strength < 3 THEN account.id END) as weak_passwords,
                COUNT(DISTINCT shared_account) as shared_accounts,
                COUNT(DISTINCT same_password_account) as same_password_accounts,
                COUNT(DISTINCT CASE WHEN auth_type.isMfaEnabled IS NULL OR auth_type.isMfaEnabled <> true THEN auth_type END) as mfaDisabledCount,
                COUNT(DISTINCT account.id) as totalAccounts,
                COUNT(DISTINCT CASE WHEN type(auth_type) = 'CREDSBASED_ACCOUNT' THEN account.id END) as credsbased_account_count,
                COUNT(DISTINCT CASE WHEN type(auth_type) = 'OAUTH_ACCOUNT' THEN account.id END) as oauth_account_count,
                COUNT(DISTINCT finding.id) as totalFindings,
                COUNT(DISTINCT CASE WHEN action IS NOT NULL THEN action END) as actionedCount,
                COUNT(DISTINCT CASE WHEN action IS NULL THEN finding.id END) as pendingCount,
                MIN(COALESCE(
                    CASE WHEN account.creationTime <> '-' THEN account.creationTime ELSE NULL END, timestamp()
                )) AS firstAccessed,
                MAX(auth_type.last_access_time) AS lastAccessed,
                COLLECT(DISTINCT dlp.id) AS sensitiveDataClasses,
                apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, actionCount] END)) AS combinedActionTracker,
                apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, outcomeMap] END)) AS combinedActionOutcomes
            
            RETURN DISTINCT
                COALESCE(app.id_, app.internalId) AS id,
                COALESCE(app.name, app.domain, app.id) AS app,
                app.logoUrl AS appLogoUrl,
                app.description AS description,
                firstAccessed,
                lastAccessed,
                compromised_passwords,
                weak_passwords,
                shared_accounts,
                same_password_accounts,
                app.isMfaSupported = true as mfaSupported,
                mfaDisabledCount,
                totalAccounts,
                credsbased_account_count,
                oauth_account_count,
                COALESCE(has.approval_status, 'Not Defined') AS approvalStatus,
                COALESCE(has.criticality, 'Not Defined') AS criticality,
                app.domain AS domain,
                CASE
                    WHEN app.complianceScore <= 2 THEN 'Very High'
                    WHEN app.complianceScore <= 4 THEN 'High'
                    WHEN app.complianceScore <= 6 THEN 'Moderate'
                    WHEN app.complianceScore <= 8 THEN 'Low'
                    WHEN app.complianceScore <= 10 THEN 'Very Low'
                    ELSE ''
                END AS complianceRisk,
                apoc.map.fromPairs([key IN keys(app) WHERE key STARTS WITH 'Compliance' | [replace(key, 'Compliance', ''), app[key] = true]]) AS complianceList,
                CASE
                    WHEN app.securityScore <= 2 THEN 'Very High'
                    WHEN app.securityScore <= 4 THEN 'High'
                    WHEN app.securityScore <= 6 THEN 'Moderate'
                    WHEN app.securityScore <= 8 THEN 'Low'
                    WHEN app.securityScore <= 10 THEN 'Very Low'
                    ELSE ''
                END AS securityRisk,
                apoc.map.fromPairs([key IN keys(app) WHERE key STARTS WITH 'Security' | [replace(key, 'Security', ''), app[key] = true]]) AS securitySupportedList,
                app.SecuritySupportsSAML = true AS isSamlSupported,
                app.isMfaSupported = true AS isMfaSupported,
                CASE
                    WHEN 'High' IN severities THEN 'High'
                    WHEN 'Medium' IN severities THEN 'Medium'
                    ELSE 'Low'
                END AS severityRisk,
                apoc.map.fromPairs([
                    ['High', SIZE([x IN severities WHERE toLower(x) = 'high'])],
                    ['Medium', SIZE([x IN severities WHERE toLower(x) = 'medium'])],
                    ['Low', SIZE([x IN severities WHERE toLower(x) = 'low'])]
                ]) AS oauthSeverity,
                apoc.map.fromPairs([
                    ['breachDate', app.breachDate],
                    ['breachDataClasses', app.breachDataClasses]
                ]) AS breachData,
                sensitiveDataClasses,
                totalFindings,
                actionedCount,
                pendingCount,
                combinedActionTracker AS actionTracker,
                combinedActionOutcomes AS actionOutcomes"
  - id: apps_detailed_BID_06
    name: "No MFA used Detailed Widget"
    label: Widget
    template: this_template
    enabled: true
    type: drilldown_widget
    widget_type: drilldown_widget
    dataSourceType: knowledgegraph
    allowed_params: true
    className: col-span-1
    query_id: ""
    input_params:
      endtime: $endtime
      appId: $appId
      behavior: $behavior
    queryFilters: []
    query: "MATCH (user:USER {subscriber: $subscriber, tenant: $tenant})-[]-(email:EMAIL)-[auth_type]-(account:ACCOUNT)-[:HAS_FINDING]-(finding:FINDING)-[]-(rule:RULE)-[]-(behavior:BEHAVIOR {id: $behavior})
            MATCH (account)-[:USING_APP]-(app:APPLICATION {id_: $appId})
            
            OPTIONAL MATCH (app)-[:USING_APP]-(shared_account:ACCOUNT {tenant: $tenant})<-[:CREDENTIAL_SHARED]-(shared_with:ACCOUNT {tenant: $tenant})
            WHERE 
                EXISTS((shared_account)-[:HAS_FINDING]->(:FINDING)-[]-(:RULE)-[]-(:BEHAVIOR {id: 'BID_09'}))
                AND EXISTS((shared_account)-[]-(:EMAIL)-[]-(:USER))
            OPTIONAL MATCH (account)-[hcf:HAS_CRED_FINGERPRINT]-(cf:CRED_FINGERPRINT)-[same_hcf:HAS_CRED_FINGERPRINT]-(same_password_account:ACCOUNT {tenant: $tenant})
            WHERE same_password_account <> account AND same_password_account.email = account.email
            OPTIONAL MATCH (app)-[]-(grant:GRANT)-[]-(scope:SCOPE)
            WHERE toLower(scope.severity) IN ['high', 'medium', 'low']
            OPTIONAL MATCH (app)-[has:HAS_APP_SETTINGS]-(tenant:TENANT {id: $tenant})
            OPTIONAL MATCH (finding)-[:TRIGGERED]-(action:ACTION)
            OPTIONAL MATCH (action)-[:RESULTED_IN]-(outcome:OUTCOME)
            OPTIONAL MATCH (finding)-[:HAS_ARTIFACT]->(dlp:DLP_FINAL_CLASS | DLP_ORIGINAL_CLASS)
            
            WITH app, auth_type, account, hcf, cf, same_hcf, shared_account, same_password_account, COLLECT(DISTINCT scope.severity) as severities, has, finding, action, outcome, dlp
            
            WITH app, auth_type, account, hcf, cf, same_hcf, shared_account, same_password_account, severities, has, finding, action, dlp,
                COALESCE(action.name, '-') AS actionName,
                COUNT(DISTINCT action) AS actionCount,
                CASE WHEN action IS NOT NULL AND outcome IS NULL THEN 'Not Responded'
                    WHEN outcome IS NOT NULL THEN COALESCE(outcome.value, outcome.message, '-')
                END as outcomeValue
            WHERE actionName IS NOT NULL
            
            WITH app, auth_type, account, hcf, cf, same_hcf, shared_account, same_password_account, severities, has, finding, action, dlp, actionName, actionCount,
                outcomeValue, COUNT(outcomeValue) AS outcomeCount
            
            WITH app, auth_type, account, hcf, cf, same_hcf, shared_account, same_password_account, severities, has, finding, action, dlp, actionName, actionCount,
                apoc.map.fromPairs(COLLECT([outcomeValue, outcomeCount])) as outcomeMap
            
            WITH app, severities, has,
                COUNT(DISTINCT CASE WHEN cf.compromised_password_status = true THEN account.id END) as compromised_passwords,
                COUNT(DISTINCT CASE WHEN cf.password_strength < 3 THEN account.id END) as weak_passwords,
                COUNT(DISTINCT shared_account) as shared_accounts,
                COUNT(DISTINCT same_password_account) as same_password_accounts,
                COUNT(DISTINCT CASE WHEN auth_type.isMfaEnabled IS NULL OR auth_type.isMfaEnabled <> true THEN auth_type END) as mfaDisabledCount,
                COUNT(DISTINCT account.id) as totalAccounts,
                COUNT(DISTINCT CASE WHEN type(auth_type) = 'CREDSBASED_ACCOUNT' THEN account.id END) as credsbased_account_count,
                COUNT(DISTINCT CASE WHEN type(auth_type) = 'OAUTH_ACCOUNT' THEN account.id END) as oauth_account_count,
                COUNT(DISTINCT finding.id) as totalFindings,
                COUNT(DISTINCT CASE WHEN action IS NOT NULL THEN action END) as actionedCount,
                COUNT(DISTINCT CASE WHEN action IS NULL THEN finding.id END) as pendingCount,
                MIN(COALESCE(
                    CASE WHEN account.creationTime <> '-' THEN account.creationTime ELSE NULL END, timestamp()
                )) AS firstAccessed,
                MAX(auth_type.last_access_time) AS lastAccessed,
                COLLECT(DISTINCT dlp.id) AS sensitiveDataClasses,
                apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, actionCount] END)) AS combinedActionTracker,
                apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, outcomeMap] END)) AS combinedActionOutcomes
            
            RETURN DISTINCT
                COALESCE(app.id_, app.internalId) AS id,
                COALESCE(app.name, app.domain, app.id) AS app,
                app.logoUrl AS appLogoUrl,
                app.description AS description,
                firstAccessed,
                lastAccessed,
                compromised_passwords,
                weak_passwords,
                shared_accounts,
                same_password_accounts,
                app.isMfaSupported = true as mfaSupported,
                mfaDisabledCount,
                totalAccounts,
                credsbased_account_count,
                oauth_account_count,
                COALESCE(has.approval_status, 'Not Defined') AS approvalStatus,
                COALESCE(has.criticality, 'Not Defined') AS criticality,
                app.domain AS domain,
                CASE
                    WHEN app.complianceScore <= 2 THEN 'Very High'
                    WHEN app.complianceScore <= 4 THEN 'High'
                    WHEN app.complianceScore <= 6 THEN 'Moderate'
                    WHEN app.complianceScore <= 8 THEN 'Low'
                    WHEN app.complianceScore <= 10 THEN 'Very Low'
                    ELSE ''
                END AS complianceRisk,
                apoc.map.fromPairs([key IN keys(app) WHERE key STARTS WITH 'Compliance' | [replace(key, 'Compliance', ''), app[key] = true]]) AS complianceList,
                CASE
                    WHEN app.securityScore <= 2 THEN 'Very High'
                    WHEN app.securityScore <= 4 THEN 'High'
                    WHEN app.securityScore <= 6 THEN 'Moderate'
                    WHEN app.securityScore <= 8 THEN 'Low'
                    WHEN app.securityScore <= 10 THEN 'Very Low'
                    ELSE ''
                END AS securityRisk,
                apoc.map.fromPairs([key IN keys(app) WHERE key STARTS WITH 'Security' | [replace(key, 'Security', ''), app[key] = true]]) AS securitySupportedList,
                app.SecuritySupportsSAML = true AS isSamlSupported,
                app.isMfaSupported = true AS isMfaSupported,
                CASE
                    WHEN 'High' IN severities THEN 'High'
                    WHEN 'Medium' IN severities THEN 'Medium'
                    ELSE 'Low'
                END AS severityRisk,
                apoc.map.fromPairs([
                    ['High', SIZE([x IN severities WHERE toLower(x) = 'high'])],
                    ['Medium', SIZE([x IN severities WHERE toLower(x) = 'medium'])],
                    ['Low', SIZE([x IN severities WHERE toLower(x) = 'low'])]
                ]) AS oauthSeverity,
                apoc.map.fromPairs([
                    ['breachDate', app.breachDate],
                    ['breachDataClasses', app.breachDataClasses]
                ]) AS breachData,
                sensitiveDataClasses,
                totalFindings,
                actionedCount,
                pendingCount,
                combinedActionTracker AS actionTracker,
                combinedActionOutcomes AS actionOutcomes"
  - id: apps_detailed_BID_07
    name: "Weak MFA used Detailed Widget"
    label: Widget
    template: this_template
    enabled: true
    type: drilldown_widget
    widget_type: drilldown_widget
    dataSourceType: knowledgegraph
    allowed_params: true
    className: col-span-1
    query_id: ""
    input_params:
      endtime: $endtime
      appId: $appId
      behavior: $behavior
    queryFilters: []
    query: "MATCH (user:USER {subscriber: $subscriber, tenant: $tenant})-[]-(email:EMAIL)-[auth_type]-(account:ACCOUNT)-[:HAS_FINDING]-(finding:FINDING)-[]-(rule:RULE)-[]-(behavior:BEHAVIOR {id: $behavior})
            MATCH (account)-[:USING_APP]-(app:APPLICATION {id_: $appId})
            
            OPTIONAL MATCH (app)-[:USING_APP]-(shared_account:ACCOUNT {tenant: $tenant})<-[:CREDENTIAL_SHARED]-(shared_with:ACCOUNT {tenant: $tenant})
            WHERE 
                EXISTS((shared_account)-[:HAS_FINDING]->(:FINDING)-[]-(:RULE)-[]-(:BEHAVIOR {id: 'BID_09'}))
                AND EXISTS((shared_account)-[]-(:EMAIL)-[]-(:USER))
            OPTIONAL MATCH (account)-[hcf:HAS_CRED_FINGERPRINT]-(cf:CRED_FINGERPRINT)-[same_hcf:HAS_CRED_FINGERPRINT]-(same_password_account:ACCOUNT {tenant: $tenant})
            WHERE same_password_account <> account AND same_password_account.email = account.email
            OPTIONAL MATCH (app)-[]-(grant:GRANT)-[]-(scope:SCOPE)
            WHERE toLower(scope.severity) IN ['high', 'medium', 'low']
            OPTIONAL MATCH (app)-[has:HAS_APP_SETTINGS]-(tenant:TENANT {id: $tenant})
            OPTIONAL MATCH (finding)-[:TRIGGERED]-(action:ACTION)
            OPTIONAL MATCH (action)-[:RESULTED_IN]-(outcome:OUTCOME)
            OPTIONAL MATCH (finding)-[:HAS_ARTIFACT]->(dlp:DLP_FINAL_CLASS | DLP_ORIGINAL_CLASS)
            
            WITH app, auth_type, account, hcf, cf, same_hcf, shared_account, same_password_account, COLLECT(DISTINCT scope.severity) as severities, has, finding, action, outcome, dlp
            
            WITH app, auth_type, account, hcf, cf, same_hcf, shared_account, same_password_account, severities, has, finding, action, dlp,
                COALESCE(action.name, '-') AS actionName,
                COUNT(DISTINCT action) AS actionCount,
                CASE WHEN action IS NOT NULL AND outcome IS NULL THEN 'Not Responded'
                    WHEN outcome IS NOT NULL THEN COALESCE(outcome.value, outcome.message, '-')
                END as outcomeValue
            WHERE actionName IS NOT NULL
            
            WITH app, auth_type, account, hcf, cf, same_hcf, shared_account, same_password_account, severities, has, finding, action, dlp, actionName, actionCount,
                outcomeValue, COUNT(outcomeValue) AS outcomeCount
            
            WITH app, auth_type, account, hcf, cf, same_hcf, shared_account, same_password_account, severities, has, finding, action, dlp, actionName, actionCount,
                apoc.map.fromPairs(COLLECT([outcomeValue, outcomeCount])) as outcomeMap
            
            WITH app, severities, has,
                COUNT(DISTINCT CASE WHEN cf.compromised_password_status = true THEN account.id END) as compromised_passwords,
                COUNT(DISTINCT CASE WHEN cf.password_strength < 3 THEN account.id END) as weak_passwords,
                COUNT(DISTINCT shared_account) as shared_accounts,
                COUNT(DISTINCT same_password_account) as same_password_accounts,
                COUNT(DISTINCT CASE WHEN auth_type.isMfaEnabled IS NULL OR auth_type.isMfaEnabled <> true THEN auth_type END) as mfaDisabledCount,
                COUNT(DISTINCT account.id) as totalAccounts,
                COUNT(DISTINCT CASE WHEN type(auth_type) = 'CREDSBASED_ACCOUNT' THEN account.id END) as credsbased_account_count,
                COUNT(DISTINCT CASE WHEN type(auth_type) = 'OAUTH_ACCOUNT' THEN account.id END) as oauth_account_count,
                COUNT(DISTINCT finding.id) as totalFindings,
                COUNT(DISTINCT CASE WHEN action IS NOT NULL THEN action END) as actionedCount,
                COUNT(DISTINCT CASE WHEN action IS NULL THEN finding.id END) as pendingCount,
                MIN(COALESCE(
                    CASE WHEN account.creationTime <> '-' THEN account.creationTime ELSE NULL END, timestamp()
                )) AS firstAccessed,
                MAX(auth_type.last_access_time) AS lastAccessed,
                COLLECT(DISTINCT dlp.id) AS sensitiveDataClasses,
                apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, actionCount] END)) AS combinedActionTracker,
                apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, outcomeMap] END)) AS combinedActionOutcomes
            
            RETURN DISTINCT
                COALESCE(app.id_, app.internalId) AS id,
                COALESCE(app.name, app.domain, app.id) AS app,
                app.logoUrl AS appLogoUrl,
                app.description AS description,
                firstAccessed,
                lastAccessed,
                compromised_passwords,
                weak_passwords,
                shared_accounts,
                same_password_accounts,
                app.isMfaSupported = true as mfaSupported,
                mfaDisabledCount,
                totalAccounts,
                credsbased_account_count,
                oauth_account_count,
                COALESCE(has.approval_status, 'Not Defined') AS approvalStatus,
                COALESCE(has.criticality, 'Not Defined') AS criticality,
                app.domain AS domain,
                CASE
                    WHEN app.complianceScore <= 2 THEN 'Very High'
                    WHEN app.complianceScore <= 4 THEN 'High'
                    WHEN app.complianceScore <= 6 THEN 'Moderate'
                    WHEN app.complianceScore <= 8 THEN 'Low'
                    WHEN app.complianceScore <= 10 THEN 'Very Low'
                    ELSE ''
                END AS complianceRisk,
                apoc.map.fromPairs([key IN keys(app) WHERE key STARTS WITH 'Compliance' | [replace(key, 'Compliance', ''), app[key] = true]]) AS complianceList,
                CASE
                    WHEN app.securityScore <= 2 THEN 'Very High'
                    WHEN app.securityScore <= 4 THEN 'High'
                    WHEN app.securityScore <= 6 THEN 'Moderate'
                    WHEN app.securityScore <= 8 THEN 'Low'
                    WHEN app.securityScore <= 10 THEN 'Very Low'
                    ELSE ''
                END AS securityRisk,
                apoc.map.fromPairs([key IN keys(app) WHERE key STARTS WITH 'Security' | [replace(key, 'Security', ''), app[key] = true]]) AS securitySupportedList,
                app.SecuritySupportsSAML = true AS isSamlSupported,
                app.isMfaSupported = true AS isMfaSupported,
                CASE
                    WHEN 'High' IN severities THEN 'High'
                    WHEN 'Medium' IN severities THEN 'Medium'
                    ELSE 'Low'
                END AS severityRisk,
                apoc.map.fromPairs([
                    ['High', SIZE([x IN severities WHERE toLower(x) = 'high'])],
                    ['Medium', SIZE([x IN severities WHERE toLower(x) = 'medium'])],
                    ['Low', SIZE([x IN severities WHERE toLower(x) = 'low'])]
                ]) AS oauthSeverity,
                apoc.map.fromPairs([
                    ['breachDate', app.breachDate],
                    ['breachDataClasses', app.breachDataClasses]
                ]) AS breachData,
                sensitiveDataClasses,
                totalFindings,
                actionedCount,
                pendingCount,
                combinedActionTracker AS actionTracker,
                combinedActionOutcomes AS actionOutcomes"
  - id: apps_detailed_BID_08
    name: "Compromised Password Detailed Widget"
    label: Widget
    template: this_template
    enabled: true
    type: drilldown_widget
    widget_type: drilldown_widget
    dataSourceType: knowledgegraph
    allowed_params: true
    className: col-span-1
    query_id: ""
    input_params:
      endtime: $endtime
      appId: $appId
      behavior: $behavior
    queryFilters: []
    query: "MATCH (user:USER {subscriber: $subscriber, tenant: $tenant})-[]-(email:EMAIL)-[auth_type]-(account:ACCOUNT)-[:HAS_FINDING]-(finding:FINDING)-[]-(rule:RULE)-[]-(behavior:BEHAVIOR {id: $behavior})
            MATCH (account)-[:USING_APP]-(app:APPLICATION {id_: $appId})
            
            OPTIONAL MATCH (app)-[:USING_APP]-(shared_account:ACCOUNT {tenant: $tenant})<-[:CREDENTIAL_SHARED]-(shared_with:ACCOUNT {tenant: $tenant})
            WHERE 
                EXISTS((shared_account)-[:HAS_FINDING]->(:FINDING)-[]-(:RULE)-[]-(:BEHAVIOR {id: 'BID_09'}))
                AND EXISTS((shared_account)-[]-(:EMAIL)-[]-(:USER))
            OPTIONAL MATCH (account)-[hcf:HAS_CRED_FINGERPRINT]-(cf:CRED_FINGERPRINT)-[same_hcf:HAS_CRED_FINGERPRINT]-(same_password_account:ACCOUNT {tenant: $tenant})
            WHERE same_password_account <> account AND same_password_account.email = account.email
            OPTIONAL MATCH (app)-[]-(grant:GRANT)-[]-(scope:SCOPE)
            WHERE toLower(scope.severity) IN ['high', 'medium', 'low']
            OPTIONAL MATCH (app)-[has:HAS_APP_SETTINGS]-(tenant:TENANT {id: $tenant})
            OPTIONAL MATCH (finding)-[:TRIGGERED]-(action:ACTION)
            OPTIONAL MATCH (action)-[:RESULTED_IN]-(outcome:OUTCOME)
            OPTIONAL MATCH (finding)-[:HAS_ARTIFACT]->(dlp:DLP_FINAL_CLASS | DLP_ORIGINAL_CLASS)
            
            WITH app, auth_type, account, hcf, cf, same_hcf, shared_account, same_password_account, COLLECT(DISTINCT scope.severity) as severities, has, finding, action, outcome, dlp
            
            WITH app, auth_type, account, hcf, cf, same_hcf, shared_account, same_password_account, severities, has, finding, action, dlp,
                COALESCE(action.name, '-') AS actionName,
                COUNT(DISTINCT action) AS actionCount,
                CASE WHEN action IS NOT NULL AND outcome IS NULL THEN 'Not Responded'
                    WHEN outcome IS NOT NULL THEN COALESCE(outcome.value, outcome.message, '-')
                END as outcomeValue
            WHERE actionName IS NOT NULL
            
            WITH app, auth_type, account, hcf, cf, same_hcf, shared_account, same_password_account, severities, has, finding, action, dlp, actionName, actionCount,
                outcomeValue, COUNT(outcomeValue) AS outcomeCount
            
            WITH app, auth_type, account, hcf, cf, same_hcf, shared_account, same_password_account, severities, has, finding, action, dlp, actionName, actionCount,
                apoc.map.fromPairs(COLLECT([outcomeValue, outcomeCount])) as outcomeMap
            
            WITH app, severities, has,
                COUNT(DISTINCT CASE WHEN cf.compromised_password_status = true THEN account.id END) as compromised_passwords,
                COUNT(DISTINCT CASE WHEN cf.password_strength < 3 THEN account.id END) as weak_passwords,
                COUNT(DISTINCT shared_account) as shared_accounts,
                COUNT(DISTINCT same_password_account) as same_password_accounts,
                COUNT(DISTINCT CASE WHEN auth_type.isMfaEnabled IS NULL OR auth_type.isMfaEnabled <> true THEN auth_type END) as mfaDisabledCount,
                COUNT(DISTINCT account.id) as totalAccounts,
                COUNT(DISTINCT CASE WHEN type(auth_type) = 'CREDSBASED_ACCOUNT' THEN account.id END) as credsbased_account_count,
                COUNT(DISTINCT CASE WHEN type(auth_type) = 'OAUTH_ACCOUNT' THEN account.id END) as oauth_account_count,
                COUNT(DISTINCT finding.id) as totalFindings,
                COUNT(DISTINCT CASE WHEN action IS NOT NULL THEN action END) as actionedCount,
                COUNT(DISTINCT CASE WHEN action IS NULL THEN finding.id END) as pendingCount,
                MIN(COALESCE(
                    CASE WHEN account.creationTime <> '-' THEN account.creationTime ELSE NULL END, timestamp()
                )) AS firstAccessed,
                MAX(auth_type.last_access_time) AS lastAccessed,
                COLLECT(DISTINCT dlp.id) AS sensitiveDataClasses,
                apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, actionCount] END)) AS combinedActionTracker,
                apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, outcomeMap] END)) AS combinedActionOutcomes
            
            RETURN DISTINCT
                COALESCE(app.id_, app.internalId) AS id,
                COALESCE(app.name, app.domain, app.id) AS app,
                app.logoUrl AS appLogoUrl,
                app.description AS description,
                firstAccessed,
                lastAccessed,
                compromised_passwords,
                weak_passwords,
                shared_accounts,
                same_password_accounts,
                app.isMfaSupported = true as mfaSupported,
                mfaDisabledCount,
                totalAccounts,
                credsbased_account_count,
                oauth_account_count,
                COALESCE(has.approval_status, 'Not Defined') AS approvalStatus,
                COALESCE(has.criticality, 'Not Defined') AS criticality,
                app.domain AS domain,
                CASE
                    WHEN app.complianceScore <= 2 THEN 'Very High'
                    WHEN app.complianceScore <= 4 THEN 'High'
                    WHEN app.complianceScore <= 6 THEN 'Moderate'
                    WHEN app.complianceScore <= 8 THEN 'Low'
                    WHEN app.complianceScore <= 10 THEN 'Very Low'
                    ELSE ''
                END AS complianceRisk,
                apoc.map.fromPairs([key IN keys(app) WHERE key STARTS WITH 'Compliance' | [replace(key, 'Compliance', ''), app[key] = true]]) AS complianceList,
                CASE
                    WHEN app.securityScore <= 2 THEN 'Very High'
                    WHEN app.securityScore <= 4 THEN 'High'
                    WHEN app.securityScore <= 6 THEN 'Moderate'
                    WHEN app.securityScore <= 8 THEN 'Low'
                    WHEN app.securityScore <= 10 THEN 'Very Low'
                    ELSE ''
                END AS securityRisk,
                apoc.map.fromPairs([key IN keys(app) WHERE key STARTS WITH 'Security' | [replace(key, 'Security', ''), app[key] = true]]) AS securitySupportedList,
                app.SecuritySupportsSAML = true AS isSamlSupported,
                app.isMfaSupported = true AS isMfaSupported,
                CASE
                    WHEN 'High' IN severities THEN 'High'
                    WHEN 'Medium' IN severities THEN 'Medium'
                    ELSE 'Low'
                END AS severityRisk,
                apoc.map.fromPairs([
                    ['High', SIZE([x IN severities WHERE toLower(x) = 'high'])],
                    ['Medium', SIZE([x IN severities WHERE toLower(x) = 'medium'])],
                    ['Low', SIZE([x IN severities WHERE toLower(x) = 'low'])]
                ]) AS oauthSeverity,
                apoc.map.fromPairs([
                    ['breachDate', app.breachDate],
                    ['breachDataClasses', app.breachDataClasses]
                ]) AS breachData,
                sensitiveDataClasses,
                totalFindings,
                actionedCount,
                pendingCount,
                combinedActionTracker AS actionTracker,
                combinedActionOutcomes AS actionOutcomes"
  - id: apps_detailed_BID_09
    name: "Credential sharing Detailed Widget"
    label: Widget
    template: this_template
    enabled: true
    type: drilldown_widget
    widget_type: drilldown_widget
    dataSourceType: knowledgegraph
    allowed_params: true
    className: col-span-1
    query_id: ""
    input_params:
      endtime: $endtime
      appId: $appId
      accountId: $accountId
      behavior: $behavior
    queryFilters: []
    query: "MATCH (app:APPLICATION {id_: $appId})<-[:USING_APP]-(shared_account:ACCOUNT {id: $accountId, subscriber: $subscriber, tenant: $tenant})
            MATCH (shared_email:EMAIL)-[auth_type]-(shared_account)
            OPTIONAL MATCH (shared_user:USER)-[]-(email)
            OPTIONAL MATCH (shared_account)<-[:CREDENTIAL_SHARED]-(account:ACCOUNT {tenant: $tenant})-[:HAS_FINDING]-(finding:FINDING)-[]-(rule:RULE)-[]-(behavior:BEHAVIOR {id: $behavior})
            WHERE 
                EXISTS((account)-[]-(:EMAIL))
                AND finding.sharedAccountId = shared_account.id
                AND shared_account <> account
                AND toLower(shared_account.email) <> toLower(account.email)
            OPTIONAL MATCH (account)<-[auth_type_target:CREDSBASED_ACCOUNT]-(email:EMAIL)
            OPTIONAL MATCH (email)<-[:HAS_EMAIL]-(user:USER)
            WITH app, auth_type, shared_account, account, shared_email, email, shared_user, user, finding
            WHERE NOT EXISTS((user)-[:SAME_USER]-(shared_user))
            OPTIONAL MATCH (shared_account)-[hcf:HAS_CRED_FINGERPRINT]-(cf:CRED_FINGERPRINT)-[same_hcf:HAS_CRED_FINGERPRINT]-(same_password_account:ACCOUNT {tenant: $tenant})
            WHERE same_password_account <> shared_account AND toLower(same_password_account.email) = toLower(shared_account.email)
            OPTIONAL MATCH (app)-[]-(grant:GRANT)-[]-(scope:SCOPE)
            WHERE toLower(scope.severity) IN ['high', 'medium', 'low']
            OPTIONAL MATCH (app)-[has:HAS_APP_SETTINGS]-(tenant:TENANT {id: $tenant})
            OPTIONAL MATCH (finding)-[:TRIGGERED]-(action:ACTION)
            OPTIONAL MATCH (action)-[:RESULTED_IN]-(outcome:OUTCOME)
            OPTIONAL MATCH (finding)-[:HAS_ARTIFACT]->(dlp:DLP_FINAL_CLASS | DLP_ORIGINAL_CLASS)
            
            WITH app, auth_type, account, hcf, cf, same_hcf, shared_account, same_password_account, COLLECT(DISTINCT scope.severity) as severities, has, finding, action, outcome, dlp
            
            WITH app, auth_type, account, hcf, cf, same_hcf, shared_account, same_password_account, severities, has, finding, action, dlp,
                COALESCE(action.name, '-') AS actionName,
                CASE 
                    WHEN action IS NOT NULL AND outcome IS NULL THEN 'Not Responded'
                    WHEN outcome IS NOT NULL THEN COALESCE(outcome.value, outcome.message, '-')
                END as outcomeValue
            WHERE actionName IS NOT NULL
            
            WITH app, auth_type, account, hcf, cf, same_hcf, shared_account, same_password_account, severities, has, finding, action, dlp, actionName,
                outcomeValue
            
            WITH app, auth_type, account, hcf, cf, same_hcf, shared_account, same_password_account, severities, has, finding, action, dlp, actionName, outcomeValue
            
            WITH app, severities, has,
                COUNT(DISTINCT CASE WHEN cf.compromised_password_status = true THEN account.id END) as compromised_passwords,
                COUNT(DISTINCT CASE WHEN cf.password_strength < 3 THEN account.id END) as weak_passwords,
                COUNT(DISTINCT shared_account) as shared_accounts,
                COUNT(DISTINCT same_password_account) as same_password_accounts,
                COUNT(DISTINCT CASE WHEN auth_type.isMfaEnabled IS NULL OR auth_type.isMfaEnabled <> true THEN auth_type END) as mfaDisabledCount,
                COUNT(DISTINCT account.id) as totalAccounts,
                COUNT(DISTINCT CASE WHEN type(auth_type) = 'CREDSBASED_ACCOUNT' THEN account.id END) as credsbased_account_count,
                COUNT(DISTINCT CASE WHEN type(auth_type) = 'OAUTH_ACCOUNT' THEN account.id END) as oauth_account_count,
                COUNT(DISTINCT finding.id) as totalFindings,
                COUNT(DISTINCT CASE WHEN action IS NOT NULL THEN action END) as actionedCount,
                COUNT(DISTINCT CASE WHEN action IS NULL THEN finding.id END) as pendingCount,
                MIN(COALESCE(
                    CASE WHEN account.creationTime <> '-' THEN account.creationTime ELSE NULL END, timestamp()
                )) AS firstAccessed,
                MAX(auth_type.last_access_time) AS lastAccessed,
                COLLECT(DISTINCT dlp.id) AS sensitiveDataClasses,
                actionName, COUNT(DISTINCT action) AS actionCount, outcomeValue, COUNT(DISTINCT CASE WHEN outcomeValue IS NOT NULL THEN action END) AS outcomeCount
            
            WITH app, severities, has,
                compromised_passwords,
                weak_passwords,
                shared_accounts,
                same_password_accounts,
                mfaDisabledCount,
                totalAccounts,
                credsbased_account_count,
                oauth_account_count,
                SUM(totalFindings) AS totalFindings,
                SUM(actionedCount) AS actionedCount,
                SUM(pendingCount) AS pendingCount,
                firstAccessed,
                lastAccessed,
                sensitiveDataClasses,
                actionName, actionCount,
                apoc.map.fromPairs(COLLECT([outcomeValue, outcomeCount])) as outcomeMap
            
            WITH app, severities, has,
                compromised_passwords,
                weak_passwords,
                shared_accounts,
                same_password_accounts,
                mfaDisabledCount,
                totalAccounts,
                credsbased_account_count,
                oauth_account_count,
                SUM(totalFindings) AS totalFindings,
                SUM(actionedCount) AS actionedCount,
                SUM(pendingCount) AS pendingCount,
                firstAccessed,
                lastAccessed,
                sensitiveDataClasses,
                apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, actionCount] END)) AS combinedActionTracker,
                apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, outcomeMap] END)) AS combinedActionOutcomes
            
            RETURN DISTINCT
                COALESCE(app.id_, app.internalId) AS id,
                COALESCE(app.name, app.domain, app.id) AS app,
                app.logoUrl AS appLogoUrl,
                app.description AS description,
                firstAccessed,
                lastAccessed,
                compromised_passwords,
                weak_passwords,
                shared_accounts,
                same_password_accounts,
                app.isMfaSupported = true as mfaSupported,
                mfaDisabledCount,
                totalAccounts,
                credsbased_account_count,
                oauth_account_count,
                COALESCE(has.approval_status, 'Not Defined') AS approvalStatus,
                COALESCE(has.criticality, 'Not Defined') AS criticality,
                app.domain AS domain,
                CASE
                    WHEN app.complianceScore <= 2 THEN 'Very High'
                    WHEN app.complianceScore <= 4 THEN 'High'
                    WHEN app.complianceScore <= 6 THEN 'Moderate'
                    WHEN app.complianceScore <= 8 THEN 'Low'
                    WHEN app.complianceScore <= 10 THEN 'Very Low'
                    ELSE ''
                END AS complianceRisk,
                apoc.map.fromPairs([key IN keys(app) WHERE key STARTS WITH 'Compliance' | [replace(key, 'Compliance', ''), app[key] = true]]) AS complianceList,
                CASE
                    WHEN app.securityScore <= 2 THEN 'Very High'
                    WHEN app.securityScore <= 4 THEN 'High'
                    WHEN app.securityScore <= 6 THEN 'Moderate'
                    WHEN app.securityScore <= 8 THEN 'Low'
                    WHEN app.securityScore <= 10 THEN 'Very Low'
                    ELSE ''
                END AS securityRisk,
                apoc.map.fromPairs([key IN keys(app) WHERE key STARTS WITH 'Security' | [replace(key, 'Security', ''), app[key] = true]]) AS securitySupportedList,
                app.SecuritySupportsSAML = true AS isSamlSupported,
                app.isMfaSupported = true AS isMfaSupported,
                CASE
                    WHEN 'High' IN severities THEN 'High'
                    WHEN 'Medium' IN severities THEN 'Medium'
                    ELSE 'Low'
                END AS severityRisk,
                apoc.map.fromPairs([
                    ['High', SIZE([x IN severities WHERE toLower(x) = 'high'])],
                    ['Medium', SIZE([x IN severities WHERE toLower(x) = 'medium'])],
                    ['Low', SIZE([x IN severities WHERE toLower(x) = 'low'])]
                ]) AS oauthSeverity,
                apoc.map.fromPairs([
                    ['breachDate', app.breachDate],
                    ['breachDataClasses', app.breachDataClasses]
                ]) AS breachData,
                sensitiveDataClasses,
                totalFindings,
                actionedCount,
                pendingCount,
                combinedActionTracker AS actionTracker,
                combinedActionOutcomes AS actionOutcomes"
  - id: apps_detailed_BID_09_timeline
    name: "Credential sharing Timeline"
    label: Widget
    template: this_template
    enabled: true
    type: drilldown_widget
    widget_type: drilldown_widget
    dataSourceType: knowledgegraph
    allowed_params: true
    className: col-span-1
    query_id: ""
    input_params:
      endtime: $endtime
      accountId: $accountId
      behavior: $behavior
    queryFilters: []
    query: "WITH 'yyyy-MM-dd' AS dateFormat

            // Find the date range of credential sharing\n
            MATCH (shared_account:ACCOUNT {id: $accountId, tenant: $tenant})<-[cs:CREDENTIAL_SHARED]-(account:ACCOUNT {tenant: $tenant})
           
            MATCH (shared_account)<-[auth_type]-(shared_email:EMAIL)
            OPTIONAL MATCH (shared_email)<-[:HAS_EMAIL]-(shared_user:USER)
            MATCH (account)<-[auth_type_target:CREDSBASED_ACCOUNT]-(email:EMAIL)
            OPTIONAL MATCH (email)<-[:HAS_EMAIL]-(user:USER)
            WITH dateFormat, cs, shared_account, account, shared_email, email, shared_user, user
            WHERE NOT EXISTS((user)-[:SAME_USER]-(shared_user))
            
            WITH shared_account, date(apoc.date.format(min(cs.last_access_time), 'ms', dateFormat)) AS startDate,
                 date(apoc.date.format(max(cs.last_access_time), 'ms', dateFormat)) AS endDate, dateFormat

            // Generate all dates in the range\n
            WITH shared_account, startDate, endDate, dateFormat,
                 [day IN range(0, duration.inDays(startDate, endDate).days) | startDate + duration({days: day})] AS dates
            UNWIND dates AS accessDate

            // Count credential usage per day\n
            OPTIONAL MATCH (shared_account)<-[cs:CREDENTIAL_SHARED]-()
            WHERE date(apoc.date.format(cs.last_access_time, 'ms', dateFormat)) = accessDate
            WITH accessDate, count(cs) AS usageCount
            ORDER BY accessDate ASC

            RETURN accessDate, usageCount

            ORDER BY accessDate ASC"
  - id: apps_detailed_BID_10
    name: "Password reuse Detailed Widget"
    label: Widget
    template: this_template
    enabled: true
    type: drilldown_widget
    widget_type: drilldown_widget
    dataSourceType: knowledgegraph
    allowed_params: true
    className: col-span-1
    query_id: ""
    input_params:
      endtime: $endtime
      appId: $appId
      behavior: $behavior
    queryFilters: []
    query: "MATCH (user:USER {subscriber: $subscriber, tenant: $tenant})-[]-(email:EMAIL)-[auth_type]-(account:ACCOUNT)-[:HAS_FINDING]-(finding:FINDING)-[]-(rule:RULE)-[]-(behavior:BEHAVIOR {id: $behavior})
            MATCH (account)-[:USING_APP]-(app:APPLICATION {id_: $appId})
            
            OPTIONAL MATCH (app)-[:USING_APP]-(shared_account:ACCOUNT {tenant: $tenant})<-[:CREDENTIAL_SHARED]-(shared_with:ACCOUNT {tenant: $tenant})
            WHERE 
                EXISTS((shared_account)-[:HAS_FINDING]->(:FINDING)-[]-(:RULE)-[]-(:BEHAVIOR {id: 'BID_09'}))
                AND EXISTS((shared_account)-[]-(:EMAIL)-[]-(:USER))
            OPTIONAL MATCH (account)-[hcf:HAS_CRED_FINGERPRINT]-(cf:CRED_FINGERPRINT)-[same_hcf:HAS_CRED_FINGERPRINT]-(same_password_account:ACCOUNT {tenant: $tenant})
            WHERE same_password_account <> account AND same_password_account.email = account.email
            OPTIONAL MATCH (app)-[]-(grant:GRANT)-[]-(scope:SCOPE)
            WHERE toLower(scope.severity) IN ['high', 'medium', 'low']
            OPTIONAL MATCH (app)-[has:HAS_APP_SETTINGS]-(tenant:TENANT {id: $tenant})
            OPTIONAL MATCH (finding)-[:TRIGGERED]-(action:ACTION)
            OPTIONAL MATCH (action)-[:RESULTED_IN]-(outcome:OUTCOME)
            OPTIONAL MATCH (finding)-[:HAS_ARTIFACT]->(dlp:DLP_FINAL_CLASS | DLP_ORIGINAL_CLASS)
            
            WITH app, auth_type, account, hcf, cf, same_hcf, shared_account, same_password_account, COLLECT(DISTINCT scope.severity) as severities, has, finding, action, outcome, dlp
            
            WITH app, auth_type, account, hcf, cf, same_hcf, shared_account, same_password_account, severities, has, finding, action, dlp,
                COALESCE(action.name, '-') AS actionName,
                COUNT(DISTINCT action) AS actionCount,
                CASE WHEN action IS NOT NULL AND outcome IS NULL THEN 'Not Responded'
                    WHEN outcome IS NOT NULL THEN COALESCE(outcome.value, outcome.message, '-')
                END as outcomeValue
            WHERE actionName IS NOT NULL
            
            WITH app, auth_type, account, hcf, cf, same_hcf, shared_account, same_password_account, severities, has, finding, action, dlp, actionName, actionCount,
                outcomeValue, COUNT(outcomeValue) AS outcomeCount
            
            WITH app, auth_type, account, hcf, cf, same_hcf, shared_account, same_password_account, severities, has, finding, action, dlp, actionName, actionCount,
                apoc.map.fromPairs(COLLECT([outcomeValue, outcomeCount])) as outcomeMap
            
            WITH app, severities, has,
                COUNT(DISTINCT CASE WHEN cf.compromised_password_status = true THEN account.id END) as compromised_passwords,
                COUNT(DISTINCT CASE WHEN cf.password_strength < 3 THEN account.id END) as weak_passwords,
                COUNT(DISTINCT shared_account) as shared_accounts,
                COUNT(DISTINCT same_password_account) as same_password_accounts,
                COUNT(DISTINCT CASE WHEN auth_type.isMfaEnabled IS NULL OR auth_type.isMfaEnabled <> true THEN auth_type END) as mfaDisabledCount,
                COUNT(DISTINCT account.id) as totalAccounts,
                COUNT(DISTINCT CASE WHEN type(auth_type) = 'CREDSBASED_ACCOUNT' THEN account.id END) as credsbased_account_count,
                COUNT(DISTINCT CASE WHEN type(auth_type) = 'OAUTH_ACCOUNT' THEN account.id END) as oauth_account_count,
                COUNT(DISTINCT finding.id) as totalFindings,
                COUNT(DISTINCT CASE WHEN action IS NOT NULL THEN action END) as actionedCount,
                COUNT(DISTINCT CASE WHEN action IS NULL THEN finding.id END) as pendingCount,
                MIN(COALESCE(
                    CASE WHEN account.creationTime <> '-' THEN account.creationTime ELSE NULL END, timestamp()
                )) AS firstAccessed,
                MAX(auth_type.last_access_time) AS lastAccessed,
                COLLECT(DISTINCT dlp.id) AS sensitiveDataClasses,
                apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, actionCount] END)) AS combinedActionTracker,
                apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, outcomeMap] END)) AS combinedActionOutcomes
            
            RETURN DISTINCT
                COALESCE(app.id_, app.internalId) AS id,
                COALESCE(app.name, app.domain, app.id) AS app,
                app.logoUrl AS appLogoUrl,
                app.description AS description,
                firstAccessed,
                lastAccessed,
                compromised_passwords,
                weak_passwords,
                shared_accounts,
                same_password_accounts,
                app.isMfaSupported = true as mfaSupported,
                mfaDisabledCount,
                totalAccounts,
                credsbased_account_count,
                oauth_account_count,
                COALESCE(has.approval_status, 'Not Defined') AS approvalStatus,
                COALESCE(has.criticality, 'Not Defined') AS criticality,
                app.domain AS domain,
                CASE
                    WHEN app.complianceScore <= 2 THEN 'Very High'
                    WHEN app.complianceScore <= 4 THEN 'High'
                    WHEN app.complianceScore <= 6 THEN 'Moderate'
                    WHEN app.complianceScore <= 8 THEN 'Low'
                    WHEN app.complianceScore <= 10 THEN 'Very Low'
                    ELSE ''
                END AS complianceRisk,
                apoc.map.fromPairs([key IN keys(app) WHERE key STARTS WITH 'Compliance' | [replace(key, 'Compliance', ''), app[key] = true]]) AS complianceList,
                CASE
                    WHEN app.securityScore <= 2 THEN 'Very High'
                    WHEN app.securityScore <= 4 THEN 'High'
                    WHEN app.securityScore <= 6 THEN 'Moderate'
                    WHEN app.securityScore <= 8 THEN 'Low'
                    WHEN app.securityScore <= 10 THEN 'Very Low'
                    ELSE ''
                END AS securityRisk,
                apoc.map.fromPairs([key IN keys(app) WHERE key STARTS WITH 'Security' | [replace(key, 'Security', ''), app[key] = true]]) AS securitySupportedList,
                app.SecuritySupportsSAML = true AS isSamlSupported,
                app.isMfaSupported = true AS isMfaSupported,
                CASE
                    WHEN 'High' IN severities THEN 'High'
                    WHEN 'Medium' IN severities THEN 'Medium'
                    ELSE 'Low'
                END AS severityRisk,
                apoc.map.fromPairs([
                    ['High', SIZE([x IN severities WHERE toLower(x) = 'high'])],
                    ['Medium', SIZE([x IN severities WHERE toLower(x) = 'medium'])],
                    ['Low', SIZE([x IN severities WHERE toLower(x) = 'low'])]
                ]) AS oauthSeverity,
                apoc.map.fromPairs([
                    ['breachDate', app.breachDate],
                    ['breachDataClasses', app.breachDataClasses]
                ]) AS breachData,
                sensitiveDataClasses,
                totalFindings,
                actionedCount,
                pendingCount,
                combinedActionTracker AS actionTracker,
                combinedActionOutcomes AS actionOutcomes"
  - id: apps_detailed_BID_11
    name: "Weak Password Detailed Widget"
    label: Widget
    template: this_template
    enabled: true
    type: drilldown_widget
    widget_type: drilldown_widget
    dataSourceType: knowledgegraph
    allowed_params: true
    className: col-span-1
    query_id: ""
    input_params:
      endtime: $endtime
      appId: $appId
      behavior: $behavior
    queryFilters: []
    query: "MATCH (user:USER {subscriber: $subscriber, tenant: $tenant})-[:HAS_EMAIL]->(email:EMAIL)-[auth_type]->(account:ACCOUNT)-[:HAS_FINDING]->(finding:FINDING)<-[:EVALUATED_TO]-(rule:RULE)-[:BELONGS_TO]->(behavior:BEHAVIOR {id: $behavior})
            MATCH (account)-[:USING_APP]->(app:APPLICATION {id_: $appId})
            
            OPTIONAL MATCH (app)-[:USING_APP]-(shared_account:ACCOUNT {tenant: $tenant})<-[:CREDENTIAL_SHARED]-(shared_with:ACCOUNT {tenant: $tenant})
            WHERE 
                EXISTS((shared_account)-[:HAS_FINDING]->(:FINDING)-[]-(:RULE)-[]-(:BEHAVIOR {id: 'BID_09'}))
                AND EXISTS((shared_account)-[]-(:EMAIL)-[:HAS_EMAIL]-(:USER))
            OPTIONAL MATCH (account)-[hcf:HAS_CRED_FINGERPRINT]->(cf:CRED_FINGERPRINT)<-[same_hcf:HAS_CRED_FINGERPRINT]-(same_password_account:ACCOUNT {tenant: $tenant})
            WHERE same_password_account <> account AND same_password_account.email = account.email
            OPTIONAL MATCH (app)-[:HAS_GRANT]->(grant:GRANT)-[:HAS_SCOPE]->(scope:SCOPE)
            WHERE toLower(scope.severity) IN ['high', 'medium', 'low']
            OPTIONAL MATCH (app)<-[has:HAS_APP_SETTINGS]-(tenant:TENANT {id: $tenant})
            OPTIONAL MATCH (finding)-[:TRIGGERED]->(action:ACTION)
            OPTIONAL MATCH (action)-[:RESULTED_IN]->(outcome:OUTCOME)
            OPTIONAL MATCH (finding)-[:HAS_ARTIFACT]->(dlp:DLP_FINAL_CLASS | DLP_ORIGINAL_CLASS)
            
            WITH app, auth_type, account, hcf, cf, same_hcf, shared_account, same_password_account, COLLECT(DISTINCT scope.severity) as severities, has, finding, action, outcome, dlp
            
            WITH app, auth_type, account, hcf, cf, same_hcf, shared_account, same_password_account, severities, has, finding, action, dlp,
                COALESCE(action.name, '-') AS actionName,
                COUNT(DISTINCT action) AS actionCount,
                CASE WHEN action IS NOT NULL AND outcome IS NULL THEN 'Not Responded'
                    WHEN outcome IS NOT NULL THEN COALESCE(outcome.value, outcome.message, '-')
                END as outcomeValue
            WHERE actionName IS NOT NULL
            
            WITH app, auth_type, account, hcf, cf, same_hcf, shared_account, same_password_account, severities, has, finding, action, dlp, actionName, actionCount,
                outcomeValue, COUNT(outcomeValue) AS outcomeCount
            
            WITH app, auth_type, account, hcf, cf, same_hcf, shared_account, same_password_account, severities, has, finding, action, dlp, actionName, actionCount,
                apoc.map.fromPairs(COLLECT([outcomeValue, outcomeCount])) as outcomeMap
            
            WITH app, severities, has,
                COUNT(DISTINCT CASE WHEN cf.compromised_password_status = true THEN account.id END) as compromised_passwords,
                COUNT(DISTINCT CASE WHEN cf.password_strength < 3 THEN account.id END) as weak_passwords,
                COUNT(DISTINCT shared_account) as shared_accounts,
                COUNT(DISTINCT same_password_account) as same_password_accounts,
                COUNT(DISTINCT CASE WHEN auth_type.isMfaEnabled IS NULL OR auth_type.isMfaEnabled <> true THEN auth_type END) as mfaDisabledCount,
                COUNT(DISTINCT account.id) as totalAccounts,
                COUNT(DISTINCT CASE WHEN type(auth_type) = 'CREDSBASED_ACCOUNT' THEN account.id END) as credsbased_account_count,
                COUNT(DISTINCT CASE WHEN type(auth_type) = 'OAUTH_ACCOUNT' THEN account.id END) as oauth_account_count,
                COUNT(DISTINCT finding.id) as totalFindings,
                COUNT(DISTINCT CASE WHEN action IS NOT NULL THEN action END) as actionedCount,
                COUNT(DISTINCT CASE WHEN action IS NULL THEN finding.id END) as pendingCount,
                MIN(COALESCE(
                    CASE WHEN account.creationTime <> '-' THEN account.creationTime ELSE NULL END, timestamp()
                )) AS firstAccessed,
                MAX(auth_type.last_access_time) AS lastAccessed,
                COLLECT(DISTINCT dlp.id) AS sensitiveDataClasses,
                apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, actionCount] END)) AS combinedActionTracker,
                apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, outcomeMap] END)) AS combinedActionOutcomes
            
            RETURN DISTINCT
                COALESCE(app.id_, app.internalId) AS id,
                COALESCE(app.name, app.domain, app.id) AS app,
                app.logoUrl AS appLogoUrl,
                app.description AS description,
                firstAccessed,
                lastAccessed,
                compromised_passwords,
                weak_passwords,
                shared_accounts,
                same_password_accounts,
                app.isMfaSupported = true as mfaSupported,
                mfaDisabledCount,
                totalAccounts,
                credsbased_account_count,
                oauth_account_count,
                COALESCE(has.approval_status, 'Not Defined') AS approvalStatus,
                COALESCE(has.criticality, 'Not Defined') AS criticality,
                app.domain AS domain,
                CASE
                    WHEN app.complianceScore <= 2 THEN 'Very High'
                    WHEN app.complianceScore <= 4 THEN 'High'
                    WHEN app.complianceScore <= 6 THEN 'Moderate'
                    WHEN app.complianceScore <= 8 THEN 'Low'
                    WHEN app.complianceScore <= 10 THEN 'Very Low'
                    ELSE ''
                END AS complianceRisk,
                apoc.map.fromPairs([key IN keys(app) WHERE key STARTS WITH 'Compliance' | [replace(key, 'Compliance', ''), app[key] = true]]) AS complianceList,
                CASE
                    WHEN app.securityScore <= 2 THEN 'Very High'
                    WHEN app.securityScore <= 4 THEN 'High'
                    WHEN app.securityScore <= 6 THEN 'Moderate'
                    WHEN app.securityScore <= 8 THEN 'Low'
                    WHEN app.securityScore <= 10 THEN 'Very Low'
                    ELSE ''
                END AS securityRisk,
                apoc.map.fromPairs([key IN keys(app) WHERE key STARTS WITH 'Security' | [replace(key, 'Security', ''), app[key] = true]]) AS securitySupportedList,
                app.SecuritySupportsSAML = true AS isSamlSupported,
                CASE
                    WHEN 'High' IN severities THEN 'High'
                    WHEN 'Medium' IN severities THEN 'Medium'
                    ELSE 'Low'
                END AS severityRisk,
                apoc.map.fromPairs([
                    ['High', SIZE([x IN severities WHERE toLower(x) = 'high'])],
                    ['Medium', SIZE([x IN severities WHERE toLower(x) = 'medium'])],
                    ['Low', SIZE([x IN severities WHERE toLower(x) = 'low'])]
                ]) AS oauthSeverity,
                apoc.map.fromPairs([
                    ['breachDate', app.breachDate],
                    ['breachDataClasses', app.breachDataClasses]
                ]) AS breachData,
                sensitiveDataClasses,
                totalFindings,
                actionedCount,
                pendingCount,
                combinedActionTracker AS actionTracker,
                combinedActionOutcomes AS actionOutcomes"
table_render:
  insights:
    queries: []
  table_additional_data:
    no_hover: true
    row_border: true
    alternate_row_colors: true
    no_table_padding: true
    table_heading_bg: bg-dark-300
    table_filters_wrapper_class: grid grid-cols-12
    no_calendar: true
    no_drilldown: true
  table_filters:
    risk_level:
      show_in_view:
        - id: unapproved_ai_applications
          is_default: false
        - id: ai_applications_with_risky_oauth_scopes
          is_default: false
        - id: newly_introduced_ai_users
          is_default: false
        - id: users_leaking_sensitive_data
          is_default: false
    criticality:
      show_in_view:
        - id: unapproved_ai_applications
          is_default: false
        - id: ai_applications_with_risky_oauth_scopes
          is_default: false
        - id: newly_introduced_ai_users
          is_default: false
        - id: users_leaking_sensitive_data
          is_default: false
    approval_status:
      show_in_view:
        - id: unapproved_ai_applications
          is_default: true
        - id: ai_applications_with_risky_oauth_scopes
          is_default: true
        - id: newly_introduced_ai_users
          is_default: true
        - id: users_leaking_sensitive_data
          is_default: true
    number_of_accounts:
      show_in_view:
        - id: unapproved_ai_applications
          is_default: true
        - id: ai_applications_with_risky_oauth_scopes
          is_default: true
        - id: newly_introduced_ai_users
          is_default: true
        - id: users_leaking_sensitive_data
          is_default: true
    technical_owner:
      show_in_view:
        - id: unapproved_ai_applications
          is_default: false
        - id: ai_applications_with_risky_oauth_scopes
          is_default: false
        - id: newly_introduced_ai_users
          is_default: false
        - id: users_leaking_sensitive_data
          is_default: false
    newly_discovered:
      show_in_view:
        - id: unapproved_ai_applications
          is_default: false
        - id: ai_applications_with_risky_oauth_scopes
          is_default: false
        - id: newly_introduced_ai_users
          is_default: false
        - id: users_leaking_sensitive_data
          is_default: false
    usage_level:
      show_in_view:
        - id: unapproved_ai_applications
          is_default: false
        - id: ai_applications_with_risky_oauth_scopes
          is_default: false
        - id: newly_introduced_ai_users
          is_default: false
        - id: users_leaking_sensitive_data
          is_default: false
    finding_status:
      show_in_view:
        - id: unapproved_ai_applications
          is_default: true
        - id: ai_applications_with_risky_oauth_scopes
          is_default: true
        - id: newly_introduced_ai_users
          is_default: true
        - id: users_leaking_sensitive_data
          is_default: true
    sensitive_data:
      show_in_view:
        - id: unapproved_ai_applications
          is_default: true
        - id: ai_applications_with_risky_oauth_scopes
          is_default: true
        - id: newly_introduced_ai_users
          is_default: true
        - id: users_leaking_sensitive_data
          is_default: true
    risky_oauth_scopes:
      show_in_view:
        - id: unapproved_ai_applications
          is_default: true
        - id: ai_applications_with_risky_oauth_scopes
          is_default: true
        - id: newly_introduced_ai_users
          is_default: true
        - id: users_leaking_sensitive_data
          is_default: true
    oauth_scope_risk_level:
      show_in_view:
        - id: unapproved_ai_applications
          is_default: true
        - id: ai_applications_with_risky_oauth_scopes
          is_default: true
        - id: newly_introduced_ai_users
          is_default: true
        - id: users_leaking_sensitive_data
          is_default: true
    granted_by:
      show_in_view:
        - id: unapproved_ai_applications
          is_default: true
        - id: ai_applications_with_risky_oauth_scopes
          is_default: true
        - id: newly_introduced_ai_users
          is_default: true
        - id: users_leaking_sensitive_data
          is_default: true
    grant_type:
      show_in_view:
        - id: unapproved_ai_applications
          is_default: true
        - id: ai_applications_with_risky_oauth_scopes
          is_default: true
        - id: newly_introduced_ai_users
          is_default: true
        - id: users_leaking_sensitive_data
          is_default: true
  table:
  unapproved_ai_applications:
  ai_applications_with_risky_oauth_scopes:
  newly_introduced_ai_users:
  users_leaking_sensitive_data:
pagination_query:
  query: ""
  dataSourceType: knowledgegraph
table_widget: []