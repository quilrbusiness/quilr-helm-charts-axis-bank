id: data-risks
name: Data Risks
type: screen
enabled: true
version: 1.0.14
icon_url: https://staticcontent1.blob.core.windows.net/finding-icons/posture-ai-usage.svg
table_query:
  id: 47d024f2-0adc-416d-9bc5-72eaa5503905
  name: Display Table Data
  queryString: null
  type: merge
  allowed_params: true
  allowed_body: true
  input_params:
    sample: value
  input_body: null
  dataSourceType: knowledgegraph
  sortOrder: desc
  sortColumn: lastseen
  limit: 10
  offset: 0
detailed_widget:
  - id: BID_200_detailed
    name: "User Copying Data Drilldown Table"
    input_params:
      appId: $appId
      accountId: $accountId
      behavior: $behavior
      group: AND toLower(group.displayName) IN [ x IN [$group] | toLower(x) ]
      department: AND toLower(department.name) IN [ x IN [$department] | toLower(x) ]
      appname: AND app.id_ IN [$appname]
      app_category: AND toLower(app_category.name) IN [ x IN [$app_category] | toLower(x) ]
      criticality: AND toLower(COALESCE(has.criticality, app.criticality)) IN [ x IN [$criticality] | toLower(x) ]
      approval_status: AND toLower(has.approval_status) IN [ x IN [$approval_status] | toLower(x) ]
    dataSourceType: "knowledgegraph"
    enabled: true
    allowed_params: true
    sortOrder: ""
    sortColumn: ""
    position: null
    template: null
    className: null
    multi_value_params:
      - id: appId
        delimiter: ","
      - id: group
        delimiter: ","
      - id: department
        delimiter: ","
      - id: appname
        delimiter: ","
      - id: app_category
        delimiter: ","
      - id: criticality
        delimiter: ","
      - id: approval_status
        delimiter: ","
    query: "MATCH (app:APPLICATION)
            WHERE app.id_ IN [$appId]
            MATCH (account:ACCOUNT {id: $accountId, tenant: $tenant})-[:USING_APP]->(app)
            MATCH (email:EMAIL:PRIMARY)-[auth_type]->(account)
            MATCH (user:USER)-[:HAS_EMAIL]->(email) 
            MATCH (finding:FINDING)<-[:HAS_FINDING]-(account)
            MATCH (finding)<-[:EVALUATED_TO]-(rule:RULE)-[:BELONGS_TO]->(behavior:BEHAVIOR {id: $behavior})

            WITH app, account, COLLECT(DISTINCT auth_type) AS auth_types, email, user, finding, rule, 
            datetime.truncate('day', datetime() - duration('P1M')).epochMillis AS one_month_ago_epoch

            OPTIONAL MATCH (finding)-[:TRIGGERED]->(action:ACTION)
            OPTIONAL MATCH (action)-[:RESULTED_IN]-(outcome:OUTCOME)
            OPTIONAL MATCH (action)-[:HAS_INTERACTION]->(interaction:INTERACTION)

            WITH app, account, auth_types, email, user, rule, one_month_ago_epoch, 
            {actioned: COUNT(DISTINCT CASE WHEN action IS NOT NULL THEN finding.id END),
                pending: COUNT(DISTINCT CASE WHEN action IS NULL THEN finding.id END)} AS actionStatus, 
            COUNT(DISTINCT finding.id) AS findingCount,
            COLLECT({
                 findingId: finding.id,
                 rule: rule.name, 
                 action: action.name,
                 outcomeDesc: outcome.description,
                 actionDesc: action.description,
                 interaction: CASE WHEN interaction IS NOT NULL THEN true ELSE false END
            }) AS findingData

            WITH app, account, auth_types, email, user, one_month_ago_epoch, findingData, actionStatus, 
                rule, findingCount, 
                ANY(data IN findingData WHERE data.interaction IS NOT NULL AND data.interaction) AS interactionsExist,
                apoc.map.fromPairs(apoc.coll.flatten(COLLECT(DISTINCT [
                   data IN findingData | [data.action, COALESCE(data.outcomeDesc, data.actionDesc)]
               ]))) AS actionCurrentState

            WITH app, account, auth_types, email, user, actionCurrentState, actionStatus, 
                interactionsExist, findingCount, rule, 
                one_month_ago_epoch, 
                apoc.map.fromPairs(
                    CASE 
                        WHEN interactionsExist IS NOT NULL AND interactionsExist 
                        THEN [data IN findingData WHERE data.interaction IS NOT NULL AND data.interaction | [data.rule, true]]
                        ELSE []
                    END
                ) AS ruleInteractionMap

            OPTIONAL MATCH (app)-[has:HAS_APP_SETTINGS]-(tenant:TENANT {id: $tenant})
            OPTIONAL MATCH (user)-[:HAS_DEPARTMENT]->(department:DEPARTMENT)
            OPTIONAL MATCH (user)-[:BELONGS_TO]->(group:GROUP {userDefined: true})
            OPTIONAL MATCH (app)-[:HAS_APP_CATEGORY]->(app_category:APP_CATEGORY)

            WITH app, account, auth_types, email, user, actionCurrentState, actionStatus, 
                interactionsExist, 
                ruleInteractionMap, findingCount, 
                one_month_ago_epoch, rule, 
                has, department, group, app_category,
                apoc.coll.min([auth in auth_types | auth.creationTime]) AS firstAccessed,
                apoc.coll.max([auth in auth_types | auth.last_access_time]) AS lastAccessed
                
            WHERE app.name IS NOT NULL AND toLower(email.id) =~ toLower('.*{searchText}.*')
            {placeholder}
            
            RETURN DISTINCT
                email.id AS userMail,
                user.displayName AS userName,
                account.id AS accountId,
                COALESCE(app.name, app.domain, app.id) AS appName,
                user.profilePicUrl AS userProfilePicUrl,
                COLLECT(DISTINCT department.name) AS departments,
                COLLECT(DISTINCT group.displayName) AS groups,
                app.logoUrl AS appLogoUrl,
                COLLECT(DISTINCT app_category.name) AS appCategories,
                has.approval_status AS appStatus,
                actionStatus, 
                MIN(CASE WHEN account.creationTime = '-' THEN NULL ELSE account.creationTime END) AS firstAccessTime,
                lastAccessed AS lastAccessTime,
                findingCount,
                apoc.map.fromPairs(COLLECT(DISTINCT
                    [rule.name, actionCurrentState]
                )) AS actionCurrentState,
                interactionsExist,
                ruleInteractionMap, 
                firstAccessed < one_month_ago_epoch  AS newlyDiscovered
            ORDER BY lastAccessed DESC"
    pagination_query: "
            MATCH (app:APPLICATION)
            WHERE app.id_ IN [$appId]
            MATCH (account:ACCOUNT {id: $accountId, subscriber: $subscriber, tenant: $tenant})-[:USING_APP]->(app)
            MATCH (email:EMAIL:PRIMARY)-[auth_type]->(account)
            MATCH (user:USER)-[:HAS_EMAIL]->(email) 
            MATCH (finding:FINDING)<-[:HAS_FINDING]-(account)
            MATCH (finding)<-[:EVALUATED_TO]-(rule:RULE)-[:BELONGS_TO]->(behavior:BEHAVIOR {id: $behavior})

            WITH app, account, COLLECT(DISTINCT auth_type) AS auth_types, email, user, finding, rule, 
            datetime.truncate('day', datetime() - duration('P1M')).epochMillis AS one_month_ago_epoch

            OPTIONAL MATCH (finding)-[:TRIGGERED]->(action:ACTION)
            OPTIONAL MATCH (action)-[:RESULTED_IN]-(outcome:OUTCOME)
            OPTIONAL MATCH (action)-[:HAS_INTERACTION]->(interaction:INTERACTION)

            WITH app, account, auth_types, email, user, rule, one_month_ago_epoch, 
            {actioned: COUNT(DISTINCT CASE WHEN action IS NOT NULL THEN finding.id END),
                pending: COUNT(DISTINCT CASE WHEN action IS NULL THEN finding.id END)} AS actionStatus, 
            COUNT(DISTINCT finding.id) AS findingCount,
            COLLECT({
                 findingId: finding.id,
                 rule: rule.name, 
                 action: action.name,
                 outcomeDesc: outcome.description,
                 actionDesc: action.description,
                 interaction: CASE WHEN interaction IS NOT NULL THEN true ELSE false END
            }) AS findingData

            WITH app, account, auth_types, email, user, one_month_ago_epoch, findingData, actionStatus, 
                rule, findingCount, 
                ANY(data IN findingData WHERE data.interaction IS NOT NULL AND data.interaction) AS interactionsExist,
                apoc.map.fromPairs(apoc.coll.flatten(COLLECT(DISTINCT [
                   data IN findingData | [data.action, COALESCE(data.outcomeDesc, data.actionDesc)]
               ]))) AS actionCurrentState

            WITH app, account, auth_types, email, user, actionCurrentState, actionStatus, 
                interactionsExist, findingCount, rule, 
                one_month_ago_epoch, 
                apoc.map.fromPairs(
                    CASE 
                        WHEN interactionsExist IS NOT NULL AND interactionsExist 
                        THEN [data IN findingData WHERE data.interaction IS NOT NULL AND data.interaction | [data.rule, true]]
                        ELSE []
                    END
                ) AS ruleInteractionMap

            OPTIONAL MATCH (app)-[has:HAS_APP_SETTINGS]-(tenant:TENANT {id: $tenant})
            OPTIONAL MATCH (user)-[:HAS_DEPARTMENT]->(department:DEPARTMENT)
            OPTIONAL MATCH (user)-[:BELONGS_TO]->(group:GROUP {userDefined: true})
            OPTIONAL MATCH (app)-[:HAS_APP_CATEGORY]->(app_category:APP_CATEGORY)

            WITH app, account, auth_types, email, user, actionCurrentState, actionStatus, 
                interactionsExist, 
                ruleInteractionMap, findingCount, 
                one_month_ago_epoch, rule, 
                has, department, group, app_category,
                apoc.coll.min([auth in auth_types | auth.creationTime]) AS firstAccessed,
                apoc.coll.max([auth in auth_types | auth.last_access_time]) AS lastAccessed
            
            WHERE app.name IS NOT NULL AND toLower(email.id) =~ toLower('.*{searchText}.*')
            {placeholder}
                      
            RETURN COUNT(DISTINCT account.id) AS totalCount"
  - id: BID_201_detailed
    name: "User Pasting Data Drilldown Table"
    input_params:
      appId: $appId
      accountId: $accountId
      behavior: $behavior
      group: AND toLower(group.displayName) IN [ x IN [$group] | toLower(x) ]
      department: AND toLower(department.name) IN [ x IN [$department] | toLower(x) ]
      appname: AND app.id_ IN [$appname]
      app_category: AND toLower(app_category.name) IN [ x IN [$app_category] | toLower(x) ]
      criticality: AND toLower(COALESCE(has.criticality, app.criticality)) IN [ x IN [$criticality] | toLower(x) ]
      approval_status: AND toLower(has.approval_status) IN [ x IN [$approval_status] | toLower(x) ]
    dataSourceType: "knowledgegraph"
    enabled: true
    allowed_params: true
    sortOrder: ""
    sortColumn: ""
    position: null
    template: null
    className: null
    multi_value_params:
      - id: appId
        delimiter: ","
      - id: group
        delimiter: ","
      - id: department
        delimiter: ","
      - id: appname
        delimiter: ","
      - id: app_category
        delimiter: ","
      - id: criticality
        delimiter: ","
      - id: approval_status
        delimiter: ","
    query: "MATCH (app:APPLICATION)
            WHERE app.id_ IN [$appId]
            MATCH (account:ACCOUNT {id: $accountId, tenant: $tenant})-[:USING_APP]->(app)
            MATCH (email:EMAIL:PRIMARY)-[auth_type]->(account)
            MATCH (user:USER)-[:HAS_EMAIL]->(email) 
            MATCH (finding:FINDING)<-[:HAS_FINDING]-(account)
            MATCH (finding)<-[:EVALUATED_TO]-(rule:RULE)-[:BELONGS_TO]->(behavior:BEHAVIOR {id: $behavior})

            WITH app, account, COLLECT(DISTINCT auth_type) AS auth_types, email, user, finding, rule, 
            datetime.truncate('day', datetime() - duration('P1M')).epochMillis AS one_month_ago_epoch

            OPTIONAL MATCH (finding)-[:TRIGGERED]->(action:ACTION)
            OPTIONAL MATCH (action)-[:RESULTED_IN]-(outcome:OUTCOME)
            OPTIONAL MATCH (action)-[:HAS_INTERACTION]->(interaction:INTERACTION)

            WITH app, account, auth_types, email, user, rule, one_month_ago_epoch, 
            {actioned: COUNT(DISTINCT CASE WHEN action IS NOT NULL THEN finding.id END),
                pending: COUNT(DISTINCT CASE WHEN action IS NULL THEN finding.id END)} AS actionStatus, 
            COUNT(DISTINCT finding.id) AS findingCount,
            COLLECT({
                 findingId: finding.id,
                 rule: rule.name, 
                 action: action.name,
                 outcomeDesc: outcome.description,
                 actionDesc: action.description,
                 interaction: CASE WHEN interaction IS NOT NULL THEN true ELSE false END
            }) AS findingData

            WITH app, account, auth_types, email, user, one_month_ago_epoch, findingData, actionStatus, 
                rule, findingCount, 
                ANY(data IN findingData WHERE data.interaction IS NOT NULL AND data.interaction) AS interactionsExist,
                apoc.map.fromPairs(apoc.coll.flatten(COLLECT(DISTINCT [
                   data IN findingData | [data.action, COALESCE(data.outcomeDesc, data.actionDesc)]
               ]))) AS actionCurrentState

            WITH app, account, auth_types, email, user, actionCurrentState, actionStatus, 
                interactionsExist, findingCount, rule, 
                one_month_ago_epoch, 
                apoc.map.fromPairs(
                    CASE 
                        WHEN interactionsExist IS NOT NULL AND interactionsExist 
                        THEN [data IN findingData WHERE data.interaction IS NOT NULL AND data.interaction | [data.rule, true]]
                        ELSE []
                    END
                ) AS ruleInteractionMap

            OPTIONAL MATCH (app)-[has:HAS_APP_SETTINGS]-(tenant:TENANT {id: $tenant})
            OPTIONAL MATCH (user)-[:HAS_DEPARTMENT]->(department:DEPARTMENT)
            OPTIONAL MATCH (user)-[:BELONGS_TO]->(group:GROUP {userDefined: true})
            OPTIONAL MATCH (app)-[:HAS_APP_CATEGORY]->(app_category:APP_CATEGORY)

            WITH app, account, auth_types, email, user, actionCurrentState, actionStatus, 
                interactionsExist, 
                ruleInteractionMap, findingCount, 
                one_month_ago_epoch, rule, 
                has, department, group, app_category,
                apoc.coll.min([auth in auth_types | auth.creationTime]) AS firstAccessed,
                apoc.coll.max([auth in auth_types | auth.last_access_time]) AS lastAccessed
                
            WHERE app.name IS NOT NULL AND toLower(email.id) =~ toLower('.*{searchText}.*')
            {placeholder}
            
            RETURN DISTINCT
                email.id AS userMail,
                user.displayName AS userName,
                account.id AS accountId,
                COALESCE(app.name, app.domain, app.id) AS appName,
                user.profilePicUrl AS userProfilePicUrl,
                COLLECT(DISTINCT department.name) AS departments,
                COLLECT(DISTINCT group.displayName) AS groups,
                app.logoUrl AS appLogoUrl,
                COLLECT(DISTINCT app_category.name) AS appCategories,
                has.approval_status AS appStatus,
                actionStatus, 
                MIN(CASE WHEN account.creationTime = '-' THEN NULL ELSE account.creationTime END) AS firstAccessTime,
                lastAccessed AS lastAccessTime,
                findingCount,
                apoc.map.fromPairs(COLLECT(DISTINCT
                    [rule.name, actionCurrentState]
                )) AS actionCurrentState,
                interactionsExist,
                ruleInteractionMap, 
                firstAccessed < one_month_ago_epoch  AS newlyDiscovered
            ORDER BY lastAccessed DESC"
    pagination_query: "
            MATCH (app:APPLICATION)
            WHERE app.id_ IN [$appId]
            MATCH (account:ACCOUNT {id: $accountId, subscriber: $subscriber, tenant: $tenant})-[:USING_APP]->(app)
            MATCH (email:EMAIL:PRIMARY)-[auth_type]->(account)
            MATCH (user:USER)-[:HAS_EMAIL]->(email) 
            MATCH (finding:FINDING)<-[:HAS_FINDING]-(account)
            MATCH (finding)<-[:EVALUATED_TO]-(rule:RULE)-[:BELONGS_TO]->(behavior:BEHAVIOR {id: $behavior})

            WITH app, account, COLLECT(DISTINCT auth_type) AS auth_types, email, user, finding, rule, 
            datetime.truncate('day', datetime() - duration('P1M')).epochMillis AS one_month_ago_epoch

            OPTIONAL MATCH (finding)-[:TRIGGERED]->(action:ACTION)
            OPTIONAL MATCH (action)-[:RESULTED_IN]-(outcome:OUTCOME)
            OPTIONAL MATCH (action)-[:HAS_INTERACTION]->(interaction:INTERACTION)

            WITH app, account, auth_types, email, user, rule, one_month_ago_epoch, 
            {actioned: COUNT(DISTINCT CASE WHEN action IS NOT NULL THEN finding.id END),
                pending: COUNT(DISTINCT CASE WHEN action IS NULL THEN finding.id END)} AS actionStatus, 
            COUNT(DISTINCT finding.id) AS findingCount,
            COLLECT({
                 findingId: finding.id,
                 rule: rule.name, 
                 action: action.name,
                 outcomeDesc: outcome.description,
                 actionDesc: action.description,
                 interaction: CASE WHEN interaction IS NOT NULL THEN true ELSE false END
            }) AS findingData

            WITH app, account, auth_types, email, user, one_month_ago_epoch, findingData, actionStatus, 
                rule, findingCount, 
                ANY(data IN findingData WHERE data.interaction IS NOT NULL AND data.interaction) AS interactionsExist,
                apoc.map.fromPairs(apoc.coll.flatten(COLLECT(DISTINCT [
                   data IN findingData | [data.action, COALESCE(data.outcomeDesc, data.actionDesc)]
               ]))) AS actionCurrentState

            WITH app, account, auth_types, email, user, actionCurrentState, actionStatus, 
                interactionsExist, findingCount, rule, 
                one_month_ago_epoch, 
                apoc.map.fromPairs(
                    CASE 
                        WHEN interactionsExist IS NOT NULL AND interactionsExist 
                        THEN [data IN findingData WHERE data.interaction IS NOT NULL AND data.interaction | [data.rule, true]]
                        ELSE []
                    END
                ) AS ruleInteractionMap

            OPTIONAL MATCH (app)-[has:HAS_APP_SETTINGS]-(tenant:TENANT {id: $tenant})
            OPTIONAL MATCH (user)-[:HAS_DEPARTMENT]->(department:DEPARTMENT)
            OPTIONAL MATCH (user)-[:BELONGS_TO]->(group:GROUP {userDefined: true})
            OPTIONAL MATCH (app)-[:HAS_APP_CATEGORY]->(app_category:APP_CATEGORY)

            WITH app, account, auth_types, email, user, actionCurrentState, actionStatus, 
                interactionsExist, 
                ruleInteractionMap, findingCount, 
                one_month_ago_epoch, rule, 
                has, department, group, app_category,
                apoc.coll.min([auth in auth_types | auth.creationTime]) AS firstAccessed,
                apoc.coll.max([auth in auth_types | auth.last_access_time]) AS lastAccessed
            
            WHERE app.name IS NOT NULL AND toLower(email.id) =~ toLower('.*{searchText}.*')
            {placeholder}
                      
            RETURN COUNT(DISTINCT account.id) AS totalCount"
  - id: interactions_metadata
    query: "MATCH (account:ACCOUNT {id: $accountId, tenant: $tenant})
            MATCH (email:EMAIL)-[auth_type]->(account)
            MATCH (user:USER)-[:HAS_EMAIL]->(email) 
            MATCH (finding:FINDING)<-[:HAS_FINDING]-(account)
            MATCH (finding)<-[:EVALUATED_TO]-(rule:RULE)-[:BELONGS_TO]->(behavior:BEHAVIOR {id: $behavior})

            OPTIONAL MATCH (finding)-[:TRIGGERED]->(action:ACTION)-[:HAS_INTERACTION]->(interaction:INTERACTION)
            WHERE interaction IS NOT NULL
            {placeholder}
            
            WITH rule, interaction, action
            WHERE interaction IS NOT NULL 
              AND action IS NOT NULL
              AND interaction.messageTime IS NOT NULL
              AND btrim(COALESCE(interaction.message, apoc.text.join([interaction.header, interaction.title, interaction.description], ' '))) <> ''
              AND btrim(COALESCE(interaction.message, apoc.text.join([interaction.header, interaction.title, interaction.description], ' '))) IS NOT NULL
            
            RETURN DISTINCT 
                rule.name AS ruleName,
                btrim(COALESCE(interaction.message, apoc.text.join([interaction.header, interaction.title, interaction.description], ' '))) AS message,
                interaction.messageTime AS messageTime,
                interaction.initiator AS initiator, 
                action.name AS action, 
                interaction.channel AS channel, 
                interaction.mode AS mode
            ORDER BY interaction.messageTime ASC"
    input_params:
      behavior: $behavior
      accountId: $accountId
      ruleName: AND tolower(rule.name) = tolower($ruleName)
    dataSourceType: "knowledgegraph"
    enabled: true
    allowed_params: true
    sortOrder: ""
    sortColumn: ""
    requestType: POST
    name: "Interaction Metadata"
    position: null
    template: null
    className: null
    multi_value_params: [ ]
    pagination_query: "MATCH (account:ACCOUNT {id: $accountId, subscriber: $subscriber, tenant: $tenant})
                       MATCH (email:EMAIL)-[auth_type]->(account)
                       MATCH (user:USER)-[:HAS_EMAIL]->(email) 
                       MATCH (finding:FINDING)<-[:HAS_FINDING]-(account)
                       MATCH (finding)<-[:EVALUATED_TO]-(rule:RULE)-[:BELONGS_TO]->(behavior:BEHAVIOR {id: $behavior})

                       OPTIONAL MATCH (finding)-[:TRIGGERED]->(action:ACTION)-[:HAS_INTERACTION]->(interaction:INTERACTION)
                       WHERE interaction IS NOT NULL
                       {placeholder}
                       
                       WITH rule, interaction, action
                       WHERE interaction IS NOT NULL 
                         AND action IS NOT NULL
                         AND interaction.messageTime IS NOT NULL
                         AND btrim(COALESCE(interaction.message, apoc.text.join([interaction.header, interaction.title, interaction.description], ' '))) <> ''
                         AND btrim(COALESCE(interaction.message, apoc.text.join([interaction.header, interaction.title, interaction.description], ' '))) IS NOT NULL
                       
                       WITH DISTINCT 
                           rule.name AS ruleName,
                           btrim(COALESCE(interaction.message, apoc.text.join([interaction.header, interaction.title, interaction.description], ' '))) AS message,
                           interaction.messageTime AS messageTime,
                           interaction.initiator AS initiator, 
                           action.name AS action, 
                           interaction.channel AS channel, 
                           interaction.mode AS mode

                       RETURN COUNT(*) AS totalCount"
view_by:
  - id: BID_200
    name: "User Copying Data"
    type: widget
    active: true
    defaultValue: null
    queryFilters: []
    multi_value_params:
      - id: approval_status
        delimiter: ","
      - id: risk_level
        delimiter: ","
    className: ""
    query: "MATCH (finding:FINDING {tenant: $tenant})<-[:EVALUATED_TO]-(rule:RULE)-[:BELONGS_TO]->(behavior:BEHAVIOR {id: $behavior})
            MATCH (u:USER {tenant: $tenant})-[:HAS_EMAIL]->(email:EMAIL)-[AUTH_TYPE]->(account:ACCOUNT)-[:HAS_FINDING]->(finding)
            MATCH (account)-[:USING_APP]->(app:APPLICATION)
            MATCH (account)-[:INITIATED]->(be:BROWSER_EVENT)
            WHERE toLower(be.event_name) ENDS WITH 'copy'
            OPTIONAL MATCH (app)-[:HAS_APP_CATEGORY]->(category:APP_CATEGORY)
            
            OPTIONAL MATCH (app)-[:HAS_ADMIN]->(owner:ACCOUNT {tenant: $tenant})
            OPTIONAL MATCH (finding)-[:TRIGGERED]->(action:ACTION)
            OPTIONAL MATCH (action)-[:RESULTED_IN]->(outcome:OUTCOME)
            OPTIONAL MATCH (t:TENANT {id: $tenant})-[hs:HAS_APP_SETTINGS]->(app)
            
            WITH app, owner, u, email, account, be, AUTH_TYPE, hs, category, finding, action,
            COALESCE(action.name, '-') AS actionName, COUNT(DISTINCT action.id) AS actionCount,
            CASE WHEN action IS NOT NULL AND outcome IS NULL THEN 'User Not Responded'
                WHEN outcome IS NOT NULL THEN COALESCE(outcome.value, outcome.message, '-')
            END as outcomeValue,
            COUNT(DISTINCT action.id) as outcomeCount
            
            WITH app, owner, u, email, account, be, AUTH_TYPE, hs, category, finding, action,
            actionName, actionCount, apoc.map.fromPairs(COLLECT([outcomeValue, outcomeCount])) as outcomeMap
            
            WITH 
                app, hs, account.id as accountId, COALESCE(CASE WHEN account.email <> '-' THEN account.email END, email.id) as email, u.profilePicUrl as profilePic,
                COUNT(DISTINCT finding.id) AS totalFindings,
                COLLECT(DISTINCT owner.email) AS appAdmin, 
                COLLECT(DISTINCT {name: category.name, priority: category.priority}) AS categories, 
                MIN(CASE WHEN account.creationTime = '-' THEN NULL ELSE account.creationTime END) AS firstAccessTime,
                MAX(COALESCE(AUTH_TYPE.last_access_time, 0)) AS lastAccessTime,  
                COALESCE(hs.approval_status, 'NEEDS REVIEW') AS status, 
                app.logoUrl AS logo, 
                COUNT(DISTINCT CASE WHEN finding IS NOT NULL THEN account.id END) AS accountsWithFindings,
                SUM(be.occurrences) AS eventOccurrences,
                apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, actionCount] END)) AS actionResults,
                apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, outcomeMap] END)) AS actionOutcomes,
                COUNT(DISTINCT CASE WHEN action IS NOT NULL THEN account.id END) AS accountsActioned,
                CASE 
                    WHEN app.totalScore IN [1, 2] THEN 'Very High'
                    WHEN app.totalScore IN [3, 4] THEN 'High'
                    WHEN app.totalScore IN [5, 6] THEN 'Moderate'
                    WHEN app.totalScore IN [7, 8] THEN 'Low'
                    WHEN app.totalScore IN [9, 10] THEN 'Very Low'
                    ELSE 'Unknown'
                END AS appRiskLevel
            
            WITH app, hs, accountId, email, profilePic, totalFindings, appAdmin, appRiskLevel, categories, lastAccessTime, firstAccessTime, 
                accountsWithFindings, eventOccurrences,
                status, logo, 
                {
                    actioned: accountsActioned,
                    pending: accountsWithFindings - accountsActioned
                } AS reviewStatus,
                datetime.truncate('day', datetime() - duration('P1M')).epochMillis AS one_month_ago_epoch, actionResults, actionOutcomes
            
            WHERE toLower(COALESCE(app.name, app.domain)) CONTAINS toLower('{searchText}')
            {placeholder}
            
            RETURN DISTINCT
                COALESCE(app.id_, app.internalId) AS id, 
                COALESCE(app.name, app.domain, app.id) AS app, 
                accountId,
                email,
                profilePic,
                totalFindings,
                appRiskLevel,
                COALESCE(app.criticality, 'Not Set') AS criticality, 
                status, 
                NOT status in ['APPROVED', 'UNAPPROVED'] AND COALESCE(firstAccessTime > one_month_ago_epoch, true) AS newlyDiscovered,
                logo, 
                [cat IN categories WHERE cat.priority = 2 | cat.name] AS highPriorityCategories, 
                accountsWithFindings, 
                eventOccurrences,
                lastAccessTime, 
                firstAccessTime,
                reviewStatus,
                actionResults,
                actionOutcomes
            ORDER BY 
            CASE
                WHEN newlyDiscovered = true THEN 1
                ELSE 0
            END DESC,
            lastAccessTime DESC"
    allowed_params: true
    input_params:
      behavior: $behavior
      risk_level: AND toLower(appRiskLevel) IN [ x IN [$risk_level] | toLower(x) ]
      criticality: AND toLower(COALESCE(hs.criticality, app.criticality)) = toLower($criticality)
      approval_status: AND toLower(status) IN [ x IN [$approval_status] | toLower(x) ]
      technical_owner: AND appAdmin = $technical_owner
      newly_discovered: AND NOT status in ['APPROVED', 'UNAPPROVED'] AND COALESCE(firstAccessTime > one_month_ago_epoch, true) = $newly_discovered
      action_status: AND reviewStatus[toLower($action_status)] > 0
    dataSourceType: "knowledgegraph"
    pagination_query: "
          MATCH (finding:FINDING {tenant: $tenant})<-[:EVALUATED_TO]-(rule:RULE)-[:BELONGS_TO]->(behavior:BEHAVIOR {id: $behavior})
            MATCH (u:USER {tenant: $tenant})-[:HAS_EMAIL]->(email:EMAIL)-[AUTH_TYPE]->(account:ACCOUNT)-[:HAS_FINDING]->(finding)
            MATCH (account)-[:USING_APP]->(app:APPLICATION)
            MATCH (account)-[:INITIATED]->(be:BROWSER_EVENT)
            WHERE toLower(be.event_name) ENDS WITH 'copy'
            OPTIONAL MATCH (app)-[:HAS_APP_CATEGORY]->(category:APP_CATEGORY)
            
            OPTIONAL MATCH (app)-[:HAS_ADMIN]->(owner:ACCOUNT {tenant: $tenant})
            OPTIONAL MATCH (finding)-[:TRIGGERED]->(action:ACTION)
            OPTIONAL MATCH (action)-[:RESULTED_IN]->(outcome:OUTCOME)
            OPTIONAL MATCH (t:TENANT {id: $tenant})-[hs:HAS_APP_SETTINGS]->(app)
            
            WITH app, owner, u, email, account, be, AUTH_TYPE, hs, category, finding, action,
            COALESCE(action.name, '-') AS actionName, COUNT(DISTINCT action.id) AS actionCount,
            CASE WHEN action IS NOT NULL AND outcome IS NULL THEN 'User Not Responded'
                WHEN outcome IS NOT NULL THEN COALESCE(outcome.value, outcome.message, '-')
            END as outcomeValue,
            COUNT(DISTINCT action.id) as outcomeCount
            
            WITH app, owner, u, email, account, be, AUTH_TYPE, hs, category, finding, action,
            actionName, actionCount, apoc.map.fromPairs(COLLECT([outcomeValue, outcomeCount])) as outcomeMap
            
            WITH 
                app, hs, account.id as accountId, COALESCE(CASE WHEN account.email <> '-' THEN account.email END, email.id) as email, u.profilePicUrl as profilePic,
                COUNT(DISTINCT finding.id) AS totalFindings,
                COLLECT(DISTINCT owner.email) AS appAdmin, 
                COLLECT(DISTINCT {name: category.name, priority: category.priority}) AS categories, 
                MIN(CASE WHEN account.creationTime = '-' THEN NULL ELSE account.creationTime END) AS firstAccessTime,
                MAX(COALESCE(AUTH_TYPE.last_access_time, 0)) AS lastAccessTime,  
                COALESCE(hs.approval_status, 'NEEDS REVIEW') AS status, 
                app.logoUrl AS logo, 
                COUNT(DISTINCT CASE WHEN finding IS NOT NULL THEN account.id END) AS accountsWithFindings,
                SUM(be.occurrences) AS eventOccurrences,
                apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, actionCount] END)) AS actionResults,
                apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, outcomeMap] END)) AS actionOutcomes,
                COUNT(DISTINCT CASE WHEN action IS NOT NULL THEN account.id END) AS accountsActioned,
                CASE 
                    WHEN app.totalScore IN [1, 2] THEN 'Very High'
                    WHEN app.totalScore IN [3, 4] THEN 'High'
                    WHEN app.totalScore IN [5, 6] THEN 'Moderate'
                    WHEN app.totalScore IN [7, 8] THEN 'Low'
                    WHEN app.totalScore IN [9, 10] THEN 'Very Low'
                    ELSE 'Unknown'
                END AS appRiskLevel
            
            WITH app, hs, accountId, email, profilePic, totalFindings, appAdmin, appRiskLevel, categories, lastAccessTime, firstAccessTime, 
                accountsWithFindings, eventOccurrences,
                status, logo, 
                {
                    actioned: accountsActioned,
                    pending: accountsWithFindings - accountsActioned
                } AS reviewStatus,
                datetime.truncate('day', datetime() - duration('P1M')).epochMillis AS one_month_ago_epoch, actionResults, actionOutcomes
            
            WHERE toLower(COALESCE(app.name, app.domain)) CONTAINS toLower('{searchText}')
            {placeholder}
            
            WITH DISTINCT
                COALESCE(app.id_, app.internalId) AS id, 
                COALESCE(app.name, app.domain, app.id) AS app, 
                accountId,
                email,
                profilePic,
                totalFindings,
                appRiskLevel,
                COALESCE(app.criticality, 'Not Set') AS criticality, 
                status, 
                NOT status in ['APPROVED', 'UNAPPROVED'] AND COALESCE(firstAccessTime > one_month_ago_epoch, true) AS newlyDiscovered,
                logo, 
                [cat IN categories WHERE cat.priority = 2 | cat.name] AS highPriorityCategories, 
                accountsWithFindings, 
                eventOccurrences,
                lastAccessTime, 
                firstAccessTime,
                reviewStatus,
                actionResults,
                actionOutcomes
            
                RETURN COUNT(*) AS totalCount"
  - id: BID_201
    name: "User Pasting Data"
    type: widget
    active: true
    defaultValue: null
    queryFilters: []
    className: ""
    multi_value_params:
      - id: approval_status
        delimiter: ","
      - id: risk_level
        delimiter: ","
    query: "MATCH (finding:FINDING {tenant: $tenant})<-[:EVALUATED_TO]-(rule:RULE)-[:BELONGS_TO]->(behavior:BEHAVIOR {id: $behavior})
            MATCH (u:USER {tenant: $tenant})-[:HAS_EMAIL]->(email:EMAIL)-[AUTH_TYPE]->(account:ACCOUNT)-[:HAS_FINDING]->(finding)
            MATCH (account)-[:USING_APP]->(app:APPLICATION)
            MATCH (account)-[:INITIATED]->(be:BROWSER_EVENT)
            WHERE toLower(be.event_name) ENDS WITH 'paste'
            OPTIONAL MATCH (app)-[:HAS_APP_CATEGORY]->(category:APP_CATEGORY)
            
            OPTIONAL MATCH (app)-[:HAS_ADMIN]->(owner:ACCOUNT {tenant: $tenant})
            OPTIONAL MATCH (finding)-[:TRIGGERED]->(action:ACTION)
            OPTIONAL MATCH (action)-[:RESULTED_IN]->(outcome:OUTCOME)
            OPTIONAL MATCH (t:TENANT {id: $tenant})-[hs:HAS_APP_SETTINGS]->(app)
            
            WITH app, owner, u, email, account, be, AUTH_TYPE, hs, category, finding, action,
            COALESCE(action.name, '-') AS actionName, COUNT(DISTINCT action.id) AS actionCount,
            CASE WHEN action IS NOT NULL AND outcome IS NULL THEN 'User Not Responded'
                WHEN outcome IS NOT NULL THEN COALESCE(outcome.value, outcome.message, '-')
            END as outcomeValue,
            COUNT(DISTINCT action.id) as outcomeCount
            
            WITH app, owner, u, email, account, be, AUTH_TYPE, hs, category, finding, action,
            actionName, actionCount, apoc.map.fromPairs(COLLECT([outcomeValue, outcomeCount])) as outcomeMap
            
            WITH 
                app, hs, account.id as accountId, COALESCE(CASE WHEN account.email <> '-' THEN account.email END, email.id) as email, u.profilePicUrl as profilePic,
                COUNT(DISTINCT finding.id) AS totalFindings,
                COLLECT(DISTINCT owner.email) AS appAdmin, 
                COLLECT(DISTINCT {name: category.name, priority: category.priority}) AS categories, 
                MIN(CASE WHEN account.creationTime = '-' THEN NULL ELSE account.creationTime END) AS firstAccessTime,
                MAX(COALESCE(AUTH_TYPE.last_access_time, 0)) AS lastAccessTime,  
                COALESCE(hs.approval_status, 'NEEDS REVIEW') AS status, 
                app.logoUrl AS logo, 
                COUNT(DISTINCT CASE WHEN finding IS NOT NULL THEN account.id END) AS accountsWithFindings,
                SUM(be.occurrences) AS eventOccurrences,
                apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, actionCount] END)) AS actionResults,
                apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, outcomeMap] END)) AS actionOutcomes,
                COUNT(DISTINCT CASE WHEN action IS NOT NULL THEN account.id END) AS accountsActioned,
                CASE 
                    WHEN app.totalScore IN [1, 2] THEN 'Very High'
                    WHEN app.totalScore IN [3, 4] THEN 'High'
                    WHEN app.totalScore IN [5, 6] THEN 'Moderate'
                    WHEN app.totalScore IN [7, 8] THEN 'Low'
                    WHEN app.totalScore IN [9, 10] THEN 'Very Low'
                    ELSE 'Unknown'
                END AS appRiskLevel
            
            WITH app, hs, accountId, email, profilePic, totalFindings, appAdmin, appRiskLevel, categories, lastAccessTime, firstAccessTime, 
                accountsWithFindings, eventOccurrences,
                status, logo, 
                {
                    actioned: accountsActioned,
                    pending: accountsWithFindings - accountsActioned
                } AS reviewStatus,
                datetime.truncate('day', datetime() - duration('P1M')).epochMillis AS one_month_ago_epoch, actionResults, actionOutcomes
            
            WHERE toLower(COALESCE(app.name, app.domain)) CONTAINS toLower('{searchText}')
            {placeholder}
            
            RETURN DISTINCT
                COALESCE(app.id_, app.internalId) AS id, 
                COALESCE(app.name, app.domain, app.id) AS app, 
                accountId,
                email,
                profilePic,
                totalFindings,
                appRiskLevel,
                COALESCE(app.criticality, 'Not Set') AS criticality, 
                status, 
                NOT status in ['APPROVED', 'UNAPPROVED'] AND COALESCE(firstAccessTime > one_month_ago_epoch, true) AS newlyDiscovered,
                logo, 
                [cat IN categories WHERE cat.priority = 2 | cat.name] AS highPriorityCategories, 
                accountsWithFindings, 
                eventOccurrences,
                lastAccessTime, 
                firstAccessTime,
                reviewStatus,
                actionResults,
                actionOutcomes
            ORDER BY 
            CASE
                WHEN newlyDiscovered = true THEN 1
                ELSE 0
            END DESC,
            lastAccessTime DESC"
    allowed_params: true
    input_params:
      behavior: $behavior
      risk_level: AND toLower(appRiskLevel) IN [ x IN [$risk_level] | toLower(x) ]
      criticality: AND toLower(COALESCE(hs.criticality, app.criticality)) = toLower($criticality)
      approval_status: AND toLower(status) IN [ x IN [$approval_status] | toLower(x) ]
      technical_owner: AND appAdmin = $technical_owner
      newly_discovered: AND NOT status in ['APPROVED', 'UNAPPROVED'] AND COALESCE(firstAccessTime > one_month_ago_epoch, true) = $newly_discovered
      action_status: AND reviewStatus[toLower($action_status)] > 0
    dataSourceType: "knowledgegraph"
    pagination_query: "
          MATCH (finding:FINDING {tenant: $tenant})<-[:EVALUATED_TO]-(rule:RULE)-[:BELONGS_TO]->(behavior:BEHAVIOR {id: $behavior})
            MATCH (u:USER {tenant: $tenant})-[:HAS_EMAIL]->(email:EMAIL)-[AUTH_TYPE]->(account:ACCOUNT)-[:HAS_FINDING]->(finding)
            MATCH (account)-[:USING_APP]->(app:APPLICATION)
            MATCH (account)-[:INITIATED]->(be:BROWSER_EVENT)
            WHERE toLower(be.event_name) ENDS WITH 'paste'
            OPTIONAL MATCH (app)-[:HAS_APP_CATEGORY]->(category:APP_CATEGORY)
            
            OPTIONAL MATCH (app)-[:HAS_ADMIN]->(owner:ACCOUNT {tenant: $tenant})
            OPTIONAL MATCH (finding)-[:TRIGGERED]->(action:ACTION)
            OPTIONAL MATCH (action)-[:RESULTED_IN]->(outcome:OUTCOME)
            OPTIONAL MATCH (t:TENANT {id: $tenant})-[hs:HAS_APP_SETTINGS]->(app)
            
            WITH app, owner, u, email, account, be, AUTH_TYPE, hs, category, finding, action,
            COALESCE(action.name, '-') AS actionName, COUNT(DISTINCT action.id) AS actionCount,
            CASE WHEN action IS NOT NULL AND outcome IS NULL THEN 'User Not Responded'
                WHEN outcome IS NOT NULL THEN COALESCE(outcome.value, outcome.message, '-')
            END as outcomeValue,
            COUNT(DISTINCT action.id) as outcomeCount
            
            WITH app, owner, u, email, account, be, AUTH_TYPE, hs, category, finding, action,
            actionName, actionCount, apoc.map.fromPairs(COLLECT([outcomeValue, outcomeCount])) as outcomeMap
            
            WITH 
                app, hs, account.id as accountId, COALESCE(CASE WHEN account.email <> '-' THEN account.email END, email.id) as email, u.profilePicUrl as profilePic,
                COUNT(DISTINCT finding.id) AS totalFindings,
                COLLECT(DISTINCT owner.email) AS appAdmin, 
                COLLECT(DISTINCT {name: category.name, priority: category.priority}) AS categories, 
                MIN(CASE WHEN account.creationTime = '-' THEN NULL ELSE account.creationTime END) AS firstAccessTime,
                MAX(COALESCE(AUTH_TYPE.last_access_time, 0)) AS lastAccessTime,  
                COALESCE(hs.approval_status, 'NEEDS REVIEW') AS status, 
                app.logoUrl AS logo, 
                COUNT(DISTINCT CASE WHEN finding IS NOT NULL THEN account.id END) AS accountsWithFindings,
                SUM(be.occurrences) AS eventOccurrences,
                apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, actionCount] END)) AS actionResults,
                apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, outcomeMap] END)) AS actionOutcomes,
                COUNT(DISTINCT CASE WHEN action IS NOT NULL THEN account.id END) AS accountsActioned,
                CASE 
                    WHEN app.totalScore IN [1, 2] THEN 'Very High'
                    WHEN app.totalScore IN [3, 4] THEN 'High'
                    WHEN app.totalScore IN [5, 6] THEN 'Moderate'
                    WHEN app.totalScore IN [7, 8] THEN 'Low'
                    WHEN app.totalScore IN [9, 10] THEN 'Very Low'
                    ELSE 'Unknown'
                END AS appRiskLevel
            
            WITH app, hs, accountId, email, profilePic, totalFindings, appAdmin, appRiskLevel, categories, lastAccessTime, firstAccessTime, 
                accountsWithFindings, eventOccurrences,
                status, logo, 
                {
                    actioned: accountsActioned,
                    pending: accountsWithFindings - accountsActioned
                } AS reviewStatus,
                datetime.truncate('day', datetime() - duration('P1M')).epochMillis AS one_month_ago_epoch, actionResults, actionOutcomes
            
            WHERE toLower(COALESCE(app.name, app.domain)) CONTAINS toLower('{searchText}')
            {placeholder}
            
            WITH DISTINCT
                COALESCE(app.id_, app.internalId) AS id, 
                COALESCE(app.name, app.domain, app.id) AS app, 
                accountId,
                email,
                profilePic,
                totalFindings,
                appRiskLevel,
                COALESCE(app.criticality, 'Not Set') AS criticality, 
                status, 
                NOT status in ['APPROVED', 'UNAPPROVED'] AND COALESCE(firstAccessTime > one_month_ago_epoch, true) AS newlyDiscovered,
                logo, 
                [cat IN categories WHERE cat.priority = 2 | cat.name] AS highPriorityCategories, 
                accountsWithFindings, 
                eventOccurrences,
                lastAccessTime, 
                firstAccessTime,
                reviewStatus,
                actionResults,
                actionOutcomes
            
                RETURN COUNT(*) AS totalCount"
table_filters:
  - id: risk_level
    name: Risk Level
    defaultValue:
    active: true
    view_by:
        - app
    optional: true
    defaultOptions:
        - 'Very High'
        - 'High'
        - 'Moderate'
        - 'Low'
        - 'Very Low'
    type: multiselect
    allowed_params: false
    dataSourceType: knowledgegraph
    input_params: null
    query: ""
  - id: criticality
    name: Criticality
    defaultValue:
    active: true
    view_by:
        - app
    optional: true
    defaultOptions:
        "Yes": "critical"
        "No": "not critical"
    type: single
    allowed_params: false
    dataSourceType: knowledgegraph
    input_params: null
    query: ""
  - id: approval_status
    name: Approval Status
    defaultValue:
    active: true
    view_by:
        - app
    optional: false
    defaultOptions:
        - "Approved"
        - "Unapproved"
        - "Needs Review"
        - "Tolerated"
    type: multiselect
    allowed_params: false
    dataSourceType: knowledgegraph
    input_params: null
    query: ""
  - id: technical_owner
    name: Technical Owner
    defaultValue:
    active: true
    view_by:
        - app
        - account
    optional: true
    defaultOptions: []
    type: singleselect
    allowed_params: false
    dataSourceType: knowledgegraph
    input_params:
        search: true
    query: "MATCH (app:APPLICATION)-[:HAS_ADMIN]->(owner:ACCOUNT {subscriber: $subscriber, tenant: $tenant})-[]-(email:EMAIL:PRIMARY)-[]-(user:USER)
            RETURN DISTINCT    user.id as id, user.displayName as label, user.mail as value"
  - id: newly_discovered
    name: Newly Discovered
    defaultValue:
    active: true
    view_by:
        - app
    optional: true
    defaultOptions:
        "Yes": true
        "No": false
    type: single
    allowed_params: false
    dataSourceType: knowledgegraph
    input_params: null
    query: ""
  - id: usage_level
    name: Usage Level
    defaultValue:
    active: false
    view_by:
        - app
    optional: true
    defaultOptions: []
    type: multiselect
    allowed_params: false
    dataSourceType: knowledgegraph
    input_params: null
    query: ""
  - id: action_status
    name: Action Status
    defaultValue:
    active: true
    view_by:
        - app
        - account
    optional: false
    defaultOptions:
        - "Actioned"
        - "Pending"
    type: single
    allowed_params: false
    dataSourceType: knowledgegraph
    input_params: null
    query: ""
  - id: department
    name: Department
    defaultValue:
    active: true
    view_by:
        - account
    optional: false
    defaultOptions: []
    type: multiselect
    allowed_params: false
    dataSourceType: knowledgegraph
    input_params: null
    query: "match(d:DEPARTMENT {subscriber: $subscriber, tenant: $tenant}) 
            return DISTINCT d.id AS id, d.name AS value , d.name AS label"
  - id: posture_risk_level
    name: Posture Risk Level
    defaultValue:
    active: true
    view_by:
        - account
    optional: false
    defaultOptions:
        - 'Very High'
        - 'High'
        - 'Moderate'
        - 'Low'
        - 'Very Low'
    type: multiselect
    allowed_params: false
    dataSourceType: knowledgegraph
    input_params: null
    query: ""
  - id: app_category
    name: App Category
    defaultValue:
    active: true
    view_by:
        - account
    optional: true
    defaultOptions: []
    type: multiselect
    allowed_params: false
    dataSourceType: knowledgegraph
    input_params: null
    query: "MATCH (email:EMAIL:PRIMARY {subscriber: $subscriber, tenant: $tenant})-[]-(acc:ACCOUNT)-[:USING_APP]-(app:APPLICATION)-[:HAS_APP_CATEGORY]-(cat:APP_CATEGORY)WHERE cat.priority IS NULL OR cat.priority < 2
            RETURN DISTINCT    cat.name as label, 
                               cat.name as value, 
                               cat.name as id"
  - id: appname
    name: Appname
    defaultValue:
    active: true
    view_by:
        - account
    optional: false
    defaultOptions: []
    type: multiselect
    allowed_params: false
    dataSourceType: knowledgegraph
    input_params: null
    query: "MATCH (email:EMAIL:PRIMARY {subscriber: $subscriber, tenant: $tenant})-[]-(acc:ACCOUNT)-[:USING_APP]-(app:APPLICATION)-[:HAS_APP_CATEGORY]-(cat:APP_CATEGORY)WHERE cat.priority IS NULL OR cat.priority < 2
            RETURN DISTINCT  app.id_ as id, app.id_ as value, app.name as label"
  - id: group
    name: Group
    defaultValue:
    active: true
    view_by:
        - account
    optional: false
    defaultOptions: []
    type: multiselect
    allowed_params: false
    dataSourceType: knowledgegraph
    input_params: null
    query: "MATCH (g:GROUP {subscriber: $subscriber, tenant: $tenant, userDefined: true}) 
            RETURN DISTINCT 
            g.id AS id, 
            g.displayName as label,
            g.displayName as value"
widgets:
  - id: identity_risk
    name: "Identity Risk"
    label: Widget
    template: identity_risk
    enabled: true
    type: multi_linechart
    widget_type: insights_widget
    dataSourceType: datalake
    allowed_params: true
    className: col-span-1
    query_id: ""
    input_params:
      endtime: $endtime
      posture: $posture
    queryFilters:
    query: "select year, monthofyear, dayofmonth, alert_percentile*100 as risk_score, ROUND((alert_percentile*4)+1) as risk_index from kafka_connect.snowdata_schema.postureprofileaggregated where agg_type = 'organization' and agg_subtype = 'posture' and agg_subtype_name = $posture and subscriber = $subscriber and tenant = $tenant order by monthofyear, dayofmonth, agg_type_name, agg_subtype_name"
  - id: identity_metrics
    name: ""
    label: Widget
    template: "detailed_chart"
    enabled: true
    type: detailed
    widget_type: insights_widget
    dataSourceType: datalake
    allowed_params: true
    className: col-span-1
    query_id: ""
    dataLabels:
      - isDetail: true
        label: "Risk Level"
        dataIndex: "Risk_Level"
        percentageIndex: "Risk_Level_chane"
        widget: "risk_level"
      - isDetail: true
        label: "Total Accounts"
        dataIndex: "TOTAL_ACCOUNTS"
        percentageIndex: "TOTAL_ACCOUNTS_CHANGE"
      - isDetail: true
        label: "Total Employees"
        dataIndex: "TOTAL_USERS"
        percentageIndex: "TOTAL_USERS_CHANGE"
      - isDetail: true
        label: "Total Apps"
        dataIndex: "TOTAL_APPS"
        percentageIndex: "TOTAL_APPS_CHANGE"
    input_params:
      endtime: $endtime
    queryFilters:
    query:
      "SELECT * FROM kafka_connect.snowdata_schema.daily_org_analytics WHERE subscriber = $subscriber AND tenant = $tenant ORDER BY timestamp DESC"
  - id: risk_level
    name: ""
    label: Widget
    template: "detailed_chart"
    enabled: true
    type: detailed
    widget_type: insights_widget
    dataSourceType: datalake
    allowed_params: true
    className: col-span-1
    query_id: ""
    dataLabels:
      - isDetail: true
        label: "Risk Level"
        dataIndex: "avg_risk_level"
        percentageIndex: ""
    input_params:
      endtime: $endtime
    queryFilters:
    query: "WITH data AS (
                SELECT 
                    year, monthofyear, dayofmonth, agg_subtype_name, alert_percentile*100 as risk_score, ROUND((alert_percentile*4)+1) as risk_index 
                FROM kafka_connect.snowdata_schema.postureprofileaggregated 
                WHERE agg_type = 'organization' and agg_subtype = 'posture' and agg_subtype_name in ('MFA Risk', 'Password Hygiene') and tenant = $tenant
                ORDER BY year, monthofyear, dayofmonth, agg_subtype_name DESC 
                LIMIT 2
            ),
            risk_level AS (
                SELECT CEIL(AVG(risk_index)) value from data
            )
            SELECT 
                value avg_risk_index,
                CASE WHEN value = 1.0 THEN 'Very Low'
                WHEN value = 2.0 THEN 'Low'
                WHEN value = 3.0 THEN 'Moderate'
                END avg_risk_level
            FROM risk_level"
  - id: password_strength_distribution
    name: "Password Strength"
    label: "Widget"
    template: "passwordStrength"
    type: "bar_distribution"
    widget_type: insights_widget
    query_id: ""
    enabled: true
    queryFilters: []
    className: ""
    query: "MATCH (user:USER {subscriber: $subscriber, tenant: $tenant})-[]-(email:EMAIL)-[]-(account:ACCOUNT)-[:HAS_CRED_FINGERPRINT]-(cfp:CRED_FINGERPRINT)
            
            WITH DISTINCT account.id as accountId,
                CASE
                    WHEN cfp.password_strength > 3 THEN 'Strong'
                    WHEN cfp.password_strength = 3 THEN 'Moderate'
                    ELSE 'Weak'
                END as tag
            
            WITH tag, COUNT(accountId) as count
            ORDER BY 
                CASE tag
                    WHEN 'Strong' THEN 1
                    WHEN 'Moderate' THEN 2
                    WHEN 'Weak' THEN 3
                END
            
            RETURN tag, count"
    allowed_params: false
    input_params: null
    dataSourceType: "knowledgegraph"
  - id: password_manager
    name: "Password Manager Use"
    label: "Widget"
    template: "passwordManager"
    type: "bar_distribution"
    widget_type: insights_widget
    query_id: ""
    enabled: true
    queryFilters: []
    className: ""
    query: ""
    allowed_params: false
    input_params: null
    dataSourceType: "knowledgegraph"
  - id: vulnerable_identities
    name: "Vulnerable Identities"
    label: "Widget"
    template: "bardistribution"
    widget_type: insights_widget
    type: "risk_bar_chart"
    query_id: ""
    enabled: true
    queryFilters: []
    className: ""
    query: ""
    allowed_params: false
    input_params: null
    dataSourceType: "knowledgegraph"
  - id: BID_200
    name: "User Copying Data"
    label: "Widget"
    template: ""
    widget_type: behavior_widget
    type: behavior_widget
    query_id: ""
    enabled: true
    queryFilters: []
    className: ""
    query: "MATCH (user:USER {subscriber: $subscriber, tenant: $tenant})-[]-(email:EMAIL)-[]-(acc:ACCOUNT)-[:HAS_FINDING]-(finding:FINDING)-[]
            -(rule:RULE)-[]-(behavior:BEHAVIOR {id: $behavior})
            OPTIONAL MATCH (finding)-[]-(action:ACTION)
            WITH acc, CASE WHEN COUNT(action) > 0 THEN true ELSE false END as hasAction
            RETURN
                COUNT(DISTINCT acc.id) AS total,
                COUNT(DISTINCT CASE WHEN hasAction = true THEN acc.id END) AS actioned,
                COUNT(DISTINCT CASE WHEN hasAction = false THEN acc.id END) AS pending"
    allowed_params: true
    input_params:
      behavior: $behavior
    dataSourceType: "knowledgegraph"
  - id: BID_201
    name: "User Pasting Data"
    label: "Widget"
    template: ""
    widget_type: behavior_widget
    type: behavior_widget
    query_id: ""
    enabled: true
    queryFilters: []
    className: ""
    query: "MATCH (user:USER {subscriber: $subscriber, tenant: $tenant})-[]-(email:EMAIL)-[]-(acc:ACCOUNT)-[:HAS_FINDING]-(finding:FINDING)-[]
            -(rule:RULE)-[]-(behavior:BEHAVIOR {id: $behavior})
            OPTIONAL MATCH (finding)-[]-(action:ACTION)
            WITH acc, CASE WHEN COUNT(action) > 0 THEN true ELSE false END as hasAction
            RETURN
                COUNT(DISTINCT acc.id) AS total,
                COUNT(DISTINCT CASE WHEN hasAction = true THEN acc.id END) AS actioned,
                COUNT(DISTINCT CASE WHEN hasAction = false THEN acc.id END) AS pending"
    allowed_params: true
    input_params:
      behavior: $behavior
    dataSourceType: "knowledgegraph"
  - id: apps_detailed_BID_200
    name: "User Copying Data Detailed Widget"
    label: Widget
    template: this_template
    enabled: true
    type: drilldown_widget
    widget_type: drilldown_widget
    dataSourceType: knowledgegraph
    allowed_params: true
    className: col-span-1
    query_id: ""
    input_params:
      endtime: $endtime
      appId: $appId
      accountId: $accountId
      behavior: $behavior
    queryFilters: []
    query: "MATCH (user:USER {subscriber: $subscriber, tenant: $tenant})-[]-(email:EMAIL)-[auth_type]-(account:ACCOUNT {id: $accountId})
                -[:HAS_FINDING]-(finding:FINDING)-[]-(rule:RULE)-[]-(behavior:BEHAVIOR {id: $behavior})
            MATCH (account)-[:USING_APP]-(app:APPLICATION {id_: $appId})
            
            OPTIONAL MATCH (app)-[:USING_APP]-(shared_account:ACCOUNT {tenant: $tenant})<-[:CREDENTIAL_SHARED]-(shared_with:ACCOUNT {tenant: $tenant})
            WHERE 
                EXISTS((shared_account)-[:HAS_FINDING]->(:FINDING)-[]-(:RULE)-[]-(:BEHAVIOR {id: 'BID_09'}))
                AND EXISTS((shared_account)-[]-(:EMAIL)-[]-(:USER))
            OPTIONAL MATCH (account)-[hcf:HAS_CRED_FINGERPRINT]-(cf:CRED_FINGERPRINT)-[same_hcf:HAS_CRED_FINGERPRINT]-(same_password_account:ACCOUNT {tenant: $tenant})
            WHERE same_password_account <> account AND same_password_account.email = account.email
            OPTIONAL MATCH (app)-[]-(grant:GRANT)-[]-(scope:SCOPE)
            WHERE toLower(scope.severity) IN ['high', 'medium', 'low']
            OPTIONAL MATCH (app)-[has:HAS_APP_SETTINGS]-(tenant:TENANT {id: $tenant})
            OPTIONAL MATCH (finding)-[:TRIGGERED]-(action:ACTION)
            OPTIONAL MATCH (action)-[:RESULTED_IN]-(outcome:OUTCOME)
            OPTIONAL MATCH (finding)-[:HAS_ARTIFACT]->(dlp:DLP_FINAL_CLASS | DLP_ORIGINAL_CLASS)
            
            WITH app, auth_type, account, hcf, cf, same_hcf, shared_account, same_password_account, COLLECT(DISTINCT scope.severity) as severities, has, finding, action, outcome, dlp
            
            WITH app, auth_type, account, hcf, cf, same_hcf, shared_account, same_password_account, severities, has, finding, action, dlp,
                COALESCE(action.name, '-') AS actionName,
                COUNT(DISTINCT action) AS actionCount,
                CASE WHEN action IS NOT NULL AND outcome IS NULL THEN 'Not Responded'
                    WHEN outcome IS NOT NULL THEN COALESCE(outcome.value, outcome.message, '-')
                END as outcomeValue
            WHERE actionName IS NOT NULL
            
            WITH app, auth_type, account, hcf, cf, same_hcf, shared_account, same_password_account, severities, has, finding, action, dlp, actionName, actionCount,
                outcomeValue, COUNT(outcomeValue) AS outcomeCount
            
            WITH app, auth_type, account, hcf, cf, same_hcf, shared_account, same_password_account, severities, has, finding, action, dlp, actionName, actionCount,
                apoc.map.fromPairs(COLLECT([outcomeValue, outcomeCount])) as outcomeMap
            
            WITH app, severities, has,
                COUNT(DISTINCT CASE WHEN cf.compromised_password_status = true THEN account.id END) as compromised_passwords,
                COUNT(DISTINCT CASE WHEN cf.password_strength < 3 THEN account.id END) as weak_passwords,
                COUNT(DISTINCT shared_account) as shared_accounts,
                COUNT(DISTINCT same_password_account) as same_password_accounts,
                COUNT(DISTINCT CASE WHEN auth_type.isMfaEnabled IS NULL OR auth_type.isMfaEnabled <> true THEN auth_type END) as mfaDisabledCount,
                COUNT(DISTINCT account.id) as totalAccounts,
                COUNT(DISTINCT CASE WHEN type(auth_type) = 'CREDSBASED_ACCOUNT' THEN account.id END) as credsbased_account_count,
                COUNT(DISTINCT CASE WHEN type(auth_type) = 'OAUTH_ACCOUNT' THEN account.id END) as oauth_account_count,
                COUNT(DISTINCT finding.id) as totalFindings,
                COUNT(DISTINCT CASE WHEN action IS NOT NULL THEN action END) as actionedCount,
                COUNT(DISTINCT CASE WHEN action IS NULL THEN finding.id END) as pendingCount,
                MIN(COALESCE(
                    CASE WHEN account.creationTime <> '-' THEN account.creationTime ELSE NULL END, timestamp()
                )) AS firstAccessed,
                MAX(auth_type.last_access_time) AS lastAccessed,
                COLLECT(DISTINCT dlp.id) AS sensitiveDataClasses,
                apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, actionCount] END)) AS combinedActionTracker,
                apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, outcomeMap] END)) AS combinedActionOutcomes
            
            RETURN DISTINCT
                COALESCE(app.id_, app.internalId) AS id,
                COALESCE(app.name, app.domain, app.id) AS app,
                app.logoUrl AS appLogoUrl,
                app.description AS description,
                firstAccessed,
                lastAccessed,
                compromised_passwords,
                weak_passwords,
                shared_accounts,
                same_password_accounts,
                app.isMfaSupported = true as mfaSupported,
                mfaDisabledCount,
                totalAccounts,
                credsbased_account_count,
                oauth_account_count,
                COALESCE(has.approval_status, 'Not Defined') AS approvalStatus,
                COALESCE(has.criticality, 'Not Defined') AS criticality,
                app.domain AS domain,
                CASE
                    WHEN app.complianceScore <= 2 THEN 'Very High'
                    WHEN app.complianceScore <= 4 THEN 'High'
                    WHEN app.complianceScore <= 6 THEN 'Moderate'
                    WHEN app.complianceScore <= 8 THEN 'Low'
                    WHEN app.complianceScore <= 10 THEN 'Very Low'
                    ELSE ''
                END AS complianceRisk,
                apoc.map.fromPairs([key IN keys(app) WHERE key STARTS WITH 'Compliance' | [replace(key, 'Compliance', ''), app[key] = true]]) AS complianceList,
                CASE
                    WHEN app.securityScore <= 2 THEN 'Very High'
                    WHEN app.securityScore <= 4 THEN 'High'
                    WHEN app.securityScore <= 6 THEN 'Moderate'
                    WHEN app.securityScore <= 8 THEN 'Low'
                    WHEN app.securityScore <= 10 THEN 'Very Low'
                    ELSE ''
                END AS securityRisk,
                apoc.map.fromPairs([key IN keys(app) WHERE key STARTS WITH 'Security' | [replace(key, 'Security', ''), app[key] = true]]) AS securitySupportedList,
                app.SecuritySupportsSAML = true AS isSamlSupported,
                app.isMfaSupported = true AS isMfaSupported,
                CASE
                    WHEN 'High' IN severities THEN 'High'
                    WHEN 'Medium' IN severities THEN 'Medium'
                    ELSE 'Low'
                END AS severityRisk,
                apoc.map.fromPairs([
                    ['High', SIZE([x IN severities WHERE toLower(x) = 'high'])],
                    ['Medium', SIZE([x IN severities WHERE toLower(x) = 'medium'])],
                    ['Low', SIZE([x IN severities WHERE toLower(x) = 'low'])]
                ]) AS oauthSeverity,
                apoc.map.fromPairs([
                    ['breachDate', app.breachDate],
                    ['breachDataClasses', app.breachDataClasses]
                ]) AS breachData,
                sensitiveDataClasses,
                totalFindings,
                actionedCount,
                pendingCount,
                combinedActionTracker AS actionTracker,
                combinedActionOutcomes AS actionOutcomes"
  - id: apps_detailed_BID_201
    name: "User Pasting Data Detailed Widget"
    label: Widget
    template: this_template
    enabled: true
    type: drilldown_widget
    widget_type: drilldown_widget
    dataSourceType: knowledgegraph
    allowed_params: true
    className: col-span-1
    query_id: ""
    input_params:
      endtime: $endtime
      appId: $appId
      accountId: $accountId
      behavior: $behavior
    queryFilters: []
    query: "MATCH (user:USER {subscriber: $subscriber, tenant: $tenant})-[]-(email:EMAIL)-[auth_type]-(account:ACCOUNT {id: $accountId})
                -[:HAS_FINDING]-(finding:FINDING)-[]-(rule:RULE)-[]-(behavior:BEHAVIOR {id: $behavior})
            MATCH (account)-[:USING_APP]-(app:APPLICATION {id_: $appId})
            
            OPTIONAL MATCH (app)-[:USING_APP]-(shared_account:ACCOUNT {tenant: $tenant})<-[:CREDENTIAL_SHARED]-(shared_with:ACCOUNT {tenant: $tenant})
            WHERE 
                EXISTS((shared_account)-[:HAS_FINDING]->(:FINDING)-[]-(:RULE)-[]-(:BEHAVIOR {id: 'BID_09'}))
                AND EXISTS((shared_account)-[]-(:EMAIL)-[]-(:USER))
            OPTIONAL MATCH (account)-[hcf:HAS_CRED_FINGERPRINT]-(cf:CRED_FINGERPRINT)-[same_hcf:HAS_CRED_FINGERPRINT]-(same_password_account:ACCOUNT {tenant: $tenant})
            WHERE same_password_account <> account AND same_password_account.email = account.email
            OPTIONAL MATCH (app)-[]-(grant:GRANT)-[]-(scope:SCOPE)
            WHERE toLower(scope.severity) IN ['high', 'medium', 'low']
            OPTIONAL MATCH (app)-[has:HAS_APP_SETTINGS]-(tenant:TENANT {id: $tenant})
            OPTIONAL MATCH (finding)-[:TRIGGERED]-(action:ACTION)
            OPTIONAL MATCH (action)-[:RESULTED_IN]-(outcome:OUTCOME)
            OPTIONAL MATCH (finding)-[:HAS_ARTIFACT]->(dlp:DLP_FINAL_CLASS | DLP_ORIGINAL_CLASS)
            
            WITH app, auth_type, account, hcf, cf, same_hcf, shared_account, same_password_account, COLLECT(DISTINCT scope.severity) as severities, has, finding, action, outcome, dlp
            
            WITH app, auth_type, account, hcf, cf, same_hcf, shared_account, same_password_account, severities, has, finding, action, dlp,
                COALESCE(action.name, '-') AS actionName,
                COUNT(DISTINCT action) AS actionCount,
                CASE WHEN action IS NOT NULL AND outcome IS NULL THEN 'Not Responded'
                    WHEN outcome IS NOT NULL THEN COALESCE(outcome.value, outcome.message, '-')
                END as outcomeValue
            WHERE actionName IS NOT NULL
            
            WITH app, auth_type, account, hcf, cf, same_hcf, shared_account, same_password_account, severities, has, finding, action, dlp, actionName, actionCount,
                outcomeValue, COUNT(outcomeValue) AS outcomeCount
            
            WITH app, auth_type, account, hcf, cf, same_hcf, shared_account, same_password_account, severities, has, finding, action, dlp, actionName, actionCount,
                apoc.map.fromPairs(COLLECT([outcomeValue, outcomeCount])) as outcomeMap
            
            WITH app, severities, has,
                COUNT(DISTINCT CASE WHEN cf.compromised_password_status = true THEN account.id END) as compromised_passwords,
                COUNT(DISTINCT CASE WHEN cf.password_strength < 3 THEN account.id END) as weak_passwords,
                COUNT(DISTINCT shared_account) as shared_accounts,
                COUNT(DISTINCT same_password_account) as same_password_accounts,
                COUNT(DISTINCT CASE WHEN auth_type.isMfaEnabled IS NULL OR auth_type.isMfaEnabled <> true THEN auth_type END) as mfaDisabledCount,
                COUNT(DISTINCT account.id) as totalAccounts,
                COUNT(DISTINCT CASE WHEN type(auth_type) = 'CREDSBASED_ACCOUNT' THEN account.id END) as credsbased_account_count,
                COUNT(DISTINCT CASE WHEN type(auth_type) = 'OAUTH_ACCOUNT' THEN account.id END) as oauth_account_count,
                COUNT(DISTINCT finding.id) as totalFindings,
                COUNT(DISTINCT CASE WHEN action IS NOT NULL THEN action END) as actionedCount,
                COUNT(DISTINCT CASE WHEN action IS NULL THEN finding.id END) as pendingCount,
                MIN(COALESCE(
                    CASE WHEN account.creationTime <> '-' THEN account.creationTime ELSE NULL END, timestamp()
                )) AS firstAccessed,
                MAX(auth_type.last_access_time) AS lastAccessed,
                COLLECT(DISTINCT dlp.id) AS sensitiveDataClasses,
                apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, actionCount] END)) AS combinedActionTracker,
                apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, outcomeMap] END)) AS combinedActionOutcomes
            
            RETURN DISTINCT
                COALESCE(app.id_, app.internalId) AS id,
                COALESCE(app.name, app.domain, app.id) AS app,
                app.logoUrl AS appLogoUrl,
                app.description AS description,
                firstAccessed,
                lastAccessed,
                compromised_passwords,
                weak_passwords,
                shared_accounts,
                same_password_accounts,
                app.isMfaSupported = true as mfaSupported,
                mfaDisabledCount,
                totalAccounts,
                credsbased_account_count,
                oauth_account_count,
                COALESCE(has.approval_status, 'Not Defined') AS approvalStatus,
                COALESCE(has.criticality, 'Not Defined') AS criticality,
                app.domain AS domain,
                CASE
                    WHEN app.complianceScore <= 2 THEN 'Very High'
                    WHEN app.complianceScore <= 4 THEN 'High'
                    WHEN app.complianceScore <= 6 THEN 'Moderate'
                    WHEN app.complianceScore <= 8 THEN 'Low'
                    WHEN app.complianceScore <= 10 THEN 'Very Low'
                    ELSE ''
                END AS complianceRisk,
                apoc.map.fromPairs([key IN keys(app) WHERE key STARTS WITH 'Compliance' | [replace(key, 'Compliance', ''), app[key] = true]]) AS complianceList,
                CASE
                    WHEN app.securityScore <= 2 THEN 'Very High'
                    WHEN app.securityScore <= 4 THEN 'High'
                    WHEN app.securityScore <= 6 THEN 'Moderate'
                    WHEN app.securityScore <= 8 THEN 'Low'
                    WHEN app.securityScore <= 10 THEN 'Very Low'
                    ELSE ''
                END AS securityRisk,
                apoc.map.fromPairs([key IN keys(app) WHERE key STARTS WITH 'Security' | [replace(key, 'Security', ''), app[key] = true]]) AS securitySupportedList,
                app.SecuritySupportsSAML = true AS isSamlSupported,
                app.isMfaSupported = true AS isMfaSupported,
                CASE
                    WHEN 'High' IN severities THEN 'High'
                    WHEN 'Medium' IN severities THEN 'Medium'
                    ELSE 'Low'
                END AS severityRisk,
                apoc.map.fromPairs([
                    ['High', SIZE([x IN severities WHERE toLower(x) = 'high'])],
                    ['Medium', SIZE([x IN severities WHERE toLower(x) = 'medium'])],
                    ['Low', SIZE([x IN severities WHERE toLower(x) = 'low'])]
                ]) AS oauthSeverity,
                apoc.map.fromPairs([
                    ['breachDate', app.breachDate],
                    ['breachDataClasses', app.breachDataClasses]
                ]) AS breachData,
                sensitiveDataClasses,
                totalFindings,
                actionedCount,
                pendingCount,
                combinedActionTracker AS actionTracker,
                combinedActionOutcomes AS actionOutcomes"
table_render:
  insights:
    queries: []
  table_additional_data:
    no_hover: true
    row_border: true
    alternate_row_colors: true
    no_table_padding: true
    table_heading_bg: bg-dark-300
    table_filters_wrapper_class: grid grid-cols-12
    no_calendar: true
    no_drilldown: true
  table_filters:
    risk_level:
      show_in_view:
        - id: unapproved_ai_applications
          is_default: false
        - id: ai_applications_with_risky_oauth_scopes
          is_default: false
        - id: newly_introduced_ai_users
          is_default: false
        - id: users_leaking_sensitive_data
          is_default: false
    criticality:
      show_in_view:
        - id: unapproved_ai_applications
          is_default: false
        - id: ai_applications_with_risky_oauth_scopes
          is_default: false
        - id: newly_introduced_ai_users
          is_default: false
        - id: users_leaking_sensitive_data
          is_default: false
    approval_status:
      show_in_view:
        - id: unapproved_ai_applications
          is_default: true
        - id: ai_applications_with_risky_oauth_scopes
          is_default: true
        - id: newly_introduced_ai_users
          is_default: true
        - id: users_leaking_sensitive_data
          is_default: true
    technical_owner:
      show_in_view:
        - id: unapproved_ai_applications
          is_default: false
        - id: ai_applications_with_risky_oauth_scopes
          is_default: false
        - id: newly_introduced_ai_users
          is_default: false
        - id: users_leaking_sensitive_data
          is_default: false
    newly_discovered:
      show_in_view:
        - id: unapproved_ai_applications
          is_default: false
        - id: ai_applications_with_risky_oauth_scopes
          is_default: false
        - id: newly_introduced_ai_users
          is_default: false
        - id: users_leaking_sensitive_data
          is_default: false
    usage_level:
      show_in_view:
        - id: unapproved_ai_applications
          is_default: false
        - id: ai_applications_with_risky_oauth_scopes
          is_default: false
        - id: newly_introduced_ai_users
          is_default: false
        - id: users_leaking_sensitive_data
          is_default: false
    finding_status:
      show_in_view:
        - id: unapproved_ai_applications
          is_default: true
        - id: ai_applications_with_risky_oauth_scopes
          is_default: true
        - id: newly_introduced_ai_users
          is_default: true
        - id: users_leaking_sensitive_data
          is_default: true
    sensitive_data:
      show_in_view:
        - id: unapproved_ai_applications
          is_default: true
        - id: ai_applications_with_risky_oauth_scopes
          is_default: true
        - id: newly_introduced_ai_users
          is_default: true
        - id: users_leaking_sensitive_data
          is_default: true
    risky_oauth_scopes:
      show_in_view:
        - id: unapproved_ai_applications
          is_default: true
        - id: ai_applications_with_risky_oauth_scopes
          is_default: true
        - id: newly_introduced_ai_users
          is_default: true
        - id: users_leaking_sensitive_data
          is_default: true
    oauth_scope_risk_level:
      show_in_view:
        - id: unapproved_ai_applications
          is_default: true
        - id: ai_applications_with_risky_oauth_scopes
          is_default: true
        - id: newly_introduced_ai_users
          is_default: true
        - id: users_leaking_sensitive_data
          is_default: true
    granted_by:
      show_in_view:
        - id: unapproved_ai_applications
          is_default: true
        - id: ai_applications_with_risky_oauth_scopes
          is_default: true
        - id: newly_introduced_ai_users
          is_default: true
        - id: users_leaking_sensitive_data
          is_default: true
    grant_type:
      show_in_view:
        - id: unapproved_ai_applications
          is_default: true
        - id: ai_applications_with_risky_oauth_scopes
          is_default: true
        - id: newly_introduced_ai_users
          is_default: true
        - id: users_leaking_sensitive_data
          is_default: true
  table:
  unapproved_ai_applications:
  ai_applications_with_risky_oauth_scopes:
  newly_introduced_ai_users:
  users_leaking_sensitive_data:
pagination_query:
  query: ""
  dataSourceType: knowledgegraph
table_widget: []
