id: ai-usage-risk
name: AI Usage Risks
type: screen
enabled: true
version: 1.2.48
icon_url: https://staticcontent1.blob.core.windows.net/finding-icons/posture-ai-usage.svg
table_query:
  id: 82f39be8-e238-4a2e-bee3-5ecb6bd420a3
  name: Display Table Data
  queryString: null
  type: merge
  allowed_params: true
  allowed_body: true
  input_params:
    sample: value
  input_body: null
  dataSourceType: knowledgegraph
  sortOrder: desc
  sortColumn: lastseen
  limit: 10
  offset: 0
detailed_widget:
  - id: BID_01_detailed
    multi_value_params:
      - id: appId
        delimiter: ","
      - id: group
        delimiter: ","
      - id: department
        delimiter: ","
      - id: criticality
        delimiter: ","
      - id: approval_status
        delimiter: ","
      - id: appname
        delimiter: ","
      - id: app_category
        delimiter: ","
    query: "MATCH (app:APPLICATION)
            WHERE app.id_ IN [$appId]
            MATCH (app)<-[using_app:USING_APP]-(account:ACCOUNT {subscriber: $subscriber, tenant: $tenant})
            MATCH (account)<-[auth_type]-(email:EMAIL)
            MATCH (email)<-[:HAS_EMAIL]-(user:USER)
            MATCH (account)-[:HAS_FINDING]->(finding:FINDING)
            MATCH (finding)<-[:EVALUATED_TO]-(rule:RULE)-[:BELONGS_TO]->(behavior:BEHAVIOR {id: $behavior})
            
            OPTIONAL MATCH (app)-[:HAS_GRANT]->(grant:GRANT)-[:HAS_SCOPE]->(scope:SCOPE)
            WHERE scope.severity IN ['High', 'Medium', 'Low']
            
            OPTIONAL MATCH (app)-[has:HAS_APP_SETTINGS]-(tenant:TENANT {id: $tenant})
            OPTIONAL MATCH (user)-[:HAS_DEPARTMENT]->(department:DEPARTMENT)
            OPTIONAL MATCH (user)-[:BELONGS_TO]->(group:GROUP {userDefined: true})
            OPTIONAL MATCH (app)-[:HAS_APP_CATEGORY]->(app_category:APP_CATEGORY)
            
            OPTIONAL MATCH (finding)-[:TRIGGERED]->(action:ACTION)
            OPTIONAL MATCH (action)-[:RESULTED_IN]-(outcome:OUTCOME)
            OPTIONAL MATCH (action)-[:HAS_INTERACTION]->(interaction:INTERACTION)
            OPTIONAL MATCH (finding)-[:HAS_ARTIFACT]->(dlp:DLP_FINAL_CLASS | DLP_ORIGINAL_CLASS)
            
            WITH app, has, group, department, app_category, account, auth_type, email, user, finding,
                CASE 
                    WHEN COUNT(dlp.id) = 0 THEN 'No Sensitive Data Shared' 
                    ELSE COLLECT(DISTINCT dlp.id) 
                END AS sensitiveDataClasses,
                COLLECT(DISTINCT CASE WHEN scope.severity = 'High' THEN scope.name END) AS highSeverityScopes,
                COUNT(scope.severity) AS severityCount,
                COLLECT(DISTINCT scope.severity) AS severityList,
                datetime.truncate('day', datetime() - duration('P1M')).epochMillis AS one_month_ago_epoch,
                {actioned: COUNT(DISTINCT CASE WHEN action IS NOT NULL THEN finding.id END),
                    pending: COUNT(DISTINCT CASE WHEN action IS NULL THEN finding.id END)} AS actionStatus,
                apoc.map.fromPairs(COLLECT(DISTINCT
                    [action.name, CASE WHEN outcome IS NOT NULL THEN outcome.description ELSE action.description END]
                )) AS actionCurrentState,
                COLLECT(
                    CASE WHEN interaction IS NOT NULL THEN 
                        {message: interaction.message,
                        name: interaction.name,
                        messageTime: interaction.messageTime,
                        initiator: interaction.initiator}
                    END
                ) AS interactionsList,
                COLLECT(DISTINCT scope.severity) AS severities
            
            UNWIND
                CASE WHEN SIZE(interactionsList) > 0 THEN interactionsList
                ELSE [NULL]
            END AS interactionData
                      
            WITH app, has, group, department, app_category, account, auth_type, email, user, sensitiveDataClasses, finding,
                highSeverityScopes, severityList, severities, actionStatus, actionCurrentState, interactionData, one_month_ago_epoch
                ORDER BY interactionData.messageTime, severities
            
            
            WITH app, has, group, department, app_category, account, auth_type, email, user, sensitiveDataClasses, finding,
                highSeverityScopes, severityList, actionStatus, actionCurrentState, one_month_ago_epoch,
                COLLECT(interactionData) AS sortedInteractions,
                REDUCE(acc = {}, severity IN ['High', 'Medium', 'Low'] |
                    CASE 
                        WHEN severity IN severities 
                        THEN apoc.map.setKey(acc, severity, size([s IN severities WHERE s = severity]))
                        ELSE acc
                    END
                ) AS oauthSeverity
                
            WHERE app.name IS NOT NULL
            {placeholder}
            
            RETURN DISTINCT
                email.id AS userMail,
                user.displayName AS userName,
                COALESCE(app.name, app.domain, app.id) AS appName,
                user.profilePicUrl AS userProfilePicUrl,
                COLLECT(DISTINCT department.name) AS departments,
                app.logoUrl AS appLogoUrl,
                COLLECT(DISTINCT app_category.name) AS appCategories,
                has.approval_status AS appStatus,
                actionStatus,
                actionCurrentState,
                MIN(auth_type.creationTime) AS firstAccessed,
                MAX(auth_type.last_access_time) AS lastAccessed,
                sensitiveDataClasses,
                CASE
                    WHEN size(highSeverityScopes) = 0 THEN 'No High Risk Oauth Scopes'
                    ELSE highSeverityScopes
                END AS highSeverityScopes,
                CASE
                    WHEN 'High' IN severityList THEN 'High'
                    WHEN 'Medium' IN severityList THEN 'Medium'
                    WHEN 'Low' IN severityList THEN 'Low'
                END AS severityRisk,
                sortedInteractions,
                oauthSeverity"
    input_params:
      appId: $appId
      behavior: $behavior
      group: AND toLower(group.displayName) = toLower($group)
      department: AND toLower(department.name) = toLower($department)
      appname: AND toLower(COALESCE(app.name, app.domain, app.id)) = toLower($appname)
      app_category: AND toLower(app_category.name) = toLower($app_category)
      criticality: AND toLower(COALESCE(has.criticality, app.criticality)) = toLower($criticality)
      approval_status: AND toLower(has.approval_status) = toLower($approval_status)
    dataSourceType: "knowledgegraph"
    enabled: true
    allowed_params: true
    sortOrder: ""
    sortColumn: ""
    name: "AI Applications with Risky Scopes Detailed"
    position: null
    template: null
    className: null
    pagination_query: "MATCH (app:APPLICATION)
            WHERE app.id_ IN [$appId]
            MATCH (app)<-[using_app:USING_APP]-(account:ACCOUNT {subscriber: $subscriber, tenant: $tenant})
            MATCH (account)<-[auth_type]-(email:EMAIL)
            MATCH (email)<-[:HAS_EMAIL]-(user:USER)
            MATCH (account)-[:HAS_FINDING]->(finding:FINDING)
            MATCH (finding)<-[:EVALUATED_TO]-(rule:RULE)-[:BELONGS_TO]->(behavior:BEHAVIOR {id: $behavior})
            
            OPTIONAL MATCH (app)-[:HAS_GRANT]->(grant:GRANT)-[:HAS_SCOPE]->(scope:SCOPE)
            WHERE scope.severity IN ['High', 'Medium', 'Low']
            
            OPTIONAL MATCH (app)-[has:HAS_APP_SETTINGS]-(tenant:TENANT {id: $tenant})
            OPTIONAL MATCH (user)-[:HAS_DEPARTMENT]->(department:DEPARTMENT)
            OPTIONAL MATCH (user)-[:BELONGS_TO]->(group:GROUP {userDefined: true})
            OPTIONAL MATCH (app)-[:HAS_APP_CATEGORY]->(app_category:APP_CATEGORY)
            
            OPTIONAL MATCH (finding)-[:TRIGGERED]->(action:ACTION)
            OPTIONAL MATCH (action)-[:RESULTED_IN]-(outcome:OUTCOME)
            OPTIONAL MATCH (action)-[:HAS_INTERACTION]->(interaction:INTERACTION)
            OPTIONAL MATCH (finding)-[:HAS_ARTIFACT]->(dlp:DLP_FINAL_CLASS | DLP_ORIGINAL_CLASS)
            
            WITH app, has, group, department, app_category, account, auth_type, email, user, finding,
                CASE 
                    WHEN COUNT(dlp.id) = 0 THEN 'No Sensitive Data Shared' 
                    ELSE COLLECT(DISTINCT dlp.id) 
                END AS sensitiveDataClasses,
                COLLECT(DISTINCT CASE WHEN scope.severity = 'High' THEN scope.name END) AS highSeverityScopes,
                COUNT(scope.severity) AS severityCount,
                COLLECT(DISTINCT scope.severity) AS severityList,
                datetime.truncate('day', datetime() - duration('P1M')).epochMillis AS one_month_ago_epoch,
                {actioned: COUNT(DISTINCT CASE WHEN action IS NOT NULL THEN finding.id END),
                    pending: COUNT(DISTINCT CASE WHEN action IS NULL THEN finding.id END)} AS actionStatus,
                apoc.map.fromPairs(COLLECT(DISTINCT
                    [action.name, CASE WHEN outcome IS NOT NULL THEN outcome.description ELSE action.description END]
                )) AS actionCurrentState,
                COLLECT(
                    CASE WHEN interaction IS NOT NULL THEN 
                        {message: interaction.message,
                        name: interaction.name,
                        messageTime: interaction.messageTime,
                        initiator: interaction.initiator}
                    END
                ) AS interactionsList,
                COLLECT(DISTINCT scope.severity) AS severities
            
            UNWIND
                CASE WHEN SIZE(interactionsList) > 0 THEN interactionsList
                ELSE [NULL]
            END AS interactionData
                      
            WITH app, has, group, department, app_category, account, auth_type, email, user, sensitiveDataClasses, finding,
                highSeverityScopes, severityList, severities, actionStatus, actionCurrentState, interactionData, one_month_ago_epoch
                ORDER BY interactionData.messageTime, severities
            
            
            WITH app, has, group, department, app_category, account, auth_type, email, user, sensitiveDataClasses, finding,
                highSeverityScopes, severityList, actionStatus, actionCurrentState, one_month_ago_epoch,
                COLLECT(interactionData) AS sortedInteractions,
                REDUCE(acc = {}, severity IN ['High', 'Medium', 'Low'] |
                    CASE 
                        WHEN severity IN severities 
                        THEN apoc.map.setKey(acc, severity, size([s IN severities WHERE s = severity]))
                        ELSE acc
                    END
                ) AS oauthSeverity
                
            WHERE app.name IS NOT NULL
            {placeholder}

            RETURN COUNT(DISTINCT account.id) AS totalCount"
  - id: BID_02_detailed
    query: |
            MATCH (app:APPLICATION)
            WHERE app.id_ IN [$appId]
            MATCH (account:ACCOUNT {id: $accountId,subscriber: $subscriber, tenant: $tenant})-[:USING_APP]->(app)
            MATCH (email:EMAIL)-[auth_type]->(account)
            MATCH (user:USER)-[:HAS_EMAIL]->(email) 
            MATCH (finding:FINDING)<-[:HAS_FINDING]-(account)
            MATCH (finding)<-[:EVALUATED_TO]-(rule:RULE)-[:BELONGS_TO]->(behavior:BEHAVIOR {id: $behavior})

            WITH app, account, COLLECT(DISTINCT auth_type) AS auth_types, email, user, finding, rule, 
            datetime.truncate('day', datetime() - duration('P1M')).epochMillis AS one_month_ago_epoch

            OPTIONAL MATCH (finding)-[:TRIGGERED]->(action:ACTION)
            OPTIONAL MATCH (action)-[:RESULTED_IN]-(outcome:OUTCOME)
            OPTIONAL MATCH (finding)-[:HAS_ARTIFACT]->(dlp:DLP_FINAL_CLASS | DLP_ORIGINAL_CLASS)
            OPTIONAL MATCH (action)-[:HAS_INTERACTION]->(interaction:INTERACTION)

            WITH app, account, auth_types, email, user, rule, one_month_ago_epoch, dlp, 
            COLLECT({
                 findingId: finding.id,
                 rule: rule.name, 
                 action: action.name,
                 outcomeDesc: outcome.description,
                 actionDesc: action.description,
                 interaction: CASE WHEN interaction IS NOT NULL THEN true ELSE false END
            }) AS findingData

            WITH app, account, auth_types, email, user, one_month_ago_epoch, findingData, 
                rule, dlp, 
                SUM(CASE WHEN ANY(data IN findingData WHERE data.action IS NOT NULL) THEN 1 ELSE 0 END) AS actionedCountPerRule,
                SUM(CASE WHEN NONE(data IN findingData WHERE data.action IS NOT NULL) THEN 1 ELSE 0 END) AS pendingCountPerRule,
                ANY(data IN findingData WHERE data.interaction IS NOT NULL AND data.interaction) AS interactionsExist,
                apoc.map.fromPairs(apoc.coll.flatten(COLLECT(DISTINCT [
                   data IN findingData | [data.action, COALESCE(data.outcomeDesc, data.actionDesc)]
               ]))) AS actionCurrentState

            WITH app, account, auth_types, email, user, one_month_ago_epoch,
                SUM(actionedCountPerRule) AS totalActioned,
                SUM(pendingCountPerRule) AS totalPending,
                actionCurrentState, findingData, dlp, 
                interactionsExist

            OPTIONAL MATCH (app)-[:HAS_GRANT]->(grant:GRANT)-[:HAS_SCOPE]->(scope:SCOPE)
            WHERE scope.severity IN ['High', 'Medium', 'Low']
            WITH app, account, auth_types, email, user, totalActioned, totalPending, actionCurrentState, 
                interactionsExist,
                one_month_ago_epoch, dlp, 
                COLLECT(DISTINCT CASE WHEN scope.severity = 'High' THEN scope.name END) AS highSeverityScopes,
                COLLECT(DISTINCT scope.severity) AS severityList,
                apoc.map.fromPairs(
                    CASE 
                        WHEN interactionsExist IS NOT NULL AND interactionsExist 
                        THEN [data IN findingData WHERE data.interaction IS NOT NULL AND data.interaction | [data.rule, true]]
                        ELSE []
                    END
                ) AS ruleInteractionMap

            OPTIONAL MATCH (app)-[has:HAS_APP_SETTINGS]-(tenant:TENANT {id: $tenant})
            OPTIONAL MATCH (user)-[:HAS_DEPARTMENT]->(department:DEPARTMENT)
            OPTIONAL MATCH (user)-[:BELONGS_TO]->(group:GROUP {userDefined: true})
            OPTIONAL MATCH (app)-[:HAS_APP_CATEGORY]->(app_category:APP_CATEGORY)

            WITH app, account, auth_types, email, user, totalActioned, totalPending, actionCurrentState, 
                interactionsExist, 
                ruleInteractionMap, 
                one_month_ago_epoch, dlp, 
                highSeverityScopes, severityList, has, department, group, app_category,
                (EXISTS((app)-[:WHITELISTED_FOR {tenant: $tenant}]->(:BEHAVIOR {id: $behavior})) OR EXISTS((account)-[:WHITELISTED_FOR]->(:BEHAVIOR {id: $behavior}))) AS is_whitelisted,
                apoc.coll.min([auth in auth_types | auth.creationTime]) AS firstAccessed,
                apoc.coll.max([auth in auth_types | auth.last_access_time]) AS lastAccessed
    
            WHERE COALESCE(app.name, app.domain) IS NOT NULL
            {placeholder}
            
            RETURN DISTINCT
                email.id AS userMail,
                user.displayName AS userName,
                account.id AS accountId,
                COALESCE(app.id_, app.internalId) AS appId,
                COALESCE(app.name, app.domain, app.id_) AS appName,
                user.profilePicUrl AS userProfilePicUrl,
                COLLECT(DISTINCT department.name) AS departments,
                is_whitelisted,
                app.logoUrl AS appLogoUrl,
                COLLECT(DISTINCT app_category.name) AS appCategories,
                has.approval_status AS appStatus,
                {actioned: totalActioned, pending: totalPending} AS actionStatus, 
                actionCurrentState,
                MIN(account.creationTime) AS firstAccessed,
                lastAccessed,
                CASE 
                    WHEN COUNT(dlp.id) > 0 THEN true
                    ELSE false
                END AS sensitiveDataShared,
                highSeverityScopes,
                interactionsExist,
                ruleInteractionMap
    input_params:
      appId: $appId
      behavior: $behavior
      accountId: $accountId
      group: AND toLower(group.displayName) IN [ x IN [$group] | toLower(x) ]
      department: AND toLower(department.name) IN [ x IN [$deparment] | toLower(x) ]
      appname: AND toLower(COALESCE(app.name, app.domain, app.id)) IN [ x IN [$appname] | toLower(x) ]
      app_category: AND toLower(app_category.name) IN [ x IN [$app_category] | toLower(x) ]
      criticality: AND toLower(COALESCE(has.criticality, app.criticality)) IN [ x IN [$criticality] | toLower(x) ]
      approval_status: AND toLower(has.approval_status) IN [ x IN [$approval_status] | toLower(x) ]
    dataSourceType: "knowledgegraph"
    enabled: true
    allowed_params: true
    sortOrder: ""
    sortColumn: ""
    name: "Newly Introduced AI Users Detailed"
    position: null
    template: null
    className: null
    multi_value_params:
      - id: appId
        delimiter: ","
      - id: group
        delimiter: ","
      - id: department
        delimiter: ","
      - id: criticality
        delimiter: ","
      - id: approval_status
        delimiter: ","
      - id: appname
        delimiter: ","
      - id: app_category
        delimiter: ","
    pagination_query: "MATCH (app:APPLICATION)
            WHERE app.id_ IN [$appId]
            MATCH (app)<-[using_app:USING_APP]-(account:ACCOUNT {id: $accountId, subscriber: $subscriber, tenant: $tenant})
            MATCH (account)<-[auth_type]-(email:EMAIL)
            MATCH (email)<-[:HAS_EMAIL]-(user:USER)
            MATCH (account)-[:HAS_FINDING]->(finding:FINDING)
            MATCH (finding)<-[:EVALUATED_TO]-(rule:RULE)-[:BELONGS_TO]->(behavior:BEHAVIOR {id: $behavior})
            
            OPTIONAL MATCH (app)-[:HAS_GRANT]->(grant:GRANT)-[:HAS_SCOPE]->(scope:SCOPE)
            WHERE scope.severity IN ['High', 'Medium', 'Low']
            
            OPTIONAL MATCH (finding)-[:TRIGGERED]->(action:ACTION)
            OPTIONAL MATCH (action)-[:RESULTED_IN]-(outcome:OUTCOME)
            OPTIONAL MATCH (action)-[:HAS_INTERACTION]->(interaction:INTERACTION)
            OPTIONAL MATCH (app)-[has:HAS_APP_SETTINGS]-(tenant:TENANT {id: $tenant})
            OPTIONAL MATCH (user)-[:HAS_DEPARTMENT]->(department:DEPARTMENT)
            OPTIONAL MATCH (user)-[:BELONGS_TO]->(group:GROUP {userDefined: true})
            OPTIONAL MATCH (app)-[:HAS_APP_CATEGORY]->(app_category:APP_CATEGORY)
            OPTIONAL MATCH (finding)-[:HAS_ARTIFACT]->(dlp:DLP_FINAL_CLASS | DLP_ORIGINAL_CLASS)
            
            WITH app, has, group, department, app_category, account, auth_type, email, user, dlp, scope, rule,
                COLLECT(DISTINCT CASE WHEN scope.severity = 'High' THEN scope.name END) AS highSeverityScopes,
                {actioned: COUNT(DISTINCT CASE WHEN action IS NOT NULL THEN finding.id END),
                    pending: COUNT(DISTINCT CASE WHEN action IS NULL THEN finding.id END)} AS actionStatus,
                apoc.map.fromPairs(COLLECT(DISTINCT
                    [action.name, CASE WHEN outcome IS NOT NULL THEN outcome.description ELSE action.description END]
                )) AS actionCurrentState,
                EXISTS {
                    MATCH (action)-[:HAS_INTERACTION]->(:INTERACTION)
                } AS interactionsExist,
                (EXISTS((app)-[:WHITELISTED_FOR]->(:BEHAVIOR {id: $behavior})) OR EXISTS((account)-[:WHITELISTED_FOR]->(:BEHAVIOR {id: $behavior}))) AS is_whitelisted
                
            WHERE COALESCE(app.name, app.domain) IS NOT NULL
            {placeholder}

            RETURN
                COUNT(DISTINCT account.id) AS totalCount"
  - id: BID_03_detailed
    query: "MATCH (app:APPLICATION)
            WHERE app.id_ IN [$appId]
            MATCH (app)<-[:USING_APP]-(account:ACCOUNT {id: $accountId, subscriber: $subscriber, tenant: $tenant})
            MATCH (account)-[:HAS_FINDING]->(finding:FINDING | FINDING_HISTORY)

            OPTIONAL MATCH (finding)-[:TRIGGERED]->(action:ACTION)
            OPTIONAL MATCH (action)-[:RESULTED_IN]-(outcome:OUTCOME)
            OPTIONAL MATCH (action)-[]->(interaction:INTERACTION)
            OPTIONAL MATCH (finding)-[:HAS_ARTIFACT]->(dlp_class:DLP_ORIGINAL_CLASS | DLP_FINAL_CLASS)
            OPTIONAL MATCH (finding)-[final_prompt_artifact:HAS_ARTIFACT]->(final_prompt:DLP_FINAL_PROMPT)
            OPTIONAL MATCH (finding)-[original_prompt_artifact:HAS_ARTIFACT]->(original_prompt:DLP_ORIGINAL_PROMPT)
            
            WITH
                app,
                action,
                finding,
                dlp_class,
                interaction,
                final_prompt_artifact,
                original_prompt_artifact
            
            WHERE dlp_class IS NOT NULL
            
            WITH 
                finding.id AS findingId,
                finding.status AS status,
                finding.generationTime as eventTime,
                finding.justification as justification,
                COLLECT(DISTINCT dlp_class.id) as sensitiveClasses,
                CASE 
                    WHEN action IS NOT NULL THEN action.name 
                    ELSE NULL
                END as actionName,
                {
                    original: {
                        message: original_prompt_artifact.artifactValue,
                        time: apoc.date.format(original_prompt_artifact.timestamp, 'ms', 'yyyy-MM-dd HH:mm:ss')
                    },
                    interaction: {
                        message: interaction.quilr_message,
                        time: apoc.date.format(interaction.timestamp, 'ms', 'yyyy-MM-dd HH:mm:ss')
                    },
                    final: {
                        message: final_prompt_artifact.artifactValue,
                        time: apoc.date.format(final_prompt_artifact.timestamp, 'ms', 'yyyy-MM-dd HH:mm:ss')
                    }
                } as promptDetails,
                CASE 
                    WHEN app.totalScore IN [1, 2] THEN 'Very High'
                    WHEN app.totalScore IN [3, 4] THEN 'High'
                    WHEN app.totalScore IN [5, 6] THEN 'Moderate'
                    WHEN app.totalScore IN [7, 8] THEN 'Low'
                    WHEN app.totalScore IN [9, 10] THEN 'Very Low'
                    ELSE 'Unknown'
                END AS appRiskLevel
            
            RETURN DISTINCT
                findingId,
                apoc.date.format(eventTime, 'ms', 'yyyy-MM-dd HH:mm:ss') as eventTime,
                justification,
                sensitiveClasses,
                actionName,
                promptDetails as prompt,
                status,
                appRiskLevel
            ORDER BY eventTime DESC"
    input_params:
      appId: $appId
      behavior: $behavior
      accountId: $accountId
    dataSourceType: "knowledgegraph"
    enabled: true
    allowed_params: true
    sortOrder: ""
    sortColumn: ""
    name: "Users Leaking Sensitive Data Detailed"
    position: null
    template: null
    className: null
    multi_value_params:
      - id: appId
        delimiter: ","
    pagination_query: "MATCH (app:APPLICATION)
            WHERE app.id_ IN [$appId]
            MATCH (app)<-[:USING_APP]-(account:ACCOUNT {id: $accountId, subscriber: $subscriber, tenant: $tenant})
            MATCH (account)-[:HAS_FINDING]->(finding:FINDING | FINDING_HISTORY)

            OPTIONAL MATCH (finding)-[:TRIGGERED]->(action:ACTION)
            OPTIONAL MATCH (action)-[:RESULTED_IN]-(outcome:OUTCOME)
            OPTIONAL MATCH (action)-[]->(interaction:INTERACTION)
            OPTIONAL MATCH (finding)-[:HAS_ARTIFACT]->(dlp_class:DLP_ORIGINAL_CLASS | DLP_FINAL_CLASS)
            OPTIONAL MATCH (finding)-[final_prompt_artifact:HAS_ARTIFACT]->(final_prompt:DLP_FINAL_PROMPT)
            OPTIONAL MATCH (finding)-[original_prompt_artifact:HAS_ARTIFACT]->(original_prompt:DLP_ORIGINAL_PROMPT)
            
            WITH
                app,
                action,
                finding,
                dlp_class,
                interaction,
                final_prompt_artifact,
                original_prompt_artifact
            
            WHERE dlp_class IS NOT NULL
            
            WITH 
                finding.id AS findingId,
                finding.status AS status,
                finding.generationTime as eventTime,
                finding.justification as justification,
                COLLECT(DISTINCT dlp_class.id) as sensitiveClasses,
                CASE 
                    WHEN action IS NOT NULL THEN action.name 
                    ELSE NULL
                END as actionName,
                {
                    original: {
                        message: original_prompt_artifact.artifactValue,
                        time: apoc.date.format(original_prompt_artifact.timestamp, 'ms', 'yyyy-MM-dd HH:mm:ss')
                    },
                    interaction: {
                        message: interaction.quilr_message,
                        time: apoc.date.format(interaction.timestamp, 'ms', 'yyyy-MM-dd HH:mm:ss')
                    },
                    final: {
                        message: final_prompt_artifact.artifactValue,
                        time: apoc.date.format(final_prompt_artifact.timestamp, 'ms', 'yyyy-MM-dd HH:mm:ss')
                    }
                } as promptDetails,
                CASE 
                    WHEN app.totalScore IN [1, 2] THEN 'Very High'
                    WHEN app.totalScore IN [3, 4] THEN 'High'
                    WHEN app.totalScore IN [5, 6] THEN 'Moderate'
                    WHEN app.totalScore IN [7, 8] THEN 'Low'
                    WHEN app.totalScore IN [9, 10] THEN 'Very Low'
                    ELSE 'Unknown'
                END AS appRiskLevel

                RETURN
                    COUNT(DISTINCT findingId) as  totalCount"
  - id: BID_04_detailed
    multi_value_params:
      - id: appId
        delimiter: ","
      - id: group
        delimiter: ","
      - id: department
        delimiter: ","
      - id: criticality
        delimiter: ","
      - id: approval_status
        delimiter: ","
      - id: appname
        delimiter: ","
      - id: app_category
        delimiter: ","
    query: "MATCH (app:APPLICATION)
            WHERE app.id_ IN [$appId]
            MATCH (account:ACCOUNT {subscriber: $subscriber, tenant: $tenant})-[:USING_APP]->(app)
            MATCH (email:EMAIL)-[auth_type]->(account)
            MATCH (user:USER)-[:HAS_EMAIL]->(email) 
            MATCH (finding:FINDING)<-[:HAS_FINDING]-(account)
            MATCH (finding)<-[:EVALUATED_TO]-(rule:RULE)-[:BELONGS_TO]->(behavior:BEHAVIOR {id: $behavior})

            WITH app, account, COLLECT(DISTINCT auth_type) AS auth_types, email, user, finding, rule, 
            datetime.truncate('day', datetime() - duration('P1M')).epochMillis AS one_month_ago_epoch

            OPTIONAL MATCH (finding)-[:TRIGGERED]->(action:ACTION)
            OPTIONAL MATCH (action)-[:RESULTED_IN]-(outcome:OUTCOME)
            OPTIONAL MATCH (finding)-[:HAS_ARTIFACT]->(dlp:DLP_FINAL_CLASS | DLP_ORIGINAL_CLASS)
            OPTIONAL MATCH (action)-[:HAS_INTERACTION]->(interaction:INTERACTION)

            WITH app, account, auth_types, email, user, rule, one_month_ago_epoch, dlp, 
            {actioned: COUNT(DISTINCT CASE WHEN action IS NOT NULL THEN finding.id END),
                pending: COUNT(DISTINCT CASE WHEN action IS NULL THEN finding.id END)} AS actionStatus, 
            COLLECT({
                 findingId: finding.id,
                 rule: rule.name, 
                 action: action.name,
                 outcomeDesc: outcome.description,
                 actionDesc: action.description,
                 interaction: CASE WHEN interaction IS NOT NULL THEN true ELSE false END
            }) AS findingData

            WITH app, account, auth_types, email, user, one_month_ago_epoch, findingData, actionStatus, 
                rule, dlp,
                ANY(data IN findingData WHERE data.interaction IS NOT NULL AND data.interaction) AS interactionsExist,
                apoc.map.fromPairs(apoc.coll.flatten(COLLECT(DISTINCT [
                   data IN findingData | [data.action, COALESCE(data.outcomeDesc, data.actionDesc)]
               ]))) AS actionCurrentState

            WITH app, account, auth_types, email, user, one_month_ago_epoch, actionStatus, 
                actionCurrentState, findingData, dlp, 
                interactionsExist

            OPTIONAL MATCH (app)-[:HAS_GRANT]->(grant:GRANT)-[:HAS_SCOPE]->(scope:SCOPE)
            WHERE scope.severity IN ['High', 'Medium', 'Low']
            WITH app, account, auth_types, email, user, actionStatus, actionCurrentState, 
                interactionsExist,
                one_month_ago_epoch, dlp, 
                COLLECT(DISTINCT CASE WHEN scope.severity = 'High' THEN scope.name END) AS highSeverityScopes,
                COLLECT(DISTINCT scope.severity) AS severityList,
                apoc.map.fromPairs(
                    CASE 
                        WHEN interactionsExist IS NOT NULL AND interactionsExist 
                        THEN [data IN findingData WHERE data.interaction IS NOT NULL AND data.interaction | [data.rule, true]]
                        ELSE []
                    END
                ) AS ruleInteractionMap

            OPTIONAL MATCH (app)-[has:HAS_APP_SETTINGS]-(tenant:TENANT {id: $tenant})
            OPTIONAL MATCH (user)-[:HAS_DEPARTMENT]->(department:DEPARTMENT)
            OPTIONAL MATCH (user)-[:BELONGS_TO]->(group:GROUP {userDefined: true})
            OPTIONAL MATCH (app)-[:HAS_APP_CATEGORY]->(app_category:APP_CATEGORY)

            WITH app, account, auth_types, email, user, actionStatus, actionCurrentState, 
                interactionsExist, 
                ruleInteractionMap, 
                one_month_ago_epoch, dlp, 
                highSeverityScopes, severityList, has, department, group, app_category,
                (EXISTS((app)-[:WHITELISTED_FOR {tenant: $tenant}]->(:BEHAVIOR {id: $behavior})) OR EXISTS((account)-[:WHITELISTED_FOR]->(:BEHAVIOR {id: $behavior}))) AS is_whitelisted,
                apoc.coll.min([auth in auth_types | auth.creationTime]) AS firstAccessed,
                apoc.coll.max([auth in auth_types | auth.last_access_time]) AS lastAccessed
    
                WHERE toLower(user.displayName) CONTAINS toLower('{searchText}') OR toLower(email.id) CONTAINS toLower('{searchText}')
                {placeholder}

            RETURN DISTINCT
                email.id AS userMail,
                user.displayName AS userName,
                COALESCE(app.name, app.domain, app.id) AS appName,
                user.profilePicUrl AS userProfilePicUrl,
                COLLECT(DISTINCT department.name) AS departments,
                is_whitelisted,
                account.id AS accountId,
                app.id_ as appId,
                app.logoUrl AS appLogoUrl,
                COLLECT(DISTINCT app_category.name) AS appCategories,
                has.approval_status AS appStatus,
                actionStatus,
                actionCurrentState,
                firstAccessed,
                lastAccessed,
                CASE 
                    WHEN COUNT(dlp.id) = 0 THEN 'No Sensitive Data Shared' 
                    ELSE COLLECT(DISTINCT dlp.id) 
                END AS sensitiveDataClasses,
                CASE
                    WHEN size(highSeverityScopes) = 0 THEN 'No High Risk Oauth Scopes'
                    ELSE highSeverityScopes
                END AS highSeverityScopes,
                CASE
                    WHEN 'High' IN severityList THEN 'High'
                    WHEN 'Medium' IN severityList THEN 'Medium'
                    WHEN 'Low' IN severityList THEN 'Low'
                END AS severityRisk,
                interactionsExist,
                ruleInteractionMap, 
                firstAccessed < one_month_ago_epoch AS newlyDiscovered
            ORDER BY lastAccessed DESC"
    input_params:
      appId: $appId
      behavior: $behavior
      group: AND toLower(group.displayName) = toLower($group)
      department: AND toLower(department.name) = toLower($department)
      appname: AND toLower(COALESCE(app.name, app.domain, app.id)) = toLower($appname)
      app_category: AND toLower(app_category.name) = toLower($app_category)
      criticality: AND toLower(COALESCE(has.criticality, app.criticality)) = toLower($criticality)
      approval_status: AND toLower(has.approval_status) = toLower($approval_status)
    dataSourceType: "knowledgegraph"
    enabled: true
    allowed_params: true
    sortOrder: ""
    sortColumn: ""
    name: "Unapproved AI Applications Used Detailed"
    position: null
    template: null
    className: null
    pagination_query: "MATCH (app:APPLICATION)
            WHERE app.id_ IN [$appId]
            MATCH (app)<-[using_app:USING_APP]-(account:ACCOUNT {subscriber: $subscriber, tenant: $tenant})
            MATCH (account)<-[auth_type]-(email:EMAIL)
            MATCH (email)<-[:HAS_EMAIL]-(user:USER)
            MATCH (account)-[:HAS_FINDING]->(finding:FINDING)
            MATCH (finding)<-[:EVALUATED_TO]-(rule:RULE)-[:BELONGS_TO]->(behavior:BEHAVIOR {id: $behavior})

            OPTIONAL MATCH (app)-[:HAS_GRANT]->(grant:GRANT)-[:HAS_SCOPE]->(scope:SCOPE)
            WHERE scope.severity IN ['High', 'Medium', 'Low']

            OPTIONAL MATCH (app)-[has:HAS_APP_SETTINGS]-(tenant:TENANT {id: $tenant})
            OPTIONAL MATCH (user)-[:HAS_DEPARTMENT]->(department:DEPARTMENT)
            OPTIONAL MATCH (user)-[:BELONGS_TO]->(group:GROUP {userDefined: true})
            OPTIONAL MATCH (app)-[:HAS_APP_CATEGORY]->(app_category:APP_CATEGORY)

            OPTIONAL MATCH (finding)-[:TRIGGERED]->(action:ACTION)
            OPTIONAL MATCH (action)-[:RESULTED_IN]-(outcome:OUTCOME)
            OPTIONAL MATCH (action)-[:HAS_INTERACTION]->(interaction:INTERACTION)
            OPTIONAL MATCH (finding)-[:HAS_ARTIFACT]->(dlp:DLP_FINAL_CLASS | DLP_ORIGINAL_CLASS)

            WITH app, has, group, department, app_category, account, auth_type, email, user, dlp,
                COLLECT(DISTINCT CASE WHEN scope.severity = 'High' THEN scope.name END) AS highSeverityScopes,
                COUNT(scope.severity) AS severityCount,
                COLLECT(DISTINCT scope.severity) AS severityList,
                datetime.truncate('day', datetime() - duration('P1M')).epochMillis AS one_month_ago_epoch,
                {actioned: COUNT(DISTINCT CASE WHEN action IS NOT NULL THEN finding.id END),
                    pending: COUNT(DISTINCT CASE WHEN action IS NULL THEN finding.id END)} AS actionStatus,
                apoc.map.fromPairs(COLLECT(DISTINCT
                    [action.name, CASE WHEN outcome IS NOT NULL THEN outcome.description ELSE action.description END]
                )) AS actionCurrentState,
                EXISTS {
                    MATCH (action)-[:HAS_INTERACTION]->(:INTERACTION)
                } AS interactionsExist
                
            WHERE toLower(user.displayName) CONTAINS toLower('{searchText}') OR toLower(email.id) CONTAINS toLower('{searchText}')
            {placeholder}

            RETURN DISTINCT
                COUNT(DISTINCT account.id) AS totalCount"
  - id: BID_21_detailed
    multi_value_params:
      - id: appId
        delimiter: ","
      - id: group
        delimiter: ","
      - id: department
        delimiter: ","
      - id: criticality
        delimiter: ","
      - id: approval_status
        delimiter: ","
      - id: appname
        delimiter: ","
      - id: app_category
        delimiter: ","
    query: "MATCH (app:APPLICATION)
            WHERE app.id_ IN [$appId]
            MATCH (account:ACCOUNT {subscriber: $subscriber, tenant: $tenant})-[:USING_APP]->(app)
            MATCH (email:EMAIL)-[auth_type]->(account)
            MATCH (user:USER)-[:HAS_EMAIL]->(email) 
            MATCH (finding:FINDING)<-[:HAS_FINDING]-(account)
            MATCH (finding)<-[:EVALUATED_TO]-(rule:RULE)-[:BELONGS_TO]->(behavior:BEHAVIOR {id: $behavior})

            WITH app, account, COLLECT(DISTINCT auth_type) AS auth_types, email, user, finding, rule, 
            datetime.truncate('day', datetime() - duration('P1M')).epochMillis AS one_month_ago_epoch

            OPTIONAL MATCH (finding)-[:TRIGGERED]->(action:ACTION)
            OPTIONAL MATCH (action)-[:RESULTED_IN]-(outcome:OUTCOME)
            OPTIONAL MATCH (finding)-[:HAS_ARTIFACT]->(dlp:DLP_FINAL_CLASS | DLP_ORIGINAL_CLASS)
            OPTIONAL MATCH (action)-[:HAS_INTERACTION]->(interaction:INTERACTION)

            WITH app, account, auth_types, email, user, rule, one_month_ago_epoch, dlp, 
            {actioned: COUNT(DISTINCT CASE WHEN action IS NOT NULL THEN finding.id END),
                pending: COUNT(DISTINCT CASE WHEN action IS NULL THEN finding.id END)} AS actionStatus, 
            COLLECT({
                 findingId: finding.id,
                 rule: rule.name, 
                 action: action.name,
                 outcomeDesc: outcome.description,
                 actionDesc: action.description,
                 interaction: CASE WHEN interaction IS NOT NULL THEN true ELSE false END
            }) AS findingData

            WITH app, account, auth_types, email, user, one_month_ago_epoch, findingData, actionStatus, 
                rule, dlp,
                ANY(data IN findingData WHERE data.interaction IS NOT NULL AND data.interaction) AS interactionsExist,
                apoc.map.fromPairs(apoc.coll.flatten(COLLECT(DISTINCT [
                   data IN findingData | [data.action, COALESCE(data.outcomeDesc, data.actionDesc)]
               ]))) AS actionCurrentState

            WITH app, account, auth_types, email, user, one_month_ago_epoch, actionStatus, 
                actionCurrentState, findingData, dlp, 
                interactionsExist

            OPTIONAL MATCH (app)-[:HAS_GRANT]->(grant:GRANT)-[:HAS_SCOPE]->(scope:SCOPE)
            WHERE scope.severity IN ['High', 'Medium', 'Low']
            WITH app, account, auth_types, email, user, actionStatus, actionCurrentState, 
                interactionsExist,
                one_month_ago_epoch, dlp, 
                COLLECT(DISTINCT CASE WHEN scope.severity = 'High' THEN scope.name END) AS highSeverityScopes,
                COLLECT(DISTINCT scope.severity) AS severityList,
                apoc.map.fromPairs(
                    CASE 
                        WHEN interactionsExist IS NOT NULL AND interactionsExist 
                        THEN [data IN findingData WHERE data.interaction IS NOT NULL AND data.interaction | [data.rule, true]]
                        ELSE []
                    END
                ) AS ruleInteractionMap

            OPTIONAL MATCH (app)-[has:HAS_APP_SETTINGS]-(tenant:TENANT {id: $tenant})
            OPTIONAL MATCH (user)-[:HAS_DEPARTMENT]->(department:DEPARTMENT)
            OPTIONAL MATCH (user)-[:BELONGS_TO]->(group:GROUP {userDefined: true})
            OPTIONAL MATCH (app)-[:HAS_APP_CATEGORY]->(app_category:APP_CATEGORY)

            WITH app, account, auth_types, email, user, actionStatus, actionCurrentState, 
                interactionsExist, 
                ruleInteractionMap, 
                one_month_ago_epoch, dlp, 
                highSeverityScopes, severityList, has, department, group, app_category,
                (EXISTS((app)-[:WHITELISTED_FOR {tenant: $tenant}]->(:BEHAVIOR {id: $behavior})) OR EXISTS((account)-[:WHITELISTED_FOR]->(:BEHAVIOR {id: $behavior}))) AS is_whitelisted,
                apoc.coll.min([auth in auth_types | auth.creationTime]) AS firstAccessed,
                apoc.coll.max([auth in auth_types | auth.last_access_time]) AS lastAccessed
    
                WHERE toLower(user.displayName) CONTAINS toLower('{searchText}') OR toLower(email.id) CONTAINS toLower('{searchText}')
                {placeholder}

            RETURN DISTINCT
                email.id AS userMail,
                user.displayName AS userName,
                COALESCE(app.name, app.domain, app.id) AS appName,
                user.profilePicUrl AS userProfilePicUrl,
                COLLECT(DISTINCT department.name) AS departments,
                is_whitelisted,
                account.id AS accountId,
                app.id_ as appId,
                app.logoUrl AS appLogoUrl,
                COLLECT(DISTINCT app_category.name) AS appCategories,
                has.approval_status AS appStatus,
                actionStatus,
                actionCurrentState,
                firstAccessed,
                lastAccessed,
                CASE 
                    WHEN COUNT(dlp.id) = 0 THEN 'No Sensitive Data Shared' 
                    ELSE COLLECT(DISTINCT dlp.id) 
                END AS sensitiveDataClasses,
                CASE
                    WHEN size(highSeverityScopes) = 0 THEN 'No High Risk Oauth Scopes'
                    ELSE highSeverityScopes
                END AS highSeverityScopes,
                CASE
                    WHEN 'High' IN severityList THEN 'High'
                    WHEN 'Medium' IN severityList THEN 'Medium'
                    WHEN 'Low' IN severityList THEN 'Low'
                END AS severityRisk,
                interactionsExist,
                ruleInteractionMap, 
                firstAccessed < one_month_ago_epoch AS newlyDiscovered
            ORDER BY lastAccessed DESC"
    input_params:
      appId: $appId
      behavior: $behavior
      group: AND toLower(group.displayName) = toLower($group)
      department: AND toLower(department.name) = toLower($department)
      appname: AND toLower(COALESCE(app.name, app.domain, app.id)) = toLower($appname)
      app_category: AND toLower(app_category.name) = toLower($app_category)
      criticality: AND toLower(COALESCE(has.criticality, app.criticality)) = toLower($criticality)
      approval_status: AND toLower(has.approval_status) = toLower($approval_status)
    dataSourceType: "knowledgegraph"
    enabled: true
    allowed_params: true
    sortOrder: ""
    sortColumn: ""
    name: "Blocked AI Applications Used Detailed"
    position: null
    template: null
    className: null
    pagination_query: "MATCH (app:APPLICATION)
            WHERE app.id_ IN [$appId]
            MATCH (app)<-[using_app:USING_APP]-(account:ACCOUNT {subscriber: $subscriber, tenant: $tenant})
            MATCH (account)<-[auth_type]-(email:EMAIL)
            MATCH (email)<-[:HAS_EMAIL]-(user:USER)
            MATCH (account)-[:HAS_FINDING]->(finding:FINDING)
            MATCH (finding)<-[:EVALUATED_TO]-(rule:RULE)-[:BELONGS_TO]->(behavior:BEHAVIOR {id: $behavior})

            OPTIONAL MATCH (app)-[:HAS_GRANT]->(grant:GRANT)-[:HAS_SCOPE]->(scope:SCOPE)
            WHERE scope.severity IN ['High', 'Medium', 'Low']

            OPTIONAL MATCH (app)-[has:HAS_APP_SETTINGS]-(tenant:TENANT {id: $tenant})
            OPTIONAL MATCH (user)-[:HAS_DEPARTMENT]->(department:DEPARTMENT)
            OPTIONAL MATCH (user)-[:BELONGS_TO]->(group:GROUP {userDefined: true})
            OPTIONAL MATCH (app)-[:HAS_APP_CATEGORY]->(app_category:APP_CATEGORY)

            OPTIONAL MATCH (finding)-[:TRIGGERED]->(action:ACTION)
            OPTIONAL MATCH (action)-[:RESULTED_IN]-(outcome:OUTCOME)
            OPTIONAL MATCH (action)-[:HAS_INTERACTION]->(interaction:INTERACTION)
            OPTIONAL MATCH (finding)-[:HAS_ARTIFACT]->(dlp:DLP_FINAL_CLASS | DLP_ORIGINAL_CLASS)

            WITH app, has, group, department, app_category, account, auth_type, email, user, dlp,
                COLLECT(DISTINCT CASE WHEN scope.severity = 'High' THEN scope.name END) AS highSeverityScopes,
                COUNT(scope.severity) AS severityCount,
                COLLECT(DISTINCT scope.severity) AS severityList,
                datetime.truncate('day', datetime() - duration('P1M')).epochMillis AS one_month_ago_epoch,
                {actioned: COUNT(DISTINCT CASE WHEN action IS NOT NULL THEN finding.id END),
                    pending: COUNT(DISTINCT CASE WHEN action IS NULL THEN finding.id END)} AS actionStatus,
                apoc.map.fromPairs(COLLECT(DISTINCT
                    [action.name, CASE WHEN outcome IS NOT NULL THEN outcome.description ELSE action.description END]
                )) AS actionCurrentState,
                EXISTS {
                    MATCH (action)-[:HAS_INTERACTION]->(:INTERACTION)
                } AS interactionsExist
                
            WHERE toLower(user.displayName) CONTAINS toLower('{searchText}') OR toLower(email.id) CONTAINS toLower('{searchText}')
            {placeholder}

            RETURN DISTINCT
                COUNT(DISTINCT account.id) AS totalCount"
  - id: BID_17_detailed
    query: "MATCH (app:APPLICATION)
            WHERE app.id_ IN [$appId]
            MATCH (account:ACCOUNT {subscriber: $subscriber, tenant: $tenant})-[:USING_APP]->(app)
            MATCH (email:EMAIL)-[auth_type]->(account)
            MATCH (user:USER)-[:HAS_EMAIL]->(email) 
            MATCH (finding:FINDING)<-[:HAS_FINDING]-(account)
            MATCH (finding)<-[:EVALUATED_TO]-(rule:RULE)-[:BELONGS_TO]->(behavior:BEHAVIOR {id: $behavior})

            WITH app, account, COLLECT(DISTINCT auth_type) AS auth_types, email, user, finding, rule, 
            datetime.truncate('day', datetime() - duration('P1M')).epochMillis AS one_month_ago_epoch

            OPTIONAL MATCH (finding)-[:TRIGGERED]->(action:ACTION)
            OPTIONAL MATCH (action)-[:RESULTED_IN]-(outcome:OUTCOME)
            OPTIONAL MATCH (finding)-[:HAS_ARTIFACT]->(dlp:DLP_FINAL_CLASS | DLP_ORIGINAL_CLASS)
            OPTIONAL MATCH (action)-[:HAS_INTERACTION]->(interaction:INTERACTION)

            WITH app, account, auth_types, email, user, rule, one_month_ago_epoch, dlp, 
            {actioned: COUNT(DISTINCT CASE WHEN action IS NOT NULL THEN finding.id END),
                pending: COUNT(DISTINCT CASE WHEN action IS NULL THEN finding.id END)} AS actionStatus, 
            COLLECT({
                 findingId: finding.id,
                 rule: rule.name, 
                 action: action.name,
                 outcomeDesc: outcome.description,
                 actionDesc: action.description,
                 interaction: CASE WHEN interaction IS NOT NULL THEN true ELSE false END
            }) AS findingData

            WITH app, account, auth_types, email, user, one_month_ago_epoch, findingData, 
                rule, dlp, actionStatus,
                ANY(data IN findingData WHERE data.interaction IS NOT NULL AND data.interaction) AS interactionsExist,
                apoc.map.fromPairs(apoc.coll.flatten(COLLECT(DISTINCT [
                   data IN findingData | [data.action, COALESCE(data.outcomeDesc, data.actionDesc)]
               ]))) AS actionCurrentState

            WITH app, account, auth_types, email, user, one_month_ago_epoch, actionStatus, 
                actionCurrentState, findingData, dlp, 
                interactionsExist

            OPTIONAL MATCH (app)-[:HAS_GRANT]->(grant:GRANT)-[:HAS_SCOPE]->(scope:SCOPE)
            WHERE scope.severity IN ['High', 'Medium', 'Low']
            WITH app, account, auth_types, email, user, actionStatus, actionCurrentState, 
                interactionsExist,
                one_month_ago_epoch, dlp, 
                COLLECT(DISTINCT CASE WHEN scope.severity = 'High' THEN scope.name END) AS highSeverityScopes,
                COLLECT(DISTINCT scope.severity) AS severityList,
                apoc.map.fromPairs(
                    CASE 
                        WHEN interactionsExist IS NOT NULL AND interactionsExist 
                        THEN [data IN findingData WHERE data.interaction IS NOT NULL AND data.interaction | [data.rule, true]]
                        ELSE []
                    END
                ) AS ruleInteractionMap

            OPTIONAL MATCH (app)-[has:HAS_APP_SETTINGS]-(tenant:TENANT {id: $tenant})
            OPTIONAL MATCH (user)-[:HAS_DEPARTMENT]->(department:DEPARTMENT)
            OPTIONAL MATCH (user)-[:BELONGS_TO]->(group:GROUP {userDefined: true})
            OPTIONAL MATCH (app)-[:HAS_APP_CATEGORY]->(app_category:APP_CATEGORY)

            WITH app, account, auth_types, email, user, actionStatus, actionCurrentState, 
                interactionsExist, 
                ruleInteractionMap, 
                one_month_ago_epoch, dlp, 
                highSeverityScopes, severityList, has, department, group, app_category,
                (EXISTS((app)-[:WHITELISTED_FOR {tenant: $tenant}]->(:BEHAVIOR {id: $behavior})) OR EXISTS((account)-[:WHITELISTED_FOR]->(:BEHAVIOR {id: $behavior}))) AS is_whitelisted,
                apoc.coll.min([auth in auth_types | auth.creationTime]) AS firstAccessed,
                apoc.coll.max([auth in auth_types | auth.last_access_time]) AS lastAccessed
    
                WHERE toLower(user.displayName) CONTAINS toLower('{searchText}') OR toLower(email.id) CONTAINS toLower('{searchText}')
                {placeholder}

            RETURN DISTINCT
                email.id AS userMail,
                user.displayName AS userName,
                COALESCE(app.name, app.domain, app.id) AS appName,
                user.profilePicUrl AS userProfilePicUrl,
                COLLECT(DISTINCT department.name) AS departments,
                is_whitelisted,
                account.id AS accountId,
                app.id_ as appId,
                app.logoUrl AS appLogoUrl,
                COLLECT(DISTINCT app_category.name) AS appCategories,
                has.approval_status AS appStatus,
                actionStatus,
                actionCurrentState,
                firstAccessed,
                lastAccessed,
                CASE 
                    WHEN COUNT(dlp.id) = 0 THEN 'No Sensitive Data Shared' 
                    ELSE COLLECT(DISTINCT dlp.id) 
                END AS sensitiveDataClasses,
                CASE
                    WHEN size(highSeverityScopes) = 0 THEN 'No High Risk Oauth Scopes'
                    ELSE highSeverityScopes
                END AS highSeverityScopes,
                CASE
                    WHEN 'High' IN severityList THEN 'High'
                    WHEN 'Medium' IN severityList THEN 'Medium'
                    WHEN 'Low' IN severityList THEN 'Low'
                END AS severityRisk,
                interactionsExist,
                ruleInteractionMap, 
                firstAccessed < one_month_ago_epoch AS newlyDiscovered
            ORDER BY lastAccessed DESC"
    input_params:
      appId: $appId
      behavior: $behavior
      accountId: $accountId
      group: AND toLower(group.displayName) IN [ x IN [$group] | toLower(x) ]
      department: AND toLower(department.name) IN [ x IN [$deparment] | toLower(x) ]
      appname: AND toLower(COALESCE(app.name, app.domain, app.id)) IN [ x IN [$appname] | toLower(x) ]
      app_category: AND toLower(app_category.name) IN [ x IN [$app_category] | toLower(x) ]
      criticality: AND toLower(COALESCE(has.criticality, app.criticality)) IN [ x IN [$criticality] | toLower(x) ]
      approval_status: AND toLower(has.approval_status) IN [ x IN [$approval_status] | toLower(x) ]
    dataSourceType: "knowledgegraph"
    enabled: true
    allowed_params: true
    sortOrder: ""
    sortColumn: ""
    name: "Newly Introduced AI Apps Detailed"
    position: null
    template: null
    className: null
    multi_value_params:
      - id: appId
        delimiter: ","
      - id: group
        delimiter: ","
      - id: department
        delimiter: ","
      - id: criticality
        delimiter: ","
      - id: approval_status
        delimiter: ","
      - id: appname
        delimiter: ","
      - id: app_category
        delimiter: ","
    pagination_query: "MATCH (app:APPLICATION)
            WHERE app.id_ IN [$appId]
            MATCH (app)<-[using_app:USING_APP]-(account:ACCOUNT {subscriber: $subscriber, tenant: $tenant})
            MATCH (account)<-[auth_type]-(email:EMAIL)
            MATCH (email)<-[:HAS_EMAIL]-(user:USER)
            MATCH (account)-[:HAS_FINDING]->(finding:FINDING)
            MATCH (finding)<-[:EVALUATED_TO]-(rule:RULE)-[:BELONGS_TO]->(behavior:BEHAVIOR {id: $behavior})
            
            OPTIONAL MATCH (app)-[:HAS_GRANT]->(grant:GRANT)-[:HAS_SCOPE]->(scope:SCOPE)
            WHERE scope.severity IN ['High', 'Medium', 'Low']
            
            OPTIONAL MATCH (app)-[has:HAS_APP_SETTINGS]-(tenant:TENANT {id: $tenant})
            OPTIONAL MATCH (user)-[:HAS_DEPARTMENT]->(department:DEPARTMENT)
            OPTIONAL MATCH (user)-[:BELONGS_TO]->(group:GROUP {userDefined: true})
            OPTIONAL MATCH (app)-[:HAS_APP_CATEGORY]->(app_category:APP_CATEGORY)
            
            OPTIONAL MATCH (finding)-[:TRIGGERED]->(action:ACTION)
            OPTIONAL MATCH (action)-[:RESULTED_IN]-(outcome:OUTCOME)
            OPTIONAL MATCH (action)-[:HAS_INTERACTION]->(interaction:INTERACTION)
            OPTIONAL MATCH (finding)-[:HAS_ARTIFACT]->(dlp:DLP_FINAL_CLASS | DLP_ORIGINAL_CLASS)
            
            WITH app, has, group, department, app_category, account, auth_type, email, user, dlp, rule,
                COLLECT(DISTINCT CASE WHEN scope.severity = 'High' THEN scope.name END) AS highSeverityScopes,
                COUNT(scope.severity) AS severityCount,
                COLLECT(DISTINCT scope.severity) AS severityList,
                datetime.truncate('day', datetime() - duration('P1M')).epochMillis AS one_month_ago_epoch,
                {actioned: COUNT(DISTINCT CASE WHEN action IS NOT NULL THEN finding.id END),
                    pending: COUNT(DISTINCT CASE WHEN action IS NULL THEN finding.id END)} AS actionStatus,
                apoc.map.fromPairs(COLLECT(DISTINCT
                    [action.name, CASE WHEN outcome IS NOT NULL THEN outcome.description ELSE action.description END]
                )) AS actionCurrentState,
                EXISTS {
                    MATCH (action)-[:HAS_INTERACTION]->(:INTERACTION)
                } AS interactionsExist,
                (EXISTS((app)-[:WHITELISTED_FOR]->(:BEHAVIOR {id: $behavior})) OR EXISTS((account)-[:WHITELISTED_FOR]->(:BEHAVIOR {id: $behavior}))) AS is_whitelisted

            WHERE toLower(user.displayName) CONTAINS toLower('{searchText}') OR toLower(email.id) CONTAINS toLower('{searchText}')
            {placeholder}

            RETURN 
                COUNT(DISTINCT account.id) AS totalCount"
  - id: BID_21_detailed
    multi_value_params:
      - id: appId
        delimiter: ","
      - id: group
        delimiter: ","
      - id: department
        delimiter: ","
      - id: criticality
        delimiter: ","
      - id: approval_status
        delimiter: ","
      - id: appname
        delimiter: ","
      - id: app_category
        delimiter: ","
    query: "MATCH (app:APPLICATION)
            WHERE app.id_ IN [$appId]
            MATCH (account:ACCOUNT {subscriber: $subscriber, tenant: $tenant})-[:USING_APP]->(app)
            MATCH (email:EMAIL)-[auth_type]->(account)
            MATCH (user:USER)-[:HAS_EMAIL]->(email) 
            MATCH (finding:FINDING)<-[:HAS_FINDING]-(account)
            MATCH (finding)<-[:EVALUATED_TO]-(rule:RULE)-[:BELONGS_TO]->(behavior:BEHAVIOR {id: $behavior})

            WITH app, account, COLLECT(DISTINCT auth_type) AS auth_types, email, user, finding, rule, 
            datetime.truncate('day', datetime() - duration('P1M')).epochMillis AS one_month_ago_epoch

            OPTIONAL MATCH (finding)-[:TRIGGERED]->(action:ACTION)
            OPTIONAL MATCH (action)-[:RESULTED_IN]-(outcome:OUTCOME)
            OPTIONAL MATCH (finding)-[:HAS_ARTIFACT]->(dlp:DLP_FINAL_CLASS | DLP_ORIGINAL_CLASS)
            OPTIONAL MATCH (action)-[:HAS_INTERACTION]->(interaction:INTERACTION)

            WITH app, account, auth_types, email, user, rule, one_month_ago_epoch, dlp, 
            {actioned: COUNT(DISTINCT CASE WHEN action IS NOT NULL THEN finding.id END),
                pending: COUNT(DISTINCT CASE WHEN action IS NULL THEN finding.id END)} AS actionStatus, 
            COLLECT({
                 findingId: finding.id,
                 rule: rule.name, 
                 action: action.name,
                 outcomeDesc: outcome.description,
                 actionDesc: action.description,
                 interaction: CASE WHEN interaction IS NOT NULL THEN true ELSE false END
            }) AS findingData

            WITH app, account, auth_types, email, user, one_month_ago_epoch, findingData, actionStatus, 
                rule, dlp,
                ANY(data IN findingData WHERE data.interaction IS NOT NULL AND data.interaction) AS interactionsExist,
                apoc.map.fromPairs(apoc.coll.flatten(COLLECT(DISTINCT [
                   data IN findingData | [data.action, COALESCE(data.outcomeDesc, data.actionDesc)]
               ]))) AS actionCurrentState

            WITH app, account, auth_types, email, user, one_month_ago_epoch, actionStatus, 
                actionCurrentState, findingData, dlp, 
                interactionsExist

            OPTIONAL MATCH (app)-[:HAS_GRANT]->(grant:GRANT)-[:HAS_SCOPE]->(scope:SCOPE)
            WHERE scope.severity IN ['High', 'Medium', 'Low']
            WITH app, account, auth_types, email, user, actionStatus, actionCurrentState, 
                interactionsExist,
                one_month_ago_epoch, dlp, 
                COLLECT(DISTINCT CASE WHEN scope.severity = 'High' THEN scope.name END) AS highSeverityScopes,
                COLLECT(DISTINCT scope.severity) AS severityList,
                apoc.map.fromPairs(
                    CASE 
                        WHEN interactionsExist IS NOT NULL AND interactionsExist 
                        THEN [data IN findingData WHERE data.interaction IS NOT NULL AND data.interaction | [data.rule, true]]
                        ELSE []
                    END
                ) AS ruleInteractionMap

            OPTIONAL MATCH (app)-[has:HAS_APP_SETTINGS]-(tenant:TENANT {id: $tenant})
            OPTIONAL MATCH (user)-[:HAS_DEPARTMENT]->(department:DEPARTMENT)
            OPTIONAL MATCH (user)-[:BELONGS_TO]->(group:GROUP {userDefined: true})
            OPTIONAL MATCH (app)-[:HAS_APP_CATEGORY]->(app_category:APP_CATEGORY)

            WITH app, account, auth_types, email, user, actionStatus, actionCurrentState, 
                interactionsExist, 
                ruleInteractionMap, 
                one_month_ago_epoch, dlp, 
                highSeverityScopes, severityList, has, department, group, app_category,
                (EXISTS((app)-[:WHITELISTED_FOR {tenant: $tenant}]->(:BEHAVIOR {id: $behavior})) OR EXISTS((account)-[:WHITELISTED_FOR]->(:BEHAVIOR {id: $behavior}))) AS is_whitelisted,
                apoc.coll.min([auth in auth_types | auth.creationTime]) AS firstAccessed,
                apoc.coll.max([auth in auth_types | auth.last_access_time]) AS lastAccessed
    
                WHERE toLower(user.displayName) CONTAINS toLower('{searchText}') OR toLower(email.id) CONTAINS toLower('{searchText}')
                {placeholder}

            RETURN DISTINCT
                email.id AS userMail,
                user.displayName AS userName,
                COALESCE(app.name, app.domain, app.id) AS appName,
                user.profilePicUrl AS userProfilePicUrl,
                COLLECT(DISTINCT department.name) AS departments,
                is_whitelisted,
                account.id AS accountId,
                app.id_ as appId,
                app.logoUrl AS appLogoUrl,
                COLLECT(DISTINCT app_category.name) AS appCategories,
                has.approval_status AS appStatus,
                actionStatus,
                actionCurrentState,
                firstAccessed,
                lastAccessed,
                CASE 
                    WHEN COUNT(dlp.id) = 0 THEN 'No Sensitive Data Shared' 
                    ELSE COLLECT(DISTINCT dlp.id) 
                END AS sensitiveDataClasses,
                CASE
                    WHEN size(highSeverityScopes) = 0 THEN 'No High Risk Oauth Scopes'
                    ELSE highSeverityScopes
                END AS highSeverityScopes,
                CASE
                    WHEN 'High' IN severityList THEN 'High'
                    WHEN 'Medium' IN severityList THEN 'Medium'
                    WHEN 'Low' IN severityList THEN 'Low'
                END AS severityRisk,
                interactionsExist,
                ruleInteractionMap, 
                firstAccessed < one_month_ago_epoch AS newlyDiscovered
            ORDER BY lastAccessed DESC"
    input_params:
      appId: $appId
      behavior: $behavior
      group: AND toLower(group.displayName) = toLower($group)
      department: AND toLower(department.name) = toLower($department)
      appname: AND toLower(COALESCE(app.name, app.domain, app.id)) = toLower($appname)
      app_category: AND toLower(app_category.name) = toLower($app_category)
      criticality: AND toLower(COALESCE(has.criticality, app.criticality)) = toLower($criticality)
      approval_status: AND toLower(has.approval_status) = toLower($approval_status)
    dataSourceType: "knowledgegraph"
    enabled: true
    allowed_params: true
    sortOrder: ""
    sortColumn: ""
    name: "Blocked AI Apps Drilldown Table"
    position: null
    template: null
    className: null
    pagination_query: "MATCH (app:APPLICATION)
            WHERE app.id_ IN [$appId]
            MATCH (app)<-[using_app:USING_APP]-(account:ACCOUNT {subscriber: $subscriber, tenant: $tenant})
            MATCH (account)<-[auth_type]-(email:EMAIL)
            MATCH (email)<-[:HAS_EMAIL]-(user:USER)
            MATCH (account)-[:HAS_FINDING]->(finding:FINDING)
            MATCH (finding)<-[:EVALUATED_TO]-(rule:RULE)-[:BELONGS_TO]->(behavior:BEHAVIOR {id: $behavior})

            OPTIONAL MATCH (app)-[:HAS_GRANT]->(grant:GRANT)-[:HAS_SCOPE]->(scope:SCOPE)
            WHERE scope.severity IN ['High', 'Medium', 'Low']

            OPTIONAL MATCH (app)-[has:HAS_APP_SETTINGS]-(tenant:TENANT {id: $tenant})
            OPTIONAL MATCH (user)-[:HAS_DEPARTMENT]->(department:DEPARTMENT)
            OPTIONAL MATCH (user)-[:BELONGS_TO]->(group:GROUP {userDefined: true})
            OPTIONAL MATCH (app)-[:HAS_APP_CATEGORY]->(app_category:APP_CATEGORY)

            OPTIONAL MATCH (finding)-[:TRIGGERED]->(action:ACTION)
            OPTIONAL MATCH (action)-[:RESULTED_IN]-(outcome:OUTCOME)
            OPTIONAL MATCH (action)-[:HAS_INTERACTION]->(interaction:INTERACTION)
            OPTIONAL MATCH (finding)-[:HAS_ARTIFACT]->(dlp:DLP_FINAL_CLASS | DLP_ORIGINAL_CLASS)

            WITH app, has, group, department, app_category, account, auth_type, email, user, dlp,
                COLLECT(DISTINCT CASE WHEN scope.severity = 'High' THEN scope.name END) AS highSeverityScopes,
                COUNT(scope.severity) AS severityCount,
                COLLECT(DISTINCT scope.severity) AS severityList,
                datetime.truncate('day', datetime() - duration('P1M')).epochMillis AS one_month_ago_epoch,
                {actioned: COUNT(DISTINCT CASE WHEN action IS NOT NULL THEN finding.id END),
                    pending: COUNT(DISTINCT CASE WHEN action IS NULL THEN finding.id END)} AS actionStatus,
                apoc.map.fromPairs(COLLECT(DISTINCT
                    [action.name, CASE WHEN outcome IS NOT NULL THEN outcome.description ELSE action.description END]
                )) AS actionCurrentState,
                EXISTS {
                    MATCH (action)-[:HAS_INTERACTION]->(:INTERACTION)
                } AS interactionsExist
                
            WHERE toLower(user.displayName) CONTAINS toLower('{searchText}') OR toLower(email.id) CONTAINS toLower('{searchText}')
            {placeholder}

            RETURN DISTINCT
                COUNT(DISTINCT account.id) AS totalCount"
  - id: BID_21_detailed
    multi_value_params:
      - id: appId
        delimiter: ","
      - id: group
        delimiter: ","
      - id: department
        delimiter: ","
      - id: criticality
        delimiter: ","
      - id: approval_status
        delimiter: ","
      - id: appname
        delimiter: ","
      - id: app_category
        delimiter: ","
    query: "MATCH (app:APPLICATION)
            WHERE app.id_ IN [$appId]
            MATCH (account:ACCOUNT {subscriber: $subscriber, tenant: $tenant})-[:USING_APP]->(app)
            MATCH (email:EMAIL)-[auth_type]->(account)
            MATCH (user:USER)-[:HAS_EMAIL]->(email) 
            MATCH (finding:FINDING)<-[:HAS_FINDING]-(account)
            MATCH (finding)<-[:EVALUATED_TO]-(rule:RULE)-[:BELONGS_TO]->(behavior:BEHAVIOR {id: $behavior})

            WITH app, account, COLLECT(DISTINCT auth_type) AS auth_types, email, user, finding, rule, 
            datetime.truncate('day', datetime() - duration('P1M')).epochMillis AS one_month_ago_epoch

            OPTIONAL MATCH (finding)-[:TRIGGERED]->(action:ACTION)
            OPTIONAL MATCH (action)-[:RESULTED_IN]-(outcome:OUTCOME)
            OPTIONAL MATCH (finding)-[:HAS_ARTIFACT]->(dlp:DLP_FINAL_CLASS | DLP_ORIGINAL_CLASS)
            OPTIONAL MATCH (action)-[:HAS_INTERACTION]->(interaction:INTERACTION)

            WITH app, account, auth_types, email, user, rule, one_month_ago_epoch, dlp, 
            {actioned: COUNT(DISTINCT CASE WHEN action IS NOT NULL THEN finding.id END),
                pending: COUNT(DISTINCT CASE WHEN action IS NULL THEN finding.id END)} AS actionStatus, 
            COLLECT({
                 findingId: finding.id,
                 rule: rule.name, 
                 action: action.name,
                 outcomeDesc: outcome.description,
                 actionDesc: action.description,
                 interaction: CASE WHEN interaction IS NOT NULL THEN true ELSE false END
            }) AS findingData

            WITH app, account, auth_types, email, user, one_month_ago_epoch, findingData, actionStatus, 
                rule, dlp,
                ANY(data IN findingData WHERE data.interaction IS NOT NULL AND data.interaction) AS interactionsExist,
                apoc.map.fromPairs(apoc.coll.flatten(COLLECT(DISTINCT [
                   data IN findingData | [data.action, COALESCE(data.outcomeDesc, data.actionDesc)]
               ]))) AS actionCurrentState

            WITH app, account, auth_types, email, user, one_month_ago_epoch, actionStatus, 
                actionCurrentState, findingData, dlp, 
                interactionsExist

            OPTIONAL MATCH (app)-[:HAS_GRANT]->(grant:GRANT)-[:HAS_SCOPE]->(scope:SCOPE)
            WHERE scope.severity IN ['High', 'Medium', 'Low']
            WITH app, account, auth_types, email, user, actionStatus, actionCurrentState, 
                interactionsExist,
                one_month_ago_epoch, dlp, 
                COLLECT(DISTINCT CASE WHEN scope.severity = 'High' THEN scope.name END) AS highSeverityScopes,
                COLLECT(DISTINCT scope.severity) AS severityList,
                apoc.map.fromPairs(
                    CASE 
                        WHEN interactionsExist IS NOT NULL AND interactionsExist 
                        THEN [data IN findingData WHERE data.interaction IS NOT NULL AND data.interaction | [data.rule, true]]
                        ELSE []
                    END
                ) AS ruleInteractionMap

            OPTIONAL MATCH (app)-[has:HAS_APP_SETTINGS]-(tenant:TENANT {id: $tenant})
            OPTIONAL MATCH (user)-[:HAS_DEPARTMENT]->(department:DEPARTMENT)
            OPTIONAL MATCH (user)-[:BELONGS_TO]->(group:GROUP {userDefined: true})
            OPTIONAL MATCH (app)-[:HAS_APP_CATEGORY]->(app_category:APP_CATEGORY)

            WITH app, account, auth_types, email, user, actionStatus, actionCurrentState, 
                interactionsExist, 
                ruleInteractionMap, 
                one_month_ago_epoch, dlp, 
                highSeverityScopes, severityList, has, department, group, app_category,
                (EXISTS((app)-[:WHITELISTED_FOR {tenant: $tenant}]->(:BEHAVIOR {id: $behavior})) OR EXISTS((account)-[:WHITELISTED_FOR]->(:BEHAVIOR {id: $behavior}))) AS is_whitelisted,
                apoc.coll.min([auth in auth_types | auth.creationTime]) AS firstAccessed,
                apoc.coll.max([auth in auth_types | auth.last_access_time]) AS lastAccessed
    
                WHERE toLower(user.displayName) CONTAINS toLower('{searchText}') OR toLower(email.id) CONTAINS toLower('{searchText}')
                {placeholder}

            RETURN DISTINCT
                email.id AS userMail,
                user.displayName AS userName,
                COALESCE(app.name, app.domain, app.id) AS appName,
                user.profilePicUrl AS userProfilePicUrl,
                COLLECT(DISTINCT department.name) AS departments,
                is_whitelisted,
                account.id AS accountId,
                app.id_ as appId,
                app.logoUrl AS appLogoUrl,
                COLLECT(DISTINCT app_category.name) AS appCategories,
                has.approval_status AS appStatus,
                actionStatus,
                actionCurrentState,
                firstAccessed,
                lastAccessed,
                CASE 
                    WHEN COUNT(dlp.id) = 0 THEN 'No Sensitive Data Shared' 
                    ELSE COLLECT(DISTINCT dlp.id) 
                END AS sensitiveDataClasses,
                CASE
                    WHEN size(highSeverityScopes) = 0 THEN 'No High Risk Oauth Scopes'
                    ELSE highSeverityScopes
                END AS highSeverityScopes,
                CASE
                    WHEN 'High' IN severityList THEN 'High'
                    WHEN 'Medium' IN severityList THEN 'Medium'
                    WHEN 'Low' IN severityList THEN 'Low'
                END AS severityRisk,
                interactionsExist,
                ruleInteractionMap, 
                firstAccessed < one_month_ago_epoch AS newlyDiscovered
            ORDER BY lastAccessed DESC"
    input_params:
      appId: $appId
      behavior: $behavior
      group: AND toLower(group.displayName) = toLower($group)
      department: AND toLower(department.name) = toLower($department)
      appname: AND toLower(COALESCE(app.name, app.domain, app.id)) = toLower($appname)
      app_category: AND toLower(app_category.name) = toLower($app_category)
      criticality: AND toLower(COALESCE(has.criticality, app.criticality)) = toLower($criticality)
      approval_status: AND toLower(has.approval_status) = toLower($approval_status)
    dataSourceType: "knowledgegraph"
    enabled: true
    allowed_params: true
    sortOrder: ""
    sortColumn: ""
    name: "Blocked AI Apps Drilldown Table"
    position: null
    template: null
    className: null
    pagination_query: "MATCH (app:APPLICATION)
            WHERE app.id_ IN [$appId]
            MATCH (app)<-[using_app:USING_APP]-(account:ACCOUNT {subscriber: $subscriber, tenant: $tenant})
            MATCH (account)<-[auth_type]-(email:EMAIL)
            MATCH (email)<-[:HAS_EMAIL]-(user:USER)
            MATCH (account)-[:HAS_FINDING]->(finding:FINDING)
            MATCH (finding)<-[:EVALUATED_TO]-(rule:RULE)-[:BELONGS_TO]->(behavior:BEHAVIOR {id: $behavior})

            OPTIONAL MATCH (app)-[:HAS_GRANT]->(grant:GRANT)-[:HAS_SCOPE]->(scope:SCOPE)
            WHERE scope.severity IN ['High', 'Medium', 'Low']

            OPTIONAL MATCH (app)-[has:HAS_APP_SETTINGS]-(tenant:TENANT {id: $tenant})
            OPTIONAL MATCH (user)-[:HAS_DEPARTMENT]->(department:DEPARTMENT)
            OPTIONAL MATCH (user)-[:BELONGS_TO]->(group:GROUP {userDefined: true})
            OPTIONAL MATCH (app)-[:HAS_APP_CATEGORY]->(app_category:APP_CATEGORY)

            OPTIONAL MATCH (finding)-[:TRIGGERED]->(action:ACTION)
            OPTIONAL MATCH (action)-[:RESULTED_IN]-(outcome:OUTCOME)
            OPTIONAL MATCH (action)-[:HAS_INTERACTION]->(interaction:INTERACTION)
            OPTIONAL MATCH (finding)-[:HAS_ARTIFACT]->(dlp:DLP_FINAL_CLASS | DLP_ORIGINAL_CLASS)

            WITH app, has, group, department, app_category, account, auth_type, email, user, dlp,
                COLLECT(DISTINCT CASE WHEN scope.severity = 'High' THEN scope.name END) AS highSeverityScopes,
                COUNT(scope.severity) AS severityCount,
                COLLECT(DISTINCT scope.severity) AS severityList,
                datetime.truncate('day', datetime() - duration('P1M')).epochMillis AS one_month_ago_epoch,
                {actioned: COUNT(DISTINCT CASE WHEN action IS NOT NULL THEN finding.id END),
                    pending: COUNT(DISTINCT CASE WHEN action IS NULL THEN finding.id END)} AS actionStatus,
                apoc.map.fromPairs(COLLECT(DISTINCT
                    [action.name, CASE WHEN outcome IS NOT NULL THEN outcome.description ELSE action.description END]
                )) AS actionCurrentState,
                EXISTS {
                    MATCH (action)-[:HAS_INTERACTION]->(:INTERACTION)
                } AS interactionsExist
                
            WHERE toLower(user.displayName) CONTAINS toLower('{searchText}') OR toLower(email.id) CONTAINS toLower('{searchText}')
            {placeholder}

            RETURN DISTINCT
                COUNT(DISTINCT account.id) AS totalCount"
  - id: BID_03_detailed_prompts
    query: "MATCH (account:ACCOUNT {id: $accountId, subscriber: $subscriber, tenant: $tenant})
            USING INDEX account:ACCOUNT(id, subscriber, tenant)
            MATCH (account)-[:USING_APP]->(app:APPLICATION {id_: $appId})
            USING INDEX app:APPLICATION(id_)
            MATCH (behavior:BEHAVIOR {id: 'BID_03'})<-[:BELONGS_TO]-(rule:RULE)
            USING INDEX behavior:BEHAVIOR(id)
            
            WITH account, app, behavior, rule
            MATCH (account)-[:HAS_FINDING]->(finding)
            WHERE (finding:FINDING OR finding:FINDING_HISTORY)
              AND (rule)-[:EVALUATED_TO]->(finding)
            
            OPTIONAL MATCH (finding)-[:TRIGGERED]->(action:ACTION)
            OPTIONAL MATCH (action)-[rel:HAS_INTERACTION|RESULTED_IN]->(io_node)
            WHERE io_node:INTERACTION OR io_node:OUTCOME
            
            CALL {
              WITH finding
              RETURN [
                [(finding)-[rel:HAS_ARTIFACT]->(art:DLP_ORIGINAL_PROMPT) | rel{.artifactValue, .timestamp}],
                [(finding)-[rel:HAS_ARTIFACT]->(art:DLP_ORIGINAL_EXTRACTION) WHERE rel.class <> '' | rel{.class}],
                [(finding)-[rel:HAS_ARTIFACT]->(art:DLP_FINAL_PROMPT) | rel{.artifactValue, .timestamp}],
                [(finding)-[rel:HAS_ARTIFACT]->(art:DLP_FINAL_EXTRACTION) WHERE rel.class <> '' | rel{.class}],
                [(finding)-[rel:HAS_ARTIFACT]->(art:DLP_ORIGINAL_CLASS) WHERE art.id <> '' | art{.id}],
                [(finding)-[rel:HAS_ARTIFACT]->(art:DLP_FINAL_CLASS) WHERE art.id <> '' | art{.id}]
              ] AS artifacts
            }
            
            WITH app, finding, action,
              COLLECT(io_node) AS io_node,
              [a IN artifacts[0] WHERE a IS NOT NULL] AS original_prompts,
              [a IN artifacts[1] WHERE a IS NOT NULL] AS original_extractions,
              [a IN artifacts[2] WHERE a IS NOT NULL] AS final_prompts,
              [a IN artifacts[3] WHERE a IS NOT NULL] AS final_extractions,
              artifacts[4] AS dlp_original_classes,
              artifacts[5] AS dlp_final_classes
            
            WHERE size(dlp_original_classes + dlp_final_classes) > 0
              AND size(original_extractions) > 0
            
            WITH 
              finding.id AS findingId,
              finding.name AS findingName,
              finding.status AS status,
              finding.generationTime AS eventTime,
              apoc.coll.toSet([c IN dlp_original_classes + dlp_final_classes | c.id]) AS sensitiveClasses,
              action.name AS actionName,
              action.context_id AS contextId,
              COALESCE(action.mode, finding.mode) AS mode,
              {
                original: {
                  message: head([op IN original_prompts | op.artifactValue]),
                  time: head([op IN original_prompts | op.timestamp]),
                  sensitive_classes: [oe IN original_extractions | oe.class]
                },
                interaction: {
                  system_message: head([i IN io_node WHERE i:INTERACTION AND i.initiator = 'system' | i.message]),
                  system_message_time: head([i IN io_node WHERE i:INTERACTION AND i.initiator = 'system' | i.messageTime]),
                  user_message: head([i IN io_node WHERE i:INTERACTION AND i.initiator = 'user' | i.message]),
                  user_message_time: head([i IN io_node WHERE i:INTERACTION AND i.initiator = 'user' | i.messageTime]),
                  outcome: head([o IN io_node WHERE o:OUTCOME | o.value])
                },
                final: {
                  message: head([fp IN final_prompts | fp.artifactValue]),
                  time: head([fp IN final_prompts | fp.timestamp]),
                  sensitive_classes: [fe IN final_extractions | fe.class]
                }
              } AS promptDetails,
              CASE
                WHEN app.totalScore IN [1, 2] THEN 'Very High'
                WHEN app.totalScore IN [3, 4] THEN 'High'
                WHEN app.totalScore IN [5, 6] THEN 'Moderate' 
                WHEN app.totalScore IN [7, 8] THEN 'Low'
                WHEN app.totalScore IN [9, 10] THEN 'Very Low'
                ELSE 'Unknown'
              END AS appRiskLevel
            
            RETURN DISTINCT
              findingId,
              findingName,
              eventTime,
              sensitiveClasses,
              actionName,
              contextId,
              mode,
              promptDetails AS prompt,
              status,
              appRiskLevel
            ORDER BY eventTime DESC"
    input_params:
      appId: $appId
      behavior: $behavior
      accountId: $accountId
    dataSourceType: "knowledgegraph"
    enabled: true
    allowed_params: true
    sortOrder: ""
    sortColumn: ""
    name: "Users Leaking Sensitive Data Detailed"
    position: null
    template: null
    className: null
    pagination_query: "MATCH (app:APPLICATION)
            WHERE app.id_ = $appId
            MATCH (app)<-[:USING_APP]-(account:ACCOUNT {id: $accountId, subscriber: $subscriber, tenant: $tenant})
            MATCH (account)-[:HAS_FINDING]->(finding:FINDING | FINDING_HISTORY)<-[]-(rule:RULE)-[]->(behavior:BEHAVIOR {id: 'BID_03'})
            
            OPTIONAL MATCH (finding)-[:TRIGGERED]->(action:ACTION)
            OPTIONAL MATCH (action)-[]->(interaction:INTERACTION)
            OPTIONAL MATCH (action)-[:RESULTED_IN]->(outcome:OUTCOME)
            OPTIONAL MATCH (finding)-[:HAS_ARTIFACT]->(dlp_class:DLP_ORIGINAL_CLASS | DLP_FINAL_CLASS)
            OPTIONAL MATCH (finding)-[original_prompt_artifact:HAS_ARTIFACT]->(original_prompt:DLP_ORIGINAL_PROMPT)
            OPTIONAL MATCH (finding)-[original_extraction_artifact:HAS_ARTIFACT]->(original_extraction:DLP_ORIGINAL_EXTRACTION)
            OPTIONAL MATCH (finding)-[final_prompt_artifact:HAS_ARTIFACT]->(final_prompt:DLP_FINAL_PROMPT)
            OPTIONAL MATCH (finding)-[final_extraction_artifact:HAS_ARTIFACT]->(final_extraction:DLP_FINAL_EXTRACTION)
            
            WITH
                app,
                action,
                finding,
                dlp_class,
                interaction,
                outcome,
                original_prompt_artifact,
                original_extraction_artifact,
                final_prompt_artifact,
                final_extraction_artifact
            
            WHERE dlp_class IS NOT NULL
                AND original_extraction_artifact IS NOT NULL 

            RETURN
                COUNT(DISTINCT finding.id) as  totalCount"
  - id: interactions_metadata
    query: "MATCH (account:ACCOUNT {id: $accountId, subscriber: $subscriber, tenant: $tenant})
            MATCH (email:EMAIL)-[auth_type]->(account)
            MATCH (user:USER)-[:HAS_EMAIL]->(email) 
            MATCH (finding:FINDING)<-[:HAS_FINDING]-(account)
            MATCH (finding)<-[:EVALUATED_TO]-(rule:RULE)-[:BELONGS_TO]->(behavior:BEHAVIOR {id: $behavior})

            OPTIONAL MATCH (finding)-[:TRIGGERED]->(action:ACTION)-[:HAS_INTERACTION]->(interaction:INTERACTION)
            WHERE interaction IS NOT NULL
            {placeholder}
                        
            WITH rule, interaction, action
            WHERE interaction IS NOT NULL 
              AND action IS NOT NULL
              AND interaction.messageTime IS NOT NULL
              AND btrim(COALESCE(interaction.message, apoc.text.join([interaction.header, interaction.title, interaction.description], ' '))) <> ''
              AND btrim(COALESCE(interaction.message, apoc.text.join([interaction.header, interaction.title, interaction.description], ' '))) IS NOT NULL
            
            RETURN DISTINCT 
                rule.name AS ruleName,
                btrim(COALESCE(interaction.message, apoc.text.join([interaction.header, interaction.title, interaction.description], ' '))) AS message,
                interaction.messageTime AS messageTime,
                interaction.initiator AS initiator, 
                action.name AS action, 
                interaction.channel AS channel, 
                interaction.mode AS mode
            ORDER BY interaction.messageTime ASC"
    input_params:
      behavior: $behavior
      accountId: $accountId
      ruleName: AND tolower(rule.name) = tolower($ruleName)
    dataSourceType: "knowledgegraph"
    enabled: true
    allowed_params: true
    sortOrder: ""
    sortColumn: ""
    requestType: POST
    name: "Interaction Metadata"
    position: null
    template: null
    className: null
    multi_value_params: []
    pagination_query: "MATCH (account:ACCOUNT {id: $accountId, subscriber: $subscriber, tenant: $tenant})
                       MATCH (email:EMAIL)-[auth_type]->(account)
                       MATCH (user:USER)-[:HAS_EMAIL]->(email) 
                       MATCH (finding:FINDING)<-[:HAS_FINDING]-(account)
                       MATCH (finding)<-[:EVALUATED_TO]-(rule:RULE)-[:BELONGS_TO]->(behavior:BEHAVIOR {id: $behavior})

                       OPTIONAL MATCH (finding)-[:TRIGGERED]->(action:ACTION)-[:HAS_INTERACTION]->(interaction:INTERACTION)
                       WHERE interaction IS NOT NULL
                       {placeholder}
                       
                       WITH rule, interaction, action
                       WHERE interaction IS NOT NULL 
                         AND action IS NOT NULL
                         AND interaction.messageTime IS NOT NULL
                         AND btrim(COALESCE(interaction.message, apoc.text.join([interaction.header, interaction.title, interaction.description], ' '))) <> ''
                         AND btrim(COALESCE(interaction.message, apoc.text.join([interaction.header, interaction.title, interaction.description], ' '))) IS NOT NULL
            
                       WITH DISTINCT 
                           rule.name AS ruleName,
                           btrim(COALESCE(interaction.message, apoc.text.join([interaction.header, interaction.title, interaction.description], ' '))) AS message,
                           interaction.messageTime AS messageTime,
                           interaction.initiator AS initiator, 
                           action.name AS action, 
                           interaction.channel AS channel, 
                           interaction.mode AS mode

                       RETURN COUNT(*) AS totalCount"
view_by:
  - id: BID_01
    query: "MATCH (user:USER {subscriber: $subscriber, tenant: $tenant})-[]-(email:EMAIL)-[acc_type:OAUTH_ACCOUNT]-(acc:ACCOUNT)-[:HAS_FINDING]-(finding:FINDING)-[]-(rule:RULE)-[]-(behavior:BEHAVIOR)-[]-(posture:POSTURE)
            WHERE behavior.id = $behavior
            MATCH (acc)-[:USING_APP]-(app:APPLICATION)-[:HAS_APP_CATEGORY]-(category:APP_CATEGORY)
            MATCH (app)-[:HAS_GRANT]-(grant:GRANT)-[:HAS_SCOPE]-(scope:SCOPE {severity: 'High'})
            
            OPTIONAL MATCH (app)-[:HAS_ADMIN]->(owner:ACCOUNT)
            OPTIONAL MATCH (app)-[hs:HAS_APP_SETTINGS]-(tenant:TENANT {id: $tenant})
            OPTIONAL MATCH (finding)-[:HAS_ARTIFACT]->(dlp:DLP_FINAL_CLASS | DLP_ORIGINAL_CLASS)
            OPTIONAL MATCH (finding)-[:TRIGGERED]-(action:ACTION)
            OPTIONAL MATCH (action)-[:RESULTED_IN]->(outcome:OUTCOME)
            
            WITH datetime.truncate('day', datetime() - duration('P1M')).epochMillis AS one_month_ago_epoch,
                MIN(CASE WHEN acc.creationTime = '-' THEN NULL ELSE acc.creationTime END) AS firstAccessTime,
                COALESCE(hs.approval_status, 'NEEDS REVIEW') AS status,
                COALESCE(action.name, '-') as actionName, COUNT(DISTINCT action.id) AS actionCount,
                CASE WHEN action IS NOT NULL AND outcome IS NULL THEN 'Not Responded'
                    WHEN outcome IS NOT NULL THEN COALESCE(outcome.value, outcome.message, '-')
                END as outcomeValue,
                COUNT(DISTINCT action.id) as outcomeCount,
                app, acc, hs, action, finding, owner, category, acc_type, scope, grant, dlp
            
            WITH one_month_ago_epoch, firstAccessTime, status, actionName, actionCount,
                apoc.map.fromPairs(COLLECT([outcomeValue, outcomeCount])) as outcomeMap,
                app, acc, hs, action, finding, owner, category, acc_type, scope, grant, dlp
            
            WHERE ( toLower(COALESCE(app.name, app.domain)) CONTAINS toLower('{searchText}') OR toLower(status) CONTAINS toLower('{searchText}') 
            OR toLower(category.name) CONTAINS toLower('{searchText}')
            OR toLower(COALESCE(app.criticality, 'Not Set')) CONTAINS toLower('{searchText}') )
            {placeholder}
            
            RETURN DISTINCT
                COALESCE(app.id_, app.internalId) AS id, 
                COALESCE(app.name, app.domain, app.id) AS app,
                status,
                COALESCE(hs.logoUrl, app.logoUrl) AS logo,
                COALESCE(hs.appCriticality, app.criticality, 'Not Set') AS criticality,
                COALESCE(firstAccessTime > one_month_ago_epoch, true) AS newlyDiscovered,
                {
                    actioned: COUNT(DISTINCT CASE WHEN action IS NOT NULL THEN finding.id END),
                    pending: COUNT(DISTINCT CASE WHEN action IS NULL THEN finding.id END)
                } AS reviewStatus,
                CASE 
                    WHEN app.totalScore IN [1, 2] THEN 'Very High'
                    WHEN app.totalScore IN [3, 4] THEN 'High'
                    WHEN app.totalScore IN [5, 6] THEN 'Moderate'
                    WHEN app.totalScore IN [7, 8] THEN 'Low'
                    WHEN app.totalScore IN [9, 10] THEN 'Very Low'
                    ELSE 'Unknown'
                END AS appRiskLevel,
                COLLECT(DISTINCT owner.email) AS appAdmins,
                COUNT(DISTINCT acc) AS accounts,
                COLLECT(DISTINCT {name: category.name, priority: category.priority}) AS categories,
                firstAccessTime,
                MAX(COALESCE(acc_type.last_access_time, 0)) AS lastAccessTime,
                COUNT(DISTINCT CASE WHEN finding IS NOT NULL THEN acc.id END) AS accountsWithFindings,
                COUNT(DISTINCT dlp) > 0 AS sensitiveData,
                COUNT(DISTINCT scope) > 0 AS riskyOauthScopes,
                grant.consentBy as grantedBy,
                grant.consentType as grantedType,
                apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, actionCount] END)) AS actionResults,
                apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, outcomeMap] END)) AS actionOutcomes"
    defaultValue:
    allowed_params: true
    name: AI Applications with Risky Scopes
    pagination_query: "MATCH (user:USER {subscriber: $subscriber, tenant: $tenant})-[]-(email:EMAIL)-[acc_type:OAUTH_ACCOUNT]-(acc:ACCOUNT)-[:HAS_FINDING]-(finding:FINDING)-[]-(rule:RULE)-[]-(behavior:BEHAVIOR)-[]-(posture:POSTURE)
            WHERE behavior.id = $behavior
            MATCH (acc)-[:USING_APP]-(app:APPLICATION)-[:HAS_APP_CATEGORY]-(category:APP_CATEGORY)
            MATCH (app)-[:HAS_GRANT]-(grant:GRANT)-[:HAS_SCOPE]-(scope:SCOPE {severity: 'High'})
            
            OPTIONAL MATCH (app)-[:HAS_ADMIN]->(owner:ACCOUNT)
            OPTIONAL MATCH (app)-[hs:HAS_APP_SETTINGS]-(tenant:TENANT {id: $tenant})
            OPTIONAL MATCH (finding)-[:HAS_ARTIFACT]->(dlp:DLP_FINAL_CLASS | DLP_ORIGINAL_CLASS)
            OPTIONAL MATCH (finding)-[:TRIGGERED]-(action:ACTION)
            OPTIONAL MATCH (action)-[:RESULTED_IN]->(outcome:OUTCOME)
            
            WITH datetime.truncate('day', datetime() - duration('P1M')).epochMillis AS one_month_ago_epoch,
                MIN(CASE WHEN acc.creationTime = '-' THEN NULL ELSE acc.creationTime END) AS firstAccessTime,
                COALESCE(hs.approval_status, 'NEEDS REVIEW') AS status,
                COALESCE(action.name, '-') as actionName, COUNT(DISTINCT action.id) AS actionCount,
                CASE WHEN action IS NOT NULL AND outcome IS NULL THEN 'Not Responded'
                    WHEN outcome IS NOT NULL THEN COALESCE(outcome.value, outcome.message, '-')
                END as outcomeValue,
                COUNT(DISTINCT action.id) as outcomeCount,
                app, acc, hs, action, finding, owner, category, acc_type, scope, grant, dlp
            
            WITH one_month_ago_epoch, firstAccessTime, status, actionName, actionCount,
                apoc.map.fromPairs(COLLECT([outcomeValue, outcomeCount])) as outcomeMap,
                app, acc, hs, action, finding, owner, category, acc_type, scope, grant, dlp
            
            WHERE ( toLower(COALESCE(app.name, app.domain)) CONTAINS toLower('{searchText}') OR toLower(status) CONTAINS toLower('{searchText}') 
            OR toLower(category.name) CONTAINS toLower('{searchText}')
            OR toLower(COALESCE(app.criticality, 'Not Set')) CONTAINS toLower('{searchText}') )
            {placeholder}
  
            RETURN 
                COUNT(DISTINCT COALESCE(app.id_, app.internalId)) AS totalCount"
    input_params:
      behavior: $behavior
      sensitive_data: AND sensitiveData = $sensitive_data
      risky_oauth_scopes: AND riskyOauthScopes = $risky_oauth_scopes
      risk_level: AND appRiskLevel = $risk_level
      criticality: AND toLower(COALESCE(hs.criticality, app.criticality)) = toLower($criticality)
      approval_status: AND toLower(status) = toLower($approval_status)
      number_of_account_greater_than: AND totalAccounts > $number_of_account_greater_than
      number_of_account_less_than: AND totalAccounts < $number_of_account_less_than
      technical_owner: AND appAdmin = $technical_owner
      newly_discovered: AND newlyDiscovered = $newly_discovered
      action_status: AND reviewStatus[toLower($action_status)] > 0
      oauth_scope_risk_level: AND toLower(scope.severity) = toLower($oauth_scope_risk_level)
      granted_by: AND toLower(grant.consentBy) = toLower($granted_by)
      grant_type: AND toLower(grant.consentType) = toLower($grant_type)
    type: widget
    dataSourceType: knowledgegraph
    active: false
  - id: BID_02
    query: "MATCH (app:APPLICATION)<-[using_app:USING_APP]-(account:ACCOUNT {subscriber: $subscriber, tenant: $tenant})
            MATCH (account)<-[auth_type]-(email:EMAIL)
            OPTIONAL MATCH (email)<-[:HAS_EMAIL]-(user:USER)
            MATCH (account)-[:HAS_FINDING]->(finding:FINDING)
            MATCH (finding)<-[:EVALUATED_TO]-(rule:RULE)-[:BELONGS_TO]->(behavior:BEHAVIOR {id: $behavior})

            OPTIONAL MATCH (app)-[:HAS_GRANT]->(grant:GRANT)-[:HAS_SCOPE]->(scope:SCOPE)
            WHERE scope.severity IN ['High', 'Medium', 'Low']

            OPTIONAL MATCH (finding)-[:TRIGGERED]->(action:ACTION)
            OPTIONAL MATCH (app)-[has:HAS_APP_SETTINGS]-(tenant:TENANT {id: $tenant})
            OPTIONAL MATCH (user)-[:HAS_DEPARTMENT]->(department:DEPARTMENT)
            OPTIONAL MATCH (app)-[:HAS_APP_CATEGORY]->(app_category:APP_CATEGORY)
            OPTIONAL MATCH (finding)-[:HAS_ARTIFACT]->(dlp:DLP_FINAL_CLASS | DLP_ORIGINAL_CLASS)
            OPTIONAL MATCH (user)-[:BELONGS_TO]->(group:GROUP {userDefined: true})

            WITH app, has, department, app_category, account, auth_type, email, user, dlp, scope, finding, group,
                COLLECT(DISTINCT CASE WHEN scope.severity = 'High' THEN scope.name END) AS highSeverityScopes,
                {actioned: COUNT(DISTINCT CASE WHEN action IS NOT NULL THEN finding.id END),
                    pending: COUNT(DISTINCT CASE WHEN action IS NULL THEN finding.id END)} AS actionStatus,
                EXISTS((account)-[:WHITELISTED_FOR]->(:BEHAVIOR {id: $behavior})) AS is_whitelisted

            WHERE (toLower(user.displayName) CONTAINS toLower('{searchText}') OR toLower(email.id) CONTAINS toLower('{searchText}'))
            {placeholder}

            RETURN DISTINCT
                email.id AS userMail,
                user.displayName AS userName,
                COLLECT(DISTINCT group.displayName) AS groups,
                account.id AS accountId,
                is_whitelisted,
                COALESCE(app.id_, app.internalId) AS appId,
                COALESCE(app.name, app.domain, app.id) AS appName,
                user.profilePicUrl AS userProfilePicUrl,
                COLLECT(DISTINCT department.name) AS departments,
                app.logoUrl AS appLogoUrl,
                COLLECT(DISTINCT app_category.name) AS appCategories,
                has.approval_status AS appStatus,
                actionStatus,
                MIN(account.creationTime) AS firstAccessed,
                MAX(auth_type.last_access_time) AS lastAccessed,
                CASE 
                    WHEN COUNT(dlp.id) > 0 THEN true
                    ELSE false
                END AS sensitiveDataShared,
                CASE
                    WHEN size(highSeverityScopes) > 0 THEN true
                    ELSE false
                END AS riskyOauthScopes
            ORDER BY lastAccessed DESC"
    defaultValue:
    allowed_params: true
    name: Newly Introduced AI Users
    pagination_query: "MATCH (app:APPLICATION)<-[using_app:USING_APP]-(account:ACCOUNT {subscriber: $subscriber, tenant: $tenant})
            MATCH (account)<-[auth_type]-(email:EMAIL)
            OPTIONAL MATCH (email)<-[:HAS_EMAIL]-(user:USER)
            MATCH (account)-[:HAS_FINDING]->(finding:FINDING)
            MATCH (finding)<-[:EVALUATED_TO]-(rule:RULE)-[:BELONGS_TO]->(behavior:BEHAVIOR {id: $behavior})

            OPTIONAL MATCH (app)-[:HAS_GRANT]->(grant:GRANT)-[:HAS_SCOPE]->(scope:SCOPE)
            WHERE scope.severity IN ['High', 'Medium', 'Low']

            OPTIONAL MATCH (finding)-[:TRIGGERED]->(action:ACTION)
            OPTIONAL MATCH (app)-[has:HAS_APP_SETTINGS]-(tenant:TENANT {id: $tenant})
            OPTIONAL MATCH (user)-[:HAS_DEPARTMENT]->(department:DEPARTMENT)
            OPTIONAL MATCH (app)-[:HAS_APP_CATEGORY]->(app_category:APP_CATEGORY)
            OPTIONAL MATCH (finding)-[:HAS_ARTIFACT]->(dlp:DLP_FINAL_CLASS | DLP_ORIGINAL_CLASS)
            OPTIONAL MATCH (user)-[:BELONGS_TO]->(group:GROUP {userDefined: true})

            WITH app, has, department, app_category, account, auth_type, email, user, dlp, scope, finding, group,
                COLLECT(DISTINCT CASE WHEN scope.severity = 'High' THEN scope.name END) AS highSeverityScopes,
                {actioned: COUNT(DISTINCT CASE WHEN action IS NOT NULL THEN finding.id END),
                    pending: COUNT(DISTINCT CASE WHEN action IS NULL THEN finding.id END)} AS actionStatus

            WHERE (toLower(user.displayName) CONTAINS toLower('{searchText}') OR toLower(email.id) CONTAINS toLower('{searchText}'))
            {placeholder}
            
            WITH DISTINCT account, email

            RETURN 
                COUNT(account.id) AS totalCount"
    input_params:
      behavior: $behavior
      sensitive_data: AND sensitiveData = $sensitive_data
      risky_oauth_scopes: AND riskyOauthScopes = $risky_oauth_scopes
      approval_status: AND toLower(status) = toLower($approval_status)
      action_status: AND CASE WHEN toLower($action_status) = 'actioned' THEN actionStatus['actioned'] > 0 ELSE actionStatus['actioned'] = 0 END
    type: widget
    dataSourceType: knowledgegraph
    active: true
  - id: BID_03
    query: "// Key fix: Proper linking of actions to their specific outcomes\n
            
            // OPTIMIZATION 1: Start with most selective filter to reduce working set early\n
            MATCH (behavior:BEHAVIOR {id: $behavior})<-[:BELONGS_TO]-(rule:RULE)
            MATCH (rule)-[:EVALUATED_TO]->(finding:FINDING | FINDING_HISTORY)            
            // OPTIMIZATION 2: Early parameter filtering to minimize graph traversal\n
            MATCH (finding)<-[:HAS_FINDING]-(account:ACCOUNT {subscriber: $subscriber, tenant: $tenant})
            
            // OPTIMIZATION 3: Direct relationships without intermediate variables where possible\n
            MATCH (account)-[using_app:USING_APP]->(app:APPLICATION)
            MATCH (account)<-[auth_type]-(email:EMAIL)<-[:HAS_EMAIL]-(user:USER)
            
            WHERE 
              CASE 
                WHEN '{searchText}' = '' THEN true
                ELSE (toLower(user.displayName) CONTAINS toLower('{searchText}') OR toLower(email.id) CONTAINS toLower ('{searchText}'))
              END
              {placeholder}
            
            // OPTIMIZATION 4: Collect high-severity scopes early with single traversal\n
            OPTIONAL MATCH (app)-[:HAS_GRANT]->(grant:GRANT)-[:HAS_SCOPE]->(scope:SCOPE)
            WHERE toLower(scope.severity) IN ['high', 'medium', 'low']
            
            // OPTIMIZATION 5: Group optional matches by relationship depth to reduce cartesian products\n
            OPTIONAL MATCH (finding)-[:TRIGGERED]->(action:ACTION)
            WHERE action.parentActionId IS NULL
            OPTIONAL MATCH (action)-[:RESULTED_IN]->(outcome:OUTCOME)
            
            // OPTIMIZATION 6: Batch remaining optional matches\n
            OPTIONAL MATCH (app)-[has:HAS_APP_SETTINGS]-(tenant:TENANT {id: $tenant})
            OPTIONAL MATCH (user)-[:HAS_DEPARTMENT]->(department:DEPARTMENT)
            OPTIONAL MATCH (app)-[:HAS_APP_CATEGORY]->(app_category:APP_CATEGORY)
            OPTIONAL MATCH (finding)-[:HAS_ARTIFACT]->(dlp:DLP_FINAL_CLASS | DLP_ORIGINAL_CLASS)
            OPTIONAL MATCH (user)-[:BELONGS_TO]->(group:GROUP {userDefined: true})
            
            // OPTIMIZATION 7: First aggregation - collect base data per user/app/finding\n
            // FIX: Create proper action-outcome pairs to maintain the relationship\n
            WITH 
                user, email, account, app, has, department, app_category, group,
                COLLECT(DISTINCT CASE WHEN toLower(scope.severity) = 'high' THEN scope.name END) AS highSeverityScopes,
                COLLECT(DISTINCT finding) as findings,
                COLLECT(DISTINCT action) as actions,
                COLLECT(DISTINCT outcome) as outcomes,
                COLLECT(DISTINCT dlp) as dlps,
                COLLECT(DISTINCT COALESCE(action.name, '-')) as actionNames,
                COLLECT(DISTINCT 
                    CASE 
                        WHEN action IS NOT NULL THEN {
                            actionName: COALESCE(action.name, '-'),
                            actionId: action.id,
                            outcomeValue: CASE 
                                WHEN outcome IS NOT NULL THEN COALESCE(outcome.value, outcome.message, '-')
                                WHEN action IS NOT NULL AND outcome IS NULL THEN 'User Not Responded'
                                ELSE NULL
                            END,
                            outcomeId: outcome.id
                        }
                        ELSE NULL
                    END
                ) as actionOutcomePairs
            
            // OPTIMIZATION 8: Final aggregation with proper count calculations\n
            WITH DISTINCT
                user.id AS userId,
                email.id AS userMail,
                user.displayName AS userName,
                user.profilePicUrl AS userProfilePicUrl,
                COLLECT(DISTINCT group.displayName) AS groups,
                account.id AS accountId,
                COALESCE(app.id_) AS appId,
                COALESCE(
                    CASE WHEN NOT app.name IN ['', '-'] THEN app.name ELSE NULL END, 
                    app.domain
                ) AS appName,
                app.logoUrl AS appLogoUrl,
                COLLECT(DISTINCT department.name) AS departments,
                COLLECT(DISTINCT app_category.name) AS appCategories,
                CASE 
                    WHEN COALESCE(has.approval_status, app.approval_status, 'NEEDS REVIEW') = '-' 
                    THEN 'NEEDS REVIEW' 
                    ELSE COALESCE(has.approval_status, app.approval_status, 'NEEDS REVIEW') 
                END AS appStatus,
                COALESCE(has.criticality, app.criticality, 'NOT SET') AS appCriticality,
                
                // Count findings with and without actions\n
                SIZE([f IN findings WHERE EXISTS {MATCH (f)-[:TRIGGERED]->(:ACTION)}]) AS actionedCount,
                SIZE([f IN findings WHERE NOT EXISTS {MATCH (f)-[:TRIGGERED]->(:ACTION)}]) AS pendingCount,
                
                // FIX: Build action results using distinct action IDs to avoid duplicates\n
                apoc.map.fromPairs([
                    actionName IN actionNames WHERE actionName IS NOT NULL |
                    [actionName, SIZE([pair IN actionOutcomePairs 
                                      WHERE pair IS NOT NULL AND pair.actionName = actionName 
                                      AND pair.actionId IS NOT NULL])]
                ]) AS actionResults,
                
                // FIX: Build action outcomes using proper action-outcome relationships\n
                apoc.map.fromPairs([
                    actionName IN actionNames WHERE actionName IS NOT NULL |
                    [actionName, apoc.map.fromPairs([
                        outcomeValue IN [pair IN actionOutcomePairs 
                                       WHERE pair IS NOT NULL AND pair.actionName = actionName 
                                       AND pair.outcomeValue IS NOT NULL | pair.outcomeValue] |
                        [outcomeValue, SIZE([pair IN actionOutcomePairs 
                                           WHERE pair IS NOT NULL 
                                           AND pair.actionName = actionName 
                                           AND pair.outcomeValue = outcomeValue
                                           AND (pair.outcomeId IS NOT NULL OR outcomeValue = 'User Not Responded')])]
                    ])]
                ]) AS actionOutcomes,
                
                MIN(account.creationTime) AS firstAccessed,
                apoc.coll.max([f IN findings | f.timestamp]) AS lastAccessed,
                SIZE(findings) AS totalFindingCount,
                
                // Handle sensitive data\n
                SIZE([d IN dlps WHERE d IS NOT NULL]) > 0 AS sensitiveData,
                apoc.map.fromPairs([
                    dlp IN dlps WHERE dlp IS NOT NULL |
                    [dlp.id, SIZE([d IN dlps WHERE d.id = dlp.id])]
                ]) AS sensitiveDataInfo,
                
                [x IN highSeverityScopes WHERE x IS NOT NULL] AS riskyOauthScopes,
                
                // Keep collections for final calculation\n
                findings, actions, outcomes, actionOutcomePairs
            
            // Final output with corrected structure\n
            RETURN
                userId,
                userMail,
                userName,
                groups,
                accountId,
                appId,
                appName,
                userProfilePicUrl,
                departments,
                appLogoUrl,
                appCategories,
                appStatus,
                appCriticality,
                {actioned: actionedCount, pending: pendingCount} AS actionStatus,
                actionResults,
                actionOutcomes,
                firstAccessed,
                lastAccessed,
                totalFindingCount,
                sensitiveData,
                sensitiveDataInfo,
                riskyOauthScopes
            
            ORDER BY lastAccessed DESC"
    defaultValue: null
    allowed_params: true
    name: Users leaking sensitive data
    pagination_query: "// Key fix: Proper linking of actions to their specific outcomes\n
    
            // OPTIMIZATION 1: Start with most selective filter to reduce working set early\n
            MATCH (behavior:BEHAVIOR {id: $behavior})<-[:BELONGS_TO]-(rule:RULE)
            MATCH (rule)-[:EVALUATED_TO]->(finding:FINDING | FINDING_HISTORY)
            
            // OPTIMIZATION 2: Early parameter filtering to minimize graph traversal\n
            MATCH (finding)<-[:HAS_FINDING]-(account:ACCOUNT {subscriber: $subscriber, tenant: $tenant})
            
            // OPTIMIZATION 3: Direct relationships without intermediate variables where possible\n
            MATCH (account)-[using_app:USING_APP]->(app:APPLICATION)
            MATCH (account)<-[auth_type]-(email:EMAIL)<-[:HAS_EMAIL]-(user:USER)
            
            WHERE 
              CASE 
                WHEN '{searchText}' = '' THEN true
                ELSE (toLower(user.displayName) CONTAINS toLower('{searchText}') OR toLower(email.id) CONTAINS toLower ('{searchText}'))
              END
              {placeholder}
            
            // OPTIMIZATION 4: Collect high-severity scopes early with single traversal\n
            OPTIONAL MATCH (app)-[:HAS_GRANT]->(grant:GRANT)-[:HAS_SCOPE]->(scope:SCOPE)
            WHERE toLower(scope.severity) IN ['high', 'medium', 'low']
            
            // OPTIMIZATION 5: Group optional matches by relationship depth to reduce cartesian products\n
            OPTIONAL MATCH (finding)-[:TRIGGERED]->(action:ACTION)
            WHERE action.parentActionId IS NULL
            OPTIONAL MATCH (action)-[:RESULTED_IN]->(outcome:OUTCOME)
            
            // OPTIMIZATION 6: Batch remaining optional matches\n
            OPTIONAL MATCH (app)-[has:HAS_APP_SETTINGS]-(tenant:TENANT {id: $tenant})
            OPTIONAL MATCH (user)-[:HAS_DEPARTMENT]->(department:DEPARTMENT)
            OPTIONAL MATCH (app)-[:HAS_APP_CATEGORY]->(app_category:APP_CATEGORY)
            OPTIONAL MATCH (finding)-[:HAS_ARTIFACT]->(dlp:DLP_FINAL_CLASS | DLP_ORIGINAL_CLASS)
            OPTIONAL MATCH (user)-[:BELONGS_TO]->(group:GROUP {userDefined: true})
            
            // OPTIMIZATION 7: First aggregation - collect base data per user/app/finding\n
            // FIX: Create proper action-outcome pairs to maintain the relationship\n
            WITH 
                user, email, account, app, has, department, app_category, group,
                COLLECT(DISTINCT CASE WHEN toLower(scope.severity) = 'high' THEN scope.name END) AS highSeverityScopes,
                COLLECT(DISTINCT finding) as findings,
                COLLECT(DISTINCT action) as actions,
                COLLECT(DISTINCT outcome) as outcomes,
                COLLECT(DISTINCT dlp) as dlps,
                COLLECT(DISTINCT COALESCE(action.name, '-')) as actionNames,
                COLLECT(DISTINCT 
                    CASE 
                        WHEN action IS NOT NULL THEN {
                            actionName: COALESCE(action.name, '-'),
                            actionId: action.id,
                            outcomeValue: CASE 
                                WHEN outcome IS NOT NULL THEN COALESCE(outcome.value, outcome.message, '-')
                                WHEN action IS NOT NULL AND outcome IS NULL THEN 'User Not Responded'
                                ELSE NULL
                            END,
                            outcomeId: outcome.id
                        }
                        ELSE NULL
                    END
                ) as actionOutcomePairs
            
            // OPTIMIZATION 8: Final aggregation with proper count calculations\n
            WITH DISTINCT
                user.id AS userId,
                email.id AS userMail,
                user.displayName AS userName,
                user.profilePicUrl AS userProfilePicUrl,
                COLLECT(DISTINCT group.displayName) AS groups,
                account.id AS accountId,
                COALESCE(app.id_) AS appId,
                COALESCE(
                    CASE WHEN NOT app.name IN ['', '-'] THEN app.name ELSE NULL END, 
                    app.domain
                ) AS appName,
                app.logoUrl AS appLogoUrl,
                COLLECT(DISTINCT department.name) AS departments,
                COLLECT(DISTINCT app_category.name) AS appCategories,
                CASE 
                    WHEN COALESCE(has.approval_status, app.approval_status, 'NEEDS REVIEW') = '-' 
                    THEN 'NEEDS REVIEW' 
                    ELSE COALESCE(has.approval_status, app.approval_status, 'NEEDS REVIEW') 
                END AS appStatus,
                COALESCE(has.criticality, app.criticality, 'NOT SET') AS appCriticality,
                
                // Count findings with and without actions\n
                SIZE([f IN findings WHERE EXISTS {MATCH (f)-[:TRIGGERED]->(:ACTION)}]) AS actionedCount,
                SIZE([f IN findings WHERE NOT EXISTS {MATCH (f)-[:TRIGGERED]->(:ACTION)}]) AS pendingCount,
                
                // FIX: Build action results using distinct action IDs to avoid duplicates\n
                apoc.map.fromPairs([
                    actionName IN actionNames WHERE actionName IS NOT NULL |
                    [actionName, SIZE([pair IN actionOutcomePairs 
                                      WHERE pair IS NOT NULL AND pair.actionName = actionName 
                                      AND pair.actionId IS NOT NULL])]
                ]) AS actionResults,
                
                // FIX: Build action outcomes using proper action-outcome relationships\n
                apoc.map.fromPairs([
                    actionName IN actionNames WHERE actionName IS NOT NULL |
                    [actionName, apoc.map.fromPairs([
                        outcomeValue IN [pair IN actionOutcomePairs 
                                       WHERE pair IS NOT NULL AND pair.actionName = actionName 
                                       AND pair.outcomeValue IS NOT NULL | pair.outcomeValue] |
                        [outcomeValue, SIZE([pair IN actionOutcomePairs 
                                           WHERE pair IS NOT NULL 
                                           AND pair.actionName = actionName 
                                           AND pair.outcomeValue = outcomeValue
                                           AND (pair.outcomeId IS NOT NULL OR outcomeValue = 'User Not Responded')])]
                    ])]
                ]) AS actionOutcomes,
                
                MIN(account.creationTime) AS firstAccessed,
                apoc.coll.max([f IN findings | f.timestamp]) AS lastAccessed,
                SIZE(findings) AS totalFindingCount,
                
                // Handle sensitive data\n
                SIZE([d IN dlps WHERE d IS NOT NULL]) > 0 AS sensitiveData,
                apoc.map.fromPairs([
                    dlp IN dlps WHERE dlp IS NOT NULL |
                    [dlp.id, SIZE([d IN dlps WHERE d.id = dlp.id])]
                ]) AS sensitiveDataInfo,
                
                [x IN highSeverityScopes WHERE x IS NOT NULL] AS riskyOauthScopes,
                
                // Keep collections for final calculation\n
                findings, actions, outcomes, actionOutcomePairs

            RETURN
                COUNT(DISTINCT accountId) AS totalCount"
    input_params:
      behavior: $behavior
      sensitive_data: AND sensitiveData = $sensitive_data
      risky_oauth_scopes: AND riskyOauthScopes = $risky_oauth_scopes
      action_status: AND CASE WHEN toLower($action_status) = 'actioned' THEN actionStatus['actioned'] > 0 ELSE actionStatus['actioned'] = 0 END
      sensitive_data_classes: AND sensitiveDataInfo[$sensitive_data_classes] > 0
    type: widget
    dataSourceType: knowledgegraph
    active: true
  - id: BID_04
    query: "CALL {
              MATCH (email:EMAIL {subscriber: $subscriber, tenant: $tenant})-[AUTH_TYPE]->(account:ACCOUNT)
              OPTIONAL MATCH (u:USER)-[:HAS_EMAIL]->(email)
              MATCH (account)-[:USING_APP]->(app:APPLICATION)
              MATCH (account)-[:HAS_FINDING]->(finding:FINDING)
              MATCH (app)-[:HAS_APP_CATEGORY]->(category:APP_CATEGORY)
              MATCH (finding)<-[:EVALUATED_TO]-(rule:RULE)-[:BELONGS_TO]->(behavior:BEHAVIOR {id: $behavior})

              OPTIONAL MATCH (app)-[:HAS_ADMIN]->(owner:ACCOUNT)
              OPTIONAL MATCH (finding)-[:TRIGGERED]->(action:ACTION)
              OPTIONAL MATCH (action)-[:RESULTED_IN]->(outcome:OUTCOME)
              OPTIONAL MATCH (app)<-[hs:HAS_APP_SETTINGS]-(t:TENANT {id: $tenant})
              OPTIONAL MATCH (app)-[:HAS_GRANT]->(grant:GRANT)-[:HAS_SCOPE]->(scope:SCOPE {severity: 'High'})
              OPTIONAL MATCH (finding)-[:HAS_ARTIFACT]->(dlp:DLP_FINAL_CLASS | DLP_ORIGINAL_CLASS)

              WITH app, owner, account, AUTH_TYPE, hs, category, finding, action, dlp, scope,
              COALESCE(action.name, '-') AS actionName, COUNT(DISTINCT action.id) AS actionCount,
              CASE WHEN action IS NOT NULL AND outcome IS NULL THEN 'Not Responded'
                  WHEN outcome IS NOT NULL THEN COALESCE(outcome.value, outcome.message, '-')
              END as outcomeValue,
              COUNT(DISTINCT action.id) as outcomeCount

              WITH app, owner, account, AUTH_TYPE, hs, category, finding, action, dlp, scope,
              actionName, actionCount, apoc.map.fromPairs(COLLECT([outcomeValue, outcomeCount])) as outcomeMap

              RETURN 
                  app, 
                  owner.email AS appAdmin, 
                  COUNT(DISTINCT account) AS accounts, 
                  COLLECT(DISTINCT {name: category.name, priority: category.priority}) AS categories, 
                  MIN(CASE WHEN account.creationTime = '-' THEN NULL ELSE account.creationTime END) AS firstAccessTime,
                  MAX(COALESCE(AUTH_TYPE.last_access_time, 0)) AS lastAccessTime,  
                  COALESCE(hs.approval_status, 'NEEDS REVIEW') AS status, 
                  COALESCE(hs.logoUrl, app.logoUrl) AS logo, 
                  COUNT(DISTINCT CASE WHEN finding IS NOT NULL THEN account.id END) AS accountsWithFindings,
                  COUNT(DISTINCT dlp) > 0 AS sensitiveData, 
                  COUNT(DISTINCT scope) > 0 AS riskyOauthScopes,
                  apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, actionCount] END)) AS actionResults,
                  apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, outcomeMap] END)) AS actionOutcomes,
                  {actioned: COUNT(DISTINCT CASE WHEN action IS NOT NULL THEN finding.id END),
                      pending: COUNT(DISTINCT CASE WHEN action IS NULL THEN finding.id END)} AS reviewStatus,
                  CASE 
                      WHEN app.totalScore IN [1, 2] THEN 'Very High'
                      WHEN app.totalScore IN [3, 4] THEN 'High'
                      WHEN app.totalScore IN [5, 6] THEN 'Moderate'
                      WHEN app.totalScore IN [7, 8] THEN 'Low'
                      WHEN app.totalScore IN [9, 10] THEN 'Very Low'
                      ELSE 'Unknown'
                  END AS appRiskLevel
          }

          WITH app, appAdmin, appRiskLevel, categories, lastAccessTime, firstAccessTime, accountsWithFindings,
              status, logo, accounts AS totalAccounts, reviewStatus, sensitiveData, riskyOauthScopes,
              datetime.truncate('day', datetime() - duration('P1M')).epochMillis AS one_month_ago_epoch, actionResults, actionOutcomes

          WHERE toLower(COALESCE(app.name, app.domain)) CONTAINS toLower('{searchText}')
          {placeholder}

          RETURN DISTINCT
              COALESCE(app.id_, app.internalId) AS id, 
              COALESCE(app.name, app.domain, app.id) AS app, 
              appRiskLevel,
              COALESCE(app.criticality, 'Not Set') AS criticality, 
              status, 
              COALESCE(firstAccessTime > one_month_ago_epoch, true) AS newlyDiscovered,
              logo, 
              [cat IN categories WHERE cat.priority = 2 | cat.name] AS highPriorityCategories, 
              totalAccounts, 
              accountsWithFindings, 
              lastAccessTime, 
              firstAccessTime,
              reviewStatus,
              sensitiveData,
              riskyOauthScopes,
              actionResults,
              actionOutcomes
          ORDER BY lastAccessTime DESC"
    defaultValue: null
    allowed_params: true
    name: Unapproved AI Applications
    pagination_query: "CALL {
              MATCH (email:EMAIL {subscriber: $subscriber, tenant: $tenant})-[AUTH_TYPE]->(account:ACCOUNT)
              OPTIONAL MATCH (u:USER)-[:HAS_EMAIL]->(email)
              MATCH (account)-[:USING_APP]->(app:APPLICATION)
              MATCH (account)-[:HAS_FINDING]->(finding:FINDING)
              MATCH (app)-[:HAS_APP_CATEGORY]->(category:APP_CATEGORY)
              MATCH (finding)<-[:EVALUATED_TO]-(rule:RULE)-[:BELONGS_TO]->(behavior:BEHAVIOR {id: $behavior})

              OPTIONAL MATCH (app)-[:HAS_ADMIN]->(owner:ACCOUNT)
              OPTIONAL MATCH (finding)-[:TRIGGERED]->(action:ACTION)
              OPTIONAL MATCH (action)-[:RESULTED_IN]->(outcome:OUTCOME)
              OPTIONAL MATCH (app)<-[hs:HAS_APP_SETTINGS]-(t:TENANT {id: $tenant})
              OPTIONAL MATCH (app)-[:HAS_GRANT]->(grant:GRANT)-[:HAS_SCOPE]->(scope:SCOPE {severity: 'High'})
              OPTIONAL MATCH (finding)-[:HAS_ARTIFACT]->(dlp:DLP_FINAL_CLASS | DLP_ORIGINAL_CLASS)

              WITH app, owner, account, AUTH_TYPE, hs, category, finding, action, dlp, scope,
              COALESCE(action.name, '-') AS actionName, COUNT(DISTINCT action.id) AS actionCount,
              CASE WHEN action IS NOT NULL AND outcome IS NULL THEN 'Not Responded'
                  WHEN outcome IS NOT NULL THEN COALESCE(outcome.value, outcome.message, '-')
              END as outcomeValue,
              COUNT(DISTINCT action.id) as outcomeCount

              WITH app, owner, account, AUTH_TYPE, hs, category, finding, action, dlp, scope,
              actionName, actionCount, apoc.map.fromPairs(COLLECT([outcomeValue, outcomeCount])) as outcomeMap

              RETURN 
                  app, 
                  owner.email AS appAdmin, 
                  COUNT(DISTINCT account) AS accounts, 
                  COLLECT(DISTINCT {name: category.name, priority: category.priority}) AS categories, 
                  MIN(CASE WHEN account.creationTime = '-' THEN NULL ELSE account.creationTime END) AS firstAccessTime,
                  MAX(COALESCE(AUTH_TYPE.last_access_time, 0)) AS lastAccessTime,  
                  COALESCE(hs.approval_status, 'NEEDS REVIEW') AS status, 
                  COALESCE(hs.logoUrl, app.logoUrl) AS logo, 
                  COUNT(DISTINCT CASE WHEN finding IS NOT NULL THEN account.id END) AS accountsWithFindings,
                  COUNT(DISTINCT dlp) > 0 AS sensitiveData, 
                  COUNT(DISTINCT scope) > 0 AS riskyOauthScopes,
                  apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, actionCount] END)) AS actionResults,
                  apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, outcomeMap] END)) AS actionOutcomes,
                  {actioned: COUNT(DISTINCT CASE WHEN action IS NOT NULL THEN finding.id END),
                      pending: COUNT(DISTINCT CASE WHEN action IS NULL THEN finding.id END)} AS reviewStatus,
                  CASE 
                      WHEN app.totalScore IN [1, 2] THEN 'Very High'
                      WHEN app.totalScore IN [3, 4] THEN 'High'
                      WHEN app.totalScore IN [5, 6] THEN 'Moderate'
                      WHEN app.totalScore IN [7, 8] THEN 'Low'
                      WHEN app.totalScore IN [9, 10] THEN 'Very Low'
                      ELSE 'Unknown'
                  END AS appRiskLevel
          }

          WITH app, appAdmin, appRiskLevel, categories, lastAccessTime, firstAccessTime, accountsWithFindings,
              status, logo, accounts AS totalAccounts, reviewStatus, sensitiveData, riskyOauthScopes,
              datetime.truncate('day', datetime() - duration('P1M')).epochMillis AS one_month_ago_epoch, actionResults, actionOutcomes

          WHERE toLower(COALESCE(app.name, app.domain)) CONTAINS toLower('{searchText}')
          {placeholder}

          RETURN
              COUNT(DISTINCT COALESCE(app.id_, app.internalId)) AS totalCount"
    input_params:
      behavior: $behavior
      sensitive_data: AND sensitiveData = $sensitive_data
      risky_oauth_scopes: AND riskyOauthScopes = $risky_oauth_scopes
      risk_level: AND appRiskLevel = $risk_level
      criticality: AND toLower(COALESCE(app.criticality, 'Not Set')) = toLower($criticality)

      approval_status: AND toLower(status) = toLower($approval_status)
      number_of_accounts_greater_than: AND totalAccounts > $number_of_accounts_greater_than
      number_of_accounts_less_than: AND totalAccounts < $number_of_accounts_less_than
      technical_owner: AND appAdmin = $technical_owner
      newly_discovered: AND newlyDiscovered = $newly_discovered
      action_status: AND CASE WHEN toLower($action_status) = 'actioned' THEN reviewStatus['actioned'] > 0 ELSE reviewStatus['actioned'] = 0 END
    type: widget
    dataSourceType: knowledgegraph
    active: true
  - id: BID_17
    query: "MATCH (email:EMAIL {subscriber: $subscriber, tenant: $tenant})-[acc_type]->(acc:ACCOUNT)-[:HAS_FINDING]->(finding:FINDING)<-[]-(rule:RULE)-[]->(behavior:BEHAVIOR {id: $behavior})
            OPTIONAL MATCH (user:USER)-[]->(email)
            MATCH (acc)-[:USING_APP]->(app:APPLICATION)-[:HAS_APP_CATEGORY]->(category:APP_CATEGORY)
            OPTIONAL MATCH (app)-[:HAS_GRANT]-(grant:GRANT)-[:HAS_SCOPE]-(scope:SCOPE {severity: 'High'})
            
            OPTIONAL MATCH (app)-[:HAS_ADMIN]->(owner:ACCOUNT)
            OPTIONAL MATCH (app)-[hs:HAS_APP_SETTINGS]-(tenant:TENANT {id: $tenant})
            OPTIONAL MATCH (finding)-[:HAS_ARTIFACT]->(dlp:DLP_FINAL_CLASS | DLP_ORIGINAL_CLASS)
            OPTIONAL MATCH (finding)-[:TRIGGERED]-(action:ACTION)
            OPTIONAL MATCH (action)-[:RESULTED_IN]->(outcome:OUTCOME)
            
            WITH datetime.truncate('day', datetime() - duration('P1M')).epochMillis AS one_month_ago_epoch,
                MIN(CASE WHEN acc.creationTime = '-' THEN NULL ELSE acc.creationTime END) AS firstAccessTime,
                COALESCE(hs.approval_status, 'NEEDS REVIEW') AS status,
                COALESCE(action.name, '-') as actionName, COUNT(DISTINCT action.id) AS actionCount,
                CASE WHEN action IS NOT NULL AND outcome IS NULL THEN 'Not Responded'
                    WHEN outcome IS NOT NULL THEN COALESCE(outcome.value, outcome.message, '-')
                END as outcomeValue,
                COUNT(DISTINCT action.id) as outcomeCount,
                app, acc, hs, action, finding, owner, category, acc_type, scope, grant, dlp, user, email
            
            WITH one_month_ago_epoch, firstAccessTime, status, actionName, actionCount,
                apoc.map.fromPairs(COLLECT([outcomeValue, outcomeCount])) as outcomeMap,
                app, acc, hs, action, finding, owner, category, acc_type, scope, grant, dlp, user, email
            
            
            
            WITH 
                email.id AS userMail,
                user.displayName AS userName,
                user.profilePicUrl AS userProfilePicUrl,
                COALESCE(app.id_, app.internalId) AS id, 
                COALESCE(app.name, app.domain) AS app,
                status,
                COALESCE(hs.logoUrl, app.logoUrl) AS logo,
                COALESCE(hs.appCriticality, app.criticality, 'Not Set') AS criticality,
                COALESCE(firstAccessTime > one_month_ago_epoch, true) AS newlyDiscovered,
                {
                    actioned: COUNT(DISTINCT CASE WHEN action IS NOT NULL THEN finding.id END),
                    pending: COUNT(DISTINCT CASE WHEN action IS NULL THEN finding.id END)
                } AS reviewStatus,
                CASE 
                    WHEN app.totalScore IN [1, 2] THEN 'Very High'
                    WHEN app.totalScore IN [3, 4] THEN 'High'
                    WHEN app.totalScore IN [5, 6] THEN 'Moderate'
                    WHEN app.totalScore IN [7, 8] THEN 'Low'
                    WHEN app.totalScore IN [9, 10] THEN 'Very Low'
                    ELSE 'Unknown'
                END AS appRiskLevel,
                COLLECT(DISTINCT owner.email) AS appAdmins,
                COUNT(DISTINCT acc) AS accounts,
                COLLECT(DISTINCT {name: category.name, priority: category.priority}) AS categories,
                firstAccessTime,
                MAX(COALESCE(acc_type.last_access_time, 0)) AS lastAccessTime,
                COUNT(DISTINCT CASE WHEN finding IS NOT NULL THEN acc.id END) AS accountsWithFindings,
                COUNT(DISTINCT dlp) > 0 AS sensitiveData,
                COUNT(DISTINCT scope) > 0 AS riskyOauthScopes,
                grant.consentBy as grantedBy,
                grant.consentType as grantedType,
                apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, actionCount] END)) AS actionResults,
                apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, outcomeMap] END)) AS actionOutcomes
            
            WHERE toLower(app) CONTAINS toLower('{searchText}')
          {placeholder}
            
            RETURN DISTINCT
                id,
                app,
                userMail,
                userName,
                userProfilePicUrl,
                status,
                logo,
                criticality,
                newlyDiscovered,
                appAdmins,
                accounts,
                categories,
                firstAccessTime,
                lastAccessTime,
                accountsWithFindings,
                reviewStatus,
                appRiskLevel,
                sensitiveData,
                riskyOauthScopes,
                grantedBy,
                grantedType,
                actionResults,
                actionOutcomes
                
                
                
            
            ORDER BY lastAccessTime DESC"
    defaultValue:
    allowed_params: true
    name: Newly Introduced AI App
    pagination_query: "MATCH (email:EMAIL {subscriber: $subscriber, tenant: $tenant})-[acc_type]->(acc:ACCOUNT)-[:HAS_FINDING]->(finding:FINDING)<-[]-(rule:RULE)-[]->(behavior:BEHAVIOR {id: $behavior})
            OPTIONAL MATCH (user:USER)-[]->(email)
            MATCH (acc)-[:USING_APP]->(app:APPLICATION)-[:HAS_APP_CATEGORY]->(category:APP_CATEGORY)
            OPTIONAL MATCH (app)-[:HAS_GRANT]-(grant:GRANT)-[:HAS_SCOPE]-(scope:SCOPE {severity: 'High'})
            
            OPTIONAL MATCH (app)-[:HAS_ADMIN]->(owner:ACCOUNT)
            OPTIONAL MATCH (app)-[hs:HAS_APP_SETTINGS]-(tenant:TENANT {id: $tenant})
            OPTIONAL MATCH (finding)-[:HAS_ARTIFACT]->(dlp:DLP_FINAL_CLASS | DLP_ORIGINAL_CLASS)
            OPTIONAL MATCH (finding)-[:TRIGGERED]-(action:ACTION)
            OPTIONAL MATCH (action)-[:RESULTED_IN]->(outcome:OUTCOME)
            
            WITH datetime.truncate('day', datetime() - duration('P1M')).epochMillis AS one_month_ago_epoch,
                MIN(CASE WHEN acc.creationTime = '-' THEN NULL ELSE acc.creationTime END) AS firstAccessTime,
                COALESCE(hs.approval_status, 'NEEDS REVIEW') AS status,
                COALESCE(action.name, '-') as actionName, COUNT(DISTINCT action.id) AS actionCount,
                CASE WHEN action IS NOT NULL AND outcome IS NULL THEN 'Not Responded'
                    WHEN outcome IS NOT NULL THEN COALESCE(outcome.value, outcome.message, '-')
                END as outcomeValue,
                COUNT(DISTINCT action.id) as outcomeCount,
                app, acc, hs, action, finding, owner, category, acc_type, scope, grant, dlp, user, email
            
            WITH one_month_ago_epoch, firstAccessTime, status, actionName, actionCount,
                apoc.map.fromPairs(COLLECT([outcomeValue, outcomeCount])) as outcomeMap,
                app, acc, hs, action, finding, owner, category, acc_type, scope, grant, dlp, user, email
            
            WITH 
                email.id AS userMail,
                user.displayName AS userName,
                user.profilePicUrl AS userProfilePicUrl,
                COALESCE(app.id_, app.internalId) AS id, 
                COALESCE(app.name, app.domain) AS app,
                status,
                COALESCE(hs.logoUrl, app.logoUrl) AS logo,
                COALESCE(hs.appCriticality, app.criticality, 'Not Set') AS criticality,
                COALESCE(firstAccessTime > one_month_ago_epoch, true) AS newlyDiscovered,
                {
                    actioned: COUNT(DISTINCT CASE WHEN action IS NOT NULL THEN finding.id END),
                    pending: COUNT(DISTINCT CASE WHEN action IS NULL THEN finding.id END)
                } AS reviewStatus,
                CASE 
                    WHEN app.totalScore IN [1, 2] THEN 'Very High'
                    WHEN app.totalScore IN [3, 4] THEN 'High'
                    WHEN app.totalScore IN [5, 6] THEN 'Moderate'
                    WHEN app.totalScore IN [7, 8] THEN 'Low'
                    WHEN app.totalScore IN [9, 10] THEN 'Very Low'
                    ELSE 'Unknown'
                END AS appRiskLevel,
                COLLECT(DISTINCT owner.email) AS appAdmins,
                COUNT(DISTINCT acc) AS accounts,
                COLLECT(DISTINCT {name: category.name, priority: category.priority}) AS categories,
                firstAccessTime,
                MAX(COALESCE(acc_type.last_access_time, 0)) AS lastAccessTime,
                COUNT(DISTINCT CASE WHEN finding IS NOT NULL THEN acc.id END) AS accountsWithFindings,
                COUNT(DISTINCT dlp) > 0 AS sensitiveData,
                COUNT(DISTINCT scope) > 0 AS riskyOauthScopes,
                grant.consentBy as grantedBy,
                grant.consentType as grantedType,
                apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, actionCount] END)) AS actionResults,
                apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, outcomeMap] END)) AS actionOutcomes
            
            WHERE toLower(app) CONTAINS toLower('{searchText}')
          {placeholder}

            RETURN
                COUNT(DISTINCT id) AS totalCount"
    input_params:
      behavior: $behavior
      approval_status: AND toLower(status) = toLower($approval_status)
      sensitive_data: AND sensitiveData = $sensitive_data
      risky_oauth_scopes: AND riskyOauthScopes = $risky_oauth_scopes
      action_status: AND reviewStatus[toLower($action_status)] > 0
      criticality: AND toLower(criticality) = toLower($criticality)
      sensitive_data_classes: AND sensitiveDataInfo[$sensitive_data_classes] > 0
      number_of_accounts_greater_than: AND accounts > $number_of_accounts_greater_than
      number_of_account_less_than: AND accounts < $number_of_account_less_than
    type: widget
    dataSourceType: knowledgegraph
    active: true
  - id: BID_21
    query: "CALL {
                MATCH (email:EMAIL {subscriber: $subscriber, tenant: $tenant})-[AUTH_TYPE]->(account:ACCOUNT)
                OPTIONAL MATCH (u:USER)-[:HAS_EMAIL]->(email)
                MATCH (account)-[:USING_APP]->(app:APPLICATION)
                MATCH (account)-[:HAS_FINDING]->(finding:FINDING)
                MATCH (app)-[:HAS_APP_CATEGORY]->(category:APP_CATEGORY)
                MATCH (finding)<-[:EVALUATED_TO]-(rule:RULE)-[:BELONGS_TO]->(behavior:BEHAVIOR {id: $behavior})
            
                OPTIONAL MATCH (app)-[:HAS_ADMIN]->(owner:ACCOUNT)
                OPTIONAL MATCH (finding)-[:TRIGGERED]->(action:ACTION)
                OPTIONAL MATCH (action)-[:RESULTED_IN]->(outcome:OUTCOME)
                OPTIONAL MATCH (app)<-[hs:HAS_APP_SETTINGS]-(t:TENANT {id: $tenant})
                OPTIONAL MATCH (app)-[:HAS_GRANT]->(grant:GRANT)-[:HAS_SCOPE]->(scope:SCOPE {severity: 'High'})
                OPTIONAL MATCH (finding)-[:HAS_ARTIFACT]->(dlp:DLP_FINAL_CLASS | DLP_ORIGINAL_CLASS)
            
                WITH app, owner, account, AUTH_TYPE, hs, category, finding, action, dlp, scope,
                COALESCE(action.name, '-') AS actionName, COUNT(DISTINCT action.id) AS actionCount,
                CASE WHEN action IS NOT NULL AND outcome IS NULL THEN 'Not Responded'
                    WHEN outcome IS NOT NULL THEN COALESCE(outcome.value, outcome.message, '-')
                END as outcomeValue,
                COUNT(DISTINCT action.id) as outcomeCount
            
                WITH app, owner, account, AUTH_TYPE, hs, category, finding, action, dlp, scope,
                actionName, actionCount, apoc.map.fromPairs(COLLECT([outcomeValue, outcomeCount])) as outcomeMap
            
                RETURN 
                    app, 
                    owner.email AS appAdmin, 
                    COUNT(DISTINCT account) AS accounts, 
                    COLLECT(DISTINCT {name: category.name, priority: category.priority}) AS categories, 
                    MIN(CASE WHEN account.creationTime = '-' THEN NULL ELSE account.creationTime END) AS firstAccessTime,
                    MAX(COALESCE(AUTH_TYPE.last_access_time, 0)) AS lastAccessTime,  
                    COALESCE(hs.approval_status, 'NEEDS REVIEW') AS status, 
                    COALESCE(hs.logoUrl, app.logoUrl) AS logo, 
                    COUNT(DISTINCT CASE WHEN finding IS NOT NULL THEN account.id END) AS accountsWithFindings,
                    COUNT(DISTINCT dlp) > 0 AS sensitiveData, 
                    COUNT(DISTINCT scope) > 0 AS riskyOauthScopes,
                    apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, actionCount] END)) AS actionResults,
                    apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, outcomeMap] END)) AS actionOutcomes,
                    {actioned: COUNT(DISTINCT CASE WHEN action IS NOT NULL THEN finding.id END),
                        pending: COUNT(DISTINCT CASE WHEN action IS NULL THEN finding.id END)} AS reviewStatus,
                    CASE 
                        WHEN app.totalScore IN [1, 2] THEN 'Very High'
                        WHEN app.totalScore IN [3, 4] THEN 'High'
                        WHEN app.totalScore IN [5, 6] THEN 'Moderate'
                        WHEN app.totalScore IN [7, 8] THEN 'Low'
                        WHEN app.totalScore IN [9, 10] THEN 'Very Low'
                        ELSE 'Unknown'
                    END AS appRiskLevel
            }
            
            WITH app, appAdmin, appRiskLevel, categories, lastAccessTime, firstAccessTime, accountsWithFindings,
                status, logo, accounts AS totalAccounts, reviewStatus, sensitiveData, riskyOauthScopes,
                datetime.truncate('day', datetime() - duration('P1M')).epochMillis AS one_month_ago_epoch, actionResults, actionOutcomes
            
            WHERE toLower(COALESCE(app.name, app.domain)) CONTAINS toLower('{searchText}')
            {placeholder}
            
            RETURN DISTINCT
                COALESCE(app.id_, app.internalId) AS id, 
                COALESCE(app.name, app.domain, app.id) AS app, 
                appRiskLevel,
                COALESCE(app.criticality, 'Not Set') AS criticality, 
                status, 
                COALESCE(firstAccessTime > one_month_ago_epoch, true) AS newlyDiscovered,
                logo, 
                [cat IN categories WHERE cat.priority = 2 | cat.name] AS highPriorityCategories, 
                totalAccounts, 
                accountsWithFindings, 
                lastAccessTime, 
                firstAccessTime,
                reviewStatus,
                sensitiveData,
                riskyOauthScopes,
                actionResults,
                actionOutcomes
            ORDER BY lastAccessTime DESC"
    defaultValue: null
    allowed_params: true
    name: Blocked AI Apps
    pagination_query: "CALL {
              MATCH (email:EMAIL {subscriber: $subscriber, tenant: $tenant})-[AUTH_TYPE]->(account:ACCOUNT)
              OPTIONAL MATCH (u:USER)-[:HAS_EMAIL]->(email)
              MATCH (account)-[:USING_APP]->(app:APPLICATION)
              MATCH (account)-[:HAS_FINDING]->(finding:FINDING)
              MATCH (app)-[:HAS_APP_CATEGORY]->(category:APP_CATEGORY)
              MATCH (finding)<-[:EVALUATED_TO]-(rule:RULE)-[:BELONGS_TO]->(behavior:BEHAVIOR {id: $behavior})

              OPTIONAL MATCH (app)-[:HAS_ADMIN]->(owner:ACCOUNT)
              OPTIONAL MATCH (finding)-[:TRIGGERED]->(action:ACTION)
              OPTIONAL MATCH (action)-[:RESULTED_IN]->(outcome:OUTCOME)
              OPTIONAL MATCH (app)<-[hs:HAS_APP_SETTINGS]-(t:TENANT {id: $tenant})
              OPTIONAL MATCH (app)-[:HAS_GRANT]->(grant:GRANT)-[:HAS_SCOPE]->(scope:SCOPE {severity: 'High'})
              OPTIONAL MATCH (finding)-[:HAS_ARTIFACT]->(dlp:DLP_FINAL_CLASS | DLP_ORIGINAL_CLASS)

              WITH app, owner, account, AUTH_TYPE, hs, category, finding, action, dlp, scope,
              COALESCE(action.name, '-') AS actionName, COUNT(DISTINCT action.id) AS actionCount,
              CASE WHEN action IS NOT NULL AND outcome IS NULL THEN 'Not Responded'
                  WHEN outcome IS NOT NULL THEN COALESCE(outcome.value, outcome.message, '-')
              END as outcomeValue,
              COUNT(DISTINCT action.id) as outcomeCount

              WITH app, owner, account, AUTH_TYPE, hs, category, finding, action, dlp, scope,
              actionName, actionCount, apoc.map.fromPairs(COLLECT([outcomeValue, outcomeCount])) as outcomeMap

              RETURN 
                  app, 
                  owner.email AS appAdmin, 
                  COUNT(DISTINCT account) AS accounts, 
                  COLLECT(DISTINCT {name: category.name, priority: category.priority}) AS categories, 
                  MIN(CASE WHEN account.creationTime = '-' THEN NULL ELSE account.creationTime END) AS firstAccessTime,
                  MAX(COALESCE(AUTH_TYPE.last_access_time, 0)) AS lastAccessTime,  
                  COALESCE(hs.approval_status, 'NEEDS REVIEW') AS status, 
                  COALESCE(hs.logoUrl, app.logoUrl) AS logo, 
                  COUNT(DISTINCT CASE WHEN finding IS NOT NULL THEN account.id END) AS accountsWithFindings,
                  COUNT(DISTINCT dlp) > 0 AS sensitiveData, 
                  COUNT(DISTINCT scope) > 0 AS riskyOauthScopes,
                  apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, actionCount] END)) AS actionResults,
                  apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, outcomeMap] END)) AS actionOutcomes,
                  {actioned: COUNT(DISTINCT CASE WHEN action IS NOT NULL THEN finding.id END),
                      pending: COUNT(DISTINCT CASE WHEN action IS NULL THEN finding.id END)} AS reviewStatus,
                  CASE 
                      WHEN app.totalScore IN [1, 2] THEN 'Very High'
                      WHEN app.totalScore IN [3, 4] THEN 'High'
                      WHEN app.totalScore IN [5, 6] THEN 'Moderate'
                      WHEN app.totalScore IN [7, 8] THEN 'Low'
                      WHEN app.totalScore IN [9, 10] THEN 'Very Low'
                      ELSE 'Unknown'
                  END AS appRiskLevel
          }

          WITH app, appAdmin, appRiskLevel, categories, lastAccessTime, firstAccessTime, accountsWithFindings,
              status, logo, accounts AS totalAccounts, reviewStatus, sensitiveData, riskyOauthScopes,
              datetime.truncate('day', datetime() - duration('P1M')).epochMillis AS one_month_ago_epoch, actionResults, actionOutcomes

          WHERE toLower(COALESCE(app.name, app.domain)) CONTAINS toLower('{searchText}')
          {placeholder}

          RETURN
              COUNT(DISTINCT COALESCE(app.id_, app.internalId)) AS totalCount"
    input_params:
      behavior: $behavior
      sensitive_data: AND sensitiveData = $sensitive_data
      risky_oauth_scopes: AND riskyOauthScopes = $risky_oauth_scopes
      risk_level: AND appRiskLevel = $risk_level
      criticality: AND toLower(COALESCE(app.criticality, 'Not Set')) = toLower($criticality)

      approval_status: AND toLower(status) = toLower($approval_status)
      number_of_accounts_greater_than: AND totalAccounts > $number_of_accounts_greater_than
      number_of_accounts_less_than: AND totalAccounts < $number_of_accounts_less_than
      technical_owner: AND appAdmin = $technical_owner
      newly_discovered: AND newlyDiscovered = $newly_discovered
      action_status: AND CASE WHEN toLower($action_status) = 'actioned' THEN reviewStatus['actioned'] > 0 ELSE reviewStatus['actioned'] = 0 END
    type: widget
    dataSourceType: knowledgegraph
    active: true
  - id: BID_21
    query: "CALL {
                MATCH (email:EMAIL {subscriber: $subscriber, tenant: $tenant})-[AUTH_TYPE]->(account:ACCOUNT)
                OPTIONAL MATCH (u:USER)-[:HAS_EMAIL]->(email)
                MATCH (account)-[:USING_APP]->(app:APPLICATION)
                MATCH (account)-[:HAS_FINDING]->(finding:FINDING)
                MATCH (app)-[:HAS_APP_CATEGORY]->(category:APP_CATEGORY)
                MATCH (finding)<-[:EVALUATED_TO]-(rule:RULE)-[:BELONGS_TO]->(behavior:BEHAVIOR {id: $behavior})
            
                OPTIONAL MATCH (app)-[:HAS_ADMIN]->(owner:ACCOUNT)
                OPTIONAL MATCH (finding)-[:TRIGGERED]->(action:ACTION)
                OPTIONAL MATCH (action)-[:RESULTED_IN]->(outcome:OUTCOME)
                OPTIONAL MATCH (app)<-[hs:HAS_APP_SETTINGS]-(t:TENANT {id: $tenant})
                OPTIONAL MATCH (app)-[:HAS_GRANT]->(grant:GRANT)-[:HAS_SCOPE]->(scope:SCOPE {severity: 'High'})
                OPTIONAL MATCH (finding)-[:HAS_ARTIFACT]->(dlp:DLP_FINAL_CLASS | DLP_ORIGINAL_CLASS)
            
                WITH app, owner, account, AUTH_TYPE, hs, category, finding, action, dlp, scope,
                COALESCE(action.name, '-') AS actionName, COUNT(DISTINCT action.id) AS actionCount,
                CASE WHEN action IS NOT NULL AND outcome IS NULL THEN 'Not Responded'
                    WHEN outcome IS NOT NULL THEN COALESCE(outcome.value, outcome.message, '-')
                END as outcomeValue,
                COUNT(DISTINCT action.id) as outcomeCount
            
                WITH app, owner, account, AUTH_TYPE, hs, category, finding, action, dlp, scope,
                actionName, actionCount, apoc.map.fromPairs(COLLECT([outcomeValue, outcomeCount])) as outcomeMap
            
                RETURN 
                    app, 
                    owner.email AS appAdmin, 
                    COUNT(DISTINCT account) AS accounts, 
                    COLLECT(DISTINCT {name: category.name, priority: category.priority}) AS categories, 
                    MIN(CASE WHEN account.creationTime = '-' THEN NULL ELSE account.creationTime END) AS firstAccessTime,
                    MAX(COALESCE(AUTH_TYPE.last_access_time, 0)) AS lastAccessTime,  
                    COALESCE(hs.approval_status, 'NEEDS REVIEW') AS status, 
                    COALESCE(hs.logoUrl, app.logoUrl) AS logo, 
                    COUNT(DISTINCT CASE WHEN finding IS NOT NULL THEN account.id END) AS accountsWithFindings,
                    COUNT(DISTINCT dlp) > 0 AS sensitiveData, 
                    COUNT(DISTINCT scope) > 0 AS riskyOauthScopes,
                    apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, actionCount] END)) AS actionResults,
                    apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, outcomeMap] END)) AS actionOutcomes,
                    {actioned: COUNT(DISTINCT CASE WHEN action IS NOT NULL THEN finding.id END),
                        pending: COUNT(DISTINCT CASE WHEN action IS NULL THEN finding.id END)} AS reviewStatus,
                    CASE 
                        WHEN app.totalScore IN [1, 2] THEN 'Very High'
                        WHEN app.totalScore IN [3, 4] THEN 'High'
                        WHEN app.totalScore IN [5, 6] THEN 'Moderate'
                        WHEN app.totalScore IN [7, 8] THEN 'Low'
                        WHEN app.totalScore IN [9, 10] THEN 'Very Low'
                        ELSE 'Unknown'
                    END AS appRiskLevel
            }
            
            WITH app, appAdmin, appRiskLevel, categories, lastAccessTime, firstAccessTime, accountsWithFindings,
                status, logo, accounts AS totalAccounts, reviewStatus, sensitiveData, riskyOauthScopes,
                datetime.truncate('day', datetime() - duration('P1M')).epochMillis AS one_month_ago_epoch, actionResults, actionOutcomes
            
            WHERE toLower(COALESCE(app.name, app.domain)) CONTAINS toLower('{searchText}')
            {placeholder}
            
            RETURN DISTINCT
                COALESCE(app.id_, app.internalId) AS id, 
                COALESCE(app.name, app.domain, app.id) AS app, 
                appRiskLevel,
                COALESCE(app.criticality, 'Not Set') AS criticality, 
                status, 
                COALESCE(firstAccessTime > one_month_ago_epoch, true) AS newlyDiscovered,
                logo, 
                [cat IN categories WHERE cat.priority = 2 | cat.name] AS highPriorityCategories, 
                totalAccounts, 
                accountsWithFindings, 
                lastAccessTime, 
                firstAccessTime,
                reviewStatus,
                sensitiveData,
                riskyOauthScopes,
                actionResults,
                actionOutcomes
            ORDER BY lastAccessTime DESC"
    defaultValue: null
    allowed_params: true
    name: Blocked AI Apps
    pagination_query: "CALL {
              MATCH (email:EMAIL {subscriber: $subscriber, tenant: $tenant})-[AUTH_TYPE]->(account:ACCOUNT)
              OPTIONAL MATCH (u:USER)-[:HAS_EMAIL]->(email)
              MATCH (account)-[:USING_APP]->(app:APPLICATION)
              MATCH (account)-[:HAS_FINDING]->(finding:FINDING)
              MATCH (app)-[:HAS_APP_CATEGORY]->(category:APP_CATEGORY)
              MATCH (finding)<-[:EVALUATED_TO]-(rule:RULE)-[:BELONGS_TO]->(behavior:BEHAVIOR {id: $behavior})

              OPTIONAL MATCH (app)-[:HAS_ADMIN]->(owner:ACCOUNT)
              OPTIONAL MATCH (finding)-[:TRIGGERED]->(action:ACTION)
              OPTIONAL MATCH (action)-[:RESULTED_IN]->(outcome:OUTCOME)
              OPTIONAL MATCH (app)<-[hs:HAS_APP_SETTINGS]-(t:TENANT {id: $tenant})
              OPTIONAL MATCH (app)-[:HAS_GRANT]->(grant:GRANT)-[:HAS_SCOPE]->(scope:SCOPE {severity: 'High'})
              OPTIONAL MATCH (finding)-[:HAS_ARTIFACT]->(dlp:DLP_FINAL_CLASS | DLP_ORIGINAL_CLASS)

              WITH app, owner, account, AUTH_TYPE, hs, category, finding, action, dlp, scope,
              COALESCE(action.name, '-') AS actionName, COUNT(DISTINCT action.id) AS actionCount,
              CASE WHEN action IS NOT NULL AND outcome IS NULL THEN 'Not Responded'
                  WHEN outcome IS NOT NULL THEN COALESCE(outcome.value, outcome.message, '-')
              END as outcomeValue,
              COUNT(DISTINCT action.id) as outcomeCount

              WITH app, owner, account, AUTH_TYPE, hs, category, finding, action, dlp, scope,
              actionName, actionCount, apoc.map.fromPairs(COLLECT([outcomeValue, outcomeCount])) as outcomeMap

              RETURN 
                  app, 
                  owner.email AS appAdmin, 
                  COUNT(DISTINCT account) AS accounts, 
                  COLLECT(DISTINCT {name: category.name, priority: category.priority}) AS categories, 
                  MIN(CASE WHEN account.creationTime = '-' THEN NULL ELSE account.creationTime END) AS firstAccessTime,
                  MAX(COALESCE(AUTH_TYPE.last_access_time, 0)) AS lastAccessTime,  
                  COALESCE(hs.approval_status, 'NEEDS REVIEW') AS status, 
                  COALESCE(hs.logoUrl, app.logoUrl) AS logo, 
                  COUNT(DISTINCT CASE WHEN finding IS NOT NULL THEN account.id END) AS accountsWithFindings,
                  COUNT(DISTINCT dlp) > 0 AS sensitiveData, 
                  COUNT(DISTINCT scope) > 0 AS riskyOauthScopes,
                  apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, actionCount] END)) AS actionResults,
                  apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, outcomeMap] END)) AS actionOutcomes,
                  {actioned: COUNT(DISTINCT CASE WHEN action IS NOT NULL THEN finding.id END),
                      pending: COUNT(DISTINCT CASE WHEN action IS NULL THEN finding.id END)} AS reviewStatus,
                  CASE 
                      WHEN app.totalScore IN [1, 2] THEN 'Very High'
                      WHEN app.totalScore IN [3, 4] THEN 'High'
                      WHEN app.totalScore IN [5, 6] THEN 'Moderate'
                      WHEN app.totalScore IN [7, 8] THEN 'Low'
                      WHEN app.totalScore IN [9, 10] THEN 'Very Low'
                      ELSE 'Unknown'
                  END AS appRiskLevel
          }

          WITH app, appAdmin, appRiskLevel, categories, lastAccessTime, firstAccessTime, accountsWithFindings,
              status, logo, accounts AS totalAccounts, reviewStatus, sensitiveData, riskyOauthScopes,
              datetime.truncate('day', datetime() - duration('P1M')).epochMillis AS one_month_ago_epoch, actionResults, actionOutcomes

          WHERE toLower(COALESCE(app.name, app.domain)) CONTAINS toLower('{searchText}')
          {placeholder}

          RETURN
              COUNT(DISTINCT COALESCE(app.id_, app.internalId)) AS totalCount"
    input_params:
      behavior: $behavior
      sensitive_data: AND sensitiveData = $sensitive_data
      risky_oauth_scopes: AND riskyOauthScopes = $risky_oauth_scopes
      risk_level: AND appRiskLevel = $risk_level
      criticality: AND toLower(COALESCE(app.criticality, 'Not Set')) = toLower($criticality)

      approval_status: AND toLower(status) = toLower($approval_status)
      number_of_accounts_greater_than: AND totalAccounts > $number_of_accounts_greater_than
      number_of_accounts_less_than: AND totalAccounts < $number_of_accounts_less_than
      technical_owner: AND appAdmin = $technical_owner
      newly_discovered: AND newlyDiscovered = $newly_discovered
      action_status: AND CASE WHEN toLower($action_status) = 'actioned' THEN reviewStatus['actioned'] > 0 ELSE reviewStatus['actioned'] = 0 END
    type: widget
    dataSourceType: knowledgegraph
    active: true
  - id: distribution_by_status
    query: "
      CALL {
        MATCH (u:USER {subscriber: $subscriber, tenant: $tenant})-[:HAS_EMAIL]-(email:EMAIL)
        MATCH (email)-[AUTH_TYPE]->(account:ACCOUNT)
        MATCH (account)-[:USING_APP]->(app:APPLICATION)-[:HAS_APP_CATEGORY]->(category:APP_CATEGORY)
        OPTIONAL MATCH (app)<-[hs:HAS_APP_SETTINGS]-(t:TENANT {id: $tenant})
        OPTIONAL MATCH (app)-[:HAS_ADMIN]->(owner:ACCOUNT)
        WITH DISTINCT app, owner, account, AUTH_TYPE, hs, category
        OPTIONAL MATCH (account)-[:HAS_FINDING]->(f:FINDING)
        OPTIONAL MATCH (f)-[:TRIGGERED]->(a:ACTION)
        OPTIONAL MATCH (f)-[:HAS_ARTIFACT]->(dlp:DLP_FINAL_CLASS | DLP_ORIGINAL_CLASS)
        OPTIONAL MATCH (app)-[:HAS_GRANT]->(grant:GRANT)
        OPTIONAL MATCH (grant)-[:HAS_SCOPE]->(scope:SCOPE {severity: 'High'})
        WHERE toLower(a.state) IN ['open', 'inprogress']
        WITH app, owner, account, AUTH_TYPE, hs, category, f, a, dlp, scope
        RETURN 
            app, 
            owner.email as appAdmin, 
            COUNT(DISTINCT account) AS accounts, 
            COLLECT(DISTINCT {name: category.name, priority: category.priority}) AS categories, 
            MAX(COALESCE(AUTH_TYPE.last_access_time, 0)) AS lastAccessTime, 
            MIN(CASE WHEN account.creationTime = '-' THEN NULL ELSE account.creationTime END) AS firstAccessTime, 
            COALESCE(hs.approval_status, 'NEEDS REVIEW') AS status, 
            COALESCE(hs.logoUrl, app.logoUrl) AS logo, 
            COUNT(DISTINCT CASE WHEN f IS NOT NULL THEN account.id END) AS accountsWithFindings,
            COUNT(DISTINCT CASE WHEN a IS NULL THEN f.id END) AS reviewStatus, 
            COLLECT(DISTINCT dlp.id) AS sensitiveDataSharedClasses, 
            COLLECT(DISTINCT scope.name) AS riskyOauthScopeNames
       }
        WITH app, appAdmin, categories, lastAccessTime, firstAccessTime, accountsWithFindings, status, logo, accounts AS totalAccounts, reviewStatus, sensitiveDataSharedClasses, riskyOauthScopeNames, datetime.truncate('day', datetime() - duration('P1M')).epochMillis AS one_month_ago_epoch
        WHERE 'generative ai' IN [cat IN categories | cat.name] 
            AND toLower(COALESCE(app.name, app.domain, app.id)) =~ toLower('.*{searchText}.*')
            AND status = $approvalStatus
            {placeholder}
        RETURN 
            COALESCE(app.id_, app.internalId) AS id, 
            COALESCE(app.name, app.domain, app.id) AS app, 
            appAdmin, 
            COALESCE(app.criticality, 'Not Set') AS criticality, 
            status, 
            COALESCE(firstAccessTime > one_month_ago_epoch, true) AS newlyDiscovered, 
            logo, 
            [cat IN categories WHERE cat.priority = 2 | cat.name] AS highPriorityCategories, 
            totalAccounts, 
            accountsWithFindings, 
            lastAccessTime, 
            firstAccessTime,
            reviewStatus,
            sensitiveDataSharedClasses,
            riskyOauthScopeNames 
        ORDER BY totalAccounts DESC"
    defaultValue:
    allowed_params: true
    name: Distribution by status
    pagination_query: ""
    input_params:
      approvalStatus: $approvalStatus
    type: widget
    dataSourceType: knowledgegraph
    active: true
  - id: sensitive_data
    query: "
        CALL {
          MATCH (u:USER {subscriber: $subscriber, tenant: $tenant})-[:HAS_EMAIL]-(email:EMAIL)
          MATCH (email)-[AUTH_TYPE]->(account:ACCOUNT)
          MATCH (account)-[:USING_APP]->(app:APPLICATION)-[:HAS_APP_CATEGORY]->(category:APP_CATEGORY)
          OPTIONAL MATCH (app)<-[hs:HAS_APP_SETTINGS]-(t:TENANT {id: $tenant})
          OPTIONAL MATCH (app)-[:HAS_ADMIN]->(owner:ACCOUNT)
          WITH DISTINCT app, owner, account, AUTH_TYPE, hs, category
          OPTIONAL MATCH (account)-[:HAS_FINDING]->(f:FINDING)
          OPTIONAL MATCH (f)-[:TRIGGERED]->(a:ACTION)
          OPTIONAL MATCH (f)-[:HAS_ARTIFACT]->(dlp:DLP_FINAL_CLASS | DLP_ORIGINAL_CLASS)
          OPTIONAL MATCH (app)-[:HAS_GRANT]->(grant:GRANT)
          OPTIONAL MATCH (grant)-[:HAS_SCOPE]->(scope:SCOPE {severity: 'High'})
          WHERE toLower(a.state) IN ['open', 'inprogress']
          WITH app, owner, account, AUTH_TYPE, hs, category, f, a, dlp, scope
            RETURN 
                app, 
                owner.email as appAdmin, 
                COUNT(DISTINCT account) AS accounts, 
                COLLECT(DISTINCT {name: category.name, priority: category.priority}) AS categories, 
                MAX(COALESCE(AUTH_TYPE.last_access_time, 0)) AS lastAccessTime, 
                MIN(CASE WHEN account.creationTime = '-' THEN NULL ELSE account.creationTime END) AS firstAccessTime, 
                COALESCE(hs.approval_status, 'NEEDS REVIEW') AS status, 
                COALESCE(hs.logoUrl, app.logoUrl) AS logo, 
                COUNT(DISTINCT CASE WHEN f IS NOT NULL THEN account.id END) AS accountsWithFindings,
                COUNT(DISTINCT CASE WHEN a IS NULL THEN f.id END) AS reviewStatus, 
                COLLECT(DISTINCT dlp.id) AS sensitiveDataSharedClasses, 
                COLLECT(DISTINCT scope.name) AS riskyOauthScopeNames
        }
        WITH app, appAdmin, categories, lastAccessTime, firstAccessTime, accountsWithFindings, status, logo, accounts AS totalAccounts, reviewStatus, sensitiveDataSharedClasses, riskyOauthScopeNames, datetime.truncate('day', datetime() - duration('P1M')).epochMillis AS one_month_ago_epoch
        WHERE 'generative ai' IN [cat IN categories | cat.name] 
            AND toLower(COALESCE(app.name, app.domain, app.id)) =~ toLower('.*{searchText}.*')
            AND dlp.id = $dataClassName
        RETURN 
            COALESCE(app.id_, app.internalId) AS id, 
            COALESCE(app.name, app.domain, app.id) AS app, 
            appAdmin, 
            COALESCE(app.criticality, 'Not Set') AS criticality, 
            status, 
            COALESCE(firstAccessTime > one_month_ago_epoch, true) AS newlyDiscovered, 
            logo, 
            [cat IN categories WHERE cat.priority = 2 | cat.name] AS highPriorityCategories, 
            totalAccounts, 
            accountsWithFindings, 
            lastAccessTime, 
            firstAccessTime,
            reviewStatus,
            sensitiveDataSharedClasses,
            riskyOauthScopeNames 
        ORDER BY totalAccounts DESC"
    defaultValue:
    allowed_params: true
    name: Distribution by status
    pagination_query: ""
    input_params:
      dataClassName: $dataClassName
    type: widget
    dataSourceType: knowledgegraph
    active: true
table_filters:
  - id: risk_level
    name: Risk Level
    defaultValue:
    active: true
    view_by:
      - app
    optional: true
    defaultOptions:
      - 'Very High'
      - 'High'
      - 'Moderate'
      - 'Low'
      - 'Very Low'
    type: multiselect
    allowed_params: false
    dataSourceType: knowledgegraph
    input_params: null
    query: ""
  - id: criticality
    name: Criticality
    defaultValue:
    active: true
    view_by:
      - app
    optional: true
    defaultOptions:
      "Yes": "critical"
      "No": "not critical"
    type: single
    allowed_params: false
    dataSourceType: knowledgegraph
    input_params: null
    query: ""
  - id: approval_status
    name: Approval Status
    defaultValue:
    active: true
    view_by:
      - app
      - BID_03
    optional: false
    defaultOptions:
      - "Approved"
      - "Unapproved"
      - "Needs Review"
      - "Tolerated"
    type: multiselect
    allowed_params: false
    dataSourceType: knowledgegraph
    input_params: null
    query: ""
  - id: number_of_accounts
    name: Number of Account
    defaultValue:
    active: true
    view_by:
      - app
      - account
    optional: false
    defaultOptions:
      - "greater_than"
      - "less_than"
    type: range
    allowed_params: false
    dataSourceType: knowledgegraph
    input_params: null
    query: ""
  - id: technical_owner
    name: Technical Owner
    defaultValue:
    active: true
    view_by:
      - app
      - account
    optional: true
    defaultOptions:
    type: single
    allowed_params: false
    dataSourceType: knowledgegraph
    input_params:
      search: true
    query: "MATCH (app:APPLICATION)-[:HAS_ADMIN]->(owner:ACCOUNT {subscriber: $subscriber, tenant: $tenant})-[]-(email:EMAIL)-[]-(user:USER)
            RETURN DISTINCT    user.id as id, user.displayName as label, user.mail as value"
  - id: newly_discovered
    name: Newly Discovered
    defaultValue:
    active: true
    view_by:
      - app
    optional: true
    defaultOptions:
      "Yes": true
      "No": false
    type: single
    allowed_params: false
    dataSourceType: knowledgegraph
    input_params: null
    query: ""
  - id: usage_level
    name: Usage Level
    defaultValue:
    active: false
    view_by:
      - app
    optional: true
    defaultOptions: []
    type: multiselect
    allowed_params: false
    dataSourceType: knowledgegraph
    input_params: null
    query: ""
  - id: action_status
    name: Action Status
    defaultValue:
    active: true
    view_by:
      - app
      - account
    optional: false
    defaultOptions:
      - "Actioned"
      - "Pending"
    type: single
    allowed_params: false
    dataSourceType: knowledgegraph
    input_params: null
    query: ""
  - id: department
    name: Department
    defaultValue:
    active: true
    view_by:
      - account
    optional: false
    defaultOptions: []
    type: multiselect
    allowed_params: false
    dataSourceType: knowledgegraph
    input_params: null
    query: "match(d:DEPARTMENT {subscriber: $subscriber, tenant: $tenant}) 
            return DISTINCT d.id AS id, d.name AS value , d.name AS label"
  - id: posture_risk_level
    name: Posture Risk Level
    defaultValue:
    active: true
    view_by:
      - account
    optional: false
    defaultOptions:
      - 'Very High'
      - 'High'
      - 'Moderate'
      - 'Low'
      - 'Very Low'
    type: multiselect
    allowed_params: false
    dataSourceType: knowledgegraph
    input_params: null
    query: ""
  - id: app_category
    name: App Category
    defaultValue:
    active: true
    view_by:
      - account
    optional: true
    defaultOptions: []
    type: multiselect
    allowed_params: false
    dataSourceType: knowledgegraph
    input_params: null
    query: "MATCH (email:EMAIL {subscriber: $subscriber, tenant: $tenant})-[]-(acc:ACCOUNT)-[:USING_APP]-(app:APPLICATION)-[:HAS_APP_CATEGORY]-(cat:APP_CATEGORY)WHERE cat.priority IS NULL OR cat.priority < 2
            RETURN DISTINCT    cat.name as label, 
                               cat.name as value, 
                               cat.name as id"
  - id: appname
    name: Appname
    defaultValue:
    active: true
    view_by:
      - account
    optional: false
    defaultOptions: []
    type: multiselect
    allowed_params: false
    dataSourceType: knowledgegraph
    input_params: null
    query: "MATCH (email:EMAIL {subscriber: $subscriber, tenant: $tenant})-[]-(acc:ACCOUNT)-[:USING_APP]-(app:APPLICATION)-[:HAS_APP_CATEGORY]-(cat:APP_CATEGORY)WHERE cat.priority IS NULL OR cat.priority < 2
            RETURN DISTINCT  app.id_ as id, app.id_ as value, app.name as label"
  - id: group
    name: Group
    defaultValue:
    active: true
    view_by:
      - account
    optional: false
    defaultOptions: []
    type: multiselect
    allowed_params: false
    dataSourceType: knowledgegraph
    input_params: null
    query: "MATCH (g:GROUP {subscriber: $subscriber, tenant: $tenant, userDefined: true}) 
            RETURN DISTINCT 
            g.id AS id, 
            g.displayName as label,
            g.displayName as value"
  - id: sensitive_data_shared
    name: Sensitive Data Shared
    defaultValue:
    active: true
    view_by:
      - BID_04
      - BID_02
      - BID_01
    optional: true
    defaultOptions:
      "Yes": true
      "No": false
    type: single
    allowed_params: false
    dataSourceType: knowledgegraph
    input_params: null
    query: ""
  - id: risky_oauth_scopes
    name: Risky Oauth Scopes
    defaultValue:
    active: true
    view_by:
      - BID_04
      - BID_02
      - BID_01
      - BID_03
    optional: true
    defaultOptions:
      "Yes": true
      "No": false
    type: single
    allowed_params: false
    dataSourceType: knowledgegraph
    input_params: null
    query: ""
  - id: granted_by
    name: Granted by
    defaultValue:
    active: true
    view_by:
      - BID_01
    optional: false
    defaultOptions:
      - "Admin"
      - "User"
    type: single
    allowed_params: false
    dataSourceType: knowledgegraph
    input_params: null
    query: ""
  - id: grant_type
    name: Grant Type
    defaultValue:
    active: true
    view_by:
      - BID_01
    optional: false
    defaultOptions:
      - "Delegated"
      - "User"
    type: single
    allowed_params: false
    dataSourceType: knowledgegraph
    input_params: null
    query: ""
  - id: sensitive_data_classes
    name: Sensitive data Classes
    defaultValue:
    active: true
    view_by:
      - BID_03
    optional: false
    defaultOptions:
    type: multi
    allowed_params: false
    dataSourceType: knowledgegraph
    input_params: null
    query: "MATCH (f:FINDING {subscriber: $subscriber, tenant: $tenant})-[:HAS_ARTIFACT]-(dlp:DLP_ORIGINAL_CLASS | DLP_FINAL_CLASS)
            RETURN DISTINCT    dlp.id as label,
                               dlp.id as value
                               dlp.id as id"
  - id: oauth_scope_risk_level
    name: Oauth Scope Risk Level
    defaultValue:
    active: true
    view_by:
      - BID_01
    optional: false
    defaultOptions:
      - 'High'
      - 'Medium'
      - 'Low'
    type: multi
    allowed_params: false
    dataSourceType: knowledgegraph
    input_params: null
    query: ""
widgets:
  - id: aiTrend
    name: "AI Trend"
    label: Widget
    template: ai_trend
    enabled: true
    type: linechart
    widget_type: insights_widget
    dataSourceType: datalake
    allowed_params: true
    className: col-span-1
    query_id: ""
    input_params:
      endtime: $endtime
      posture: $posture
    queryFilters:
    query: "select year, monthofyear, dayofmonth, alert_percentile*100 as risk_score, ROUND((alert_percentile*4)+1) as risk_index from kafka_connect.snowdata_schema.postureprofileaggregated where agg_type = 'organization' and agg_subtype = 'posture' and agg_subtype_name = $posture and subscriber = $subscriber and tenant = $tenant order by monthofyear, dayofmonth, agg_type_name, agg_subtype_name"
  - id: appsGraph
    name: ""
    label: Widget
    template: "detailed_chart"
    enabled: true
    type: detailed
    widget_type: insights_widget
    dataSourceType: datalake
    allowed_params: true
    className: col-span-1
    query_id: ""
    dataLabels:
      - isDetail: true
        label: "Total AI apps"
        dataIndex: "TOTAL_AI_APPS"
        percentageIndex: "TOTAL_AI_APPS_CHANGE"
      - isDetail: true
        label: "Total Accounts"
        dataIndex: "TOTAL_ACCOUNTS"
        percentageIndex: "TOTAL_ACCOUNTS_CHANGE"
      - isDetail: true
        label: "Newly discovered Apps"
        dataIndex: "NEW_AI_APPS"
        percentageIndex: "NEW_AI_APPS_CHANGE"
      - isDetail: true
        label: "Most used Apps"
        dataIndex: "MOST_USED_AI_APPS"
        percentageIndex: "MOST_USED_AI_APPS_CHANGE"
    input_params:
      endtime: $endtime
    queryFilters:
    query:
      "SELECT * FROM kafka_connect.snowdata_schema.daily_org_analytics WHERE subscriber = $subscriber AND tenant = $tenant ORDER BY timestamp DESC"
  - id: status
    name: Distribution by status
    label: Widget
    template: status
    enabled: true
    dataSourceType: knowledgegraph
    allowed_params: false
    type: variable_pie_chart
    widget_type: insights_widget
    className: col-span-3
    query_id: ""
    input_params: null
    queryFilters: []
    query: "MATCH (u:USER {subscriber: $subscriber , tenant: $tenant})-[:HAS_EMAIL]-(email:EMAIL)-[]->(account:ACCOUNT)
            MATCH (account)-[:USING_APP]->(app:APPLICATION)-[:HAS_APP_CATEGORY]->(category:APP_CATEGORY {name: 'generative ai'})
            
            OPTIONAL MATCH (app)<-[hs:HAS_APP_SETTINGS]-(tenant:TENANT {id: $tenant})
            
            WITH hs, app
            
            WITH
            COUNT(DISTINCT CASE WHEN COALESCE(hs.approval_status, 'NEEDS REVIEW') = 'NEEDS REVIEW' THEN app END) AS needsReviewCount,
            COUNT(DISTINCT CASE WHEN COALESCE(hs.approval_status, 'NEEDS REVIEW') = 'APPROVED' THEN app END) AS approvedCount,
            COUNT(DISTINCT CASE WHEN COALESCE(hs.approval_status, 'NEEDS REVIEW') = 'UNAPPROVED' THEN app END) AS unapprovedCount,
            COUNT(DISTINCT CASE WHEN COALESCE(hs.approval_status, 'NEEDS REVIEW') = 'TOLERATED' THEN app END) AS toleratedCount
            
            RETURN [
                { value: needsReviewCount, name: 'Needs Review' },
                { value: approvedCount, name: 'Approved' },
                { value: unapprovedCount, name: 'Unapproved' },
                { value: toleratedCount, name: 'Tolerated' }
            ] AS results"
  - id: PiChart
    name: Sensitive Data
    label: Widget
    template: PieChart
    enabled: true
    dataSourceType: knowledgegraph
    allowed_params: true
    type: bar_chart
    widget_type: insights_widget
    className: col-span-3
    query_id: ""
    input_params:
      starttime: AND app.timestamp >= $starttime
      endtime: AND app.timestamp <= $endtime
    queryFilters:
      - id: c58d1d61-6422-449f-96fd-b2b740bcd6f3
        name: Time Filter
        type: multiselect
        options: null
    # TODO : add a.resolverType IS NOT NULL in this query later.
    query: "MATCH (u:USER {subscriber: $subscriber, tenant: $tenant})-[:HAS_EMAIL]->(e:EMAIL)-[relation]->(acc:ACCOUNT)

            OPTIONAL MATCH (acc)-[:HAS_FINDING]->(f:FINDING | FINDING_HISTORY)
            OPTIONAL MATCH (f)-[:HAS_ARTIFACT]->(dlp:DLP_FINAL_CLASS)
            
            WITH f, dlp
            WHERE dlp.id IS NOT NULL AND toLower(f.status) <> 'benign'
                
            WITH f, dlp
            
            RETURN
            DISTINCT dlp.id as dlpData,
            COUNT(DISTINCT f.name) as findingCount"
  - id: prompts
    name: "Category of Prompts"
    label: Widget
    template: this_template
    enabled: true
    type: bar_chart
    widget_type: insights_widget
    dataSourceType: knowledgegraph
    allowed_params: true
    className: col-span-1
    query_id: ""
    input_params:
      endtime: $endtime
    queryFilters:
      - id: 23154174-af03-40c1-ac44-cb8b078c3b0f
        name: Time Filter
        type: multiselect
        options: null
    query:
  - id: BID_04
    name: ""
    label: Widget
    template: this_template
    enabled: true
    type: behavior_widget
    widget_type: behavior_widget
    dataSourceType: knowledgegraph
    allowed_params: true
    className: col-span-1
    query_id: ""
    input_params:
      endtime: $endtime
      behavior: $behavior
    queryFilters: []
    query: "MATCH (email:EMAIL {subscriber: $subscriber, tenant: $tenant})-[]-(acc:ACCOUNT)-[:HAS_FINDING]-(finding:FINDING)-[]
            -(rule:RULE)-[]-(behavior:BEHAVIOR {id: $behavior})
            MATCH (acc)-[:USING_APP]->(app:APPLICATION)
            WHERE COALESCE(app.name, app.domain) IS NOT NULL
            OPTIONAL MATCH (finding)-[]-(action:ACTION)
            WITH app, CASE WHEN COUNT(action) > 0 THEN true ELSE false END as hasAction
            RETURN
                COUNT(DISTINCT app.id_) AS total,
                COUNT(DISTINCT CASE WHEN hasAction = true THEN app.id_ END) AS actioned,
                COUNT(DISTINCT CASE WHEN hasAction = false THEN app.id_ END) AS pending"
  - id: BID_01
    name: ""
    label: Widget
    template: this_template
    enabled: true
    type: behavior_widget
    widget_type: behavior_widget
    dataSourceType: knowledgegraph
    allowed_params: true
    className: col-span-1
    query_id: ""
    input_params:
      endtime: $endtime
      behavior: $behavior
    queryFilters: []
    query: "MATCH (u:USER {subscriber: $subscriber, tenant: $tenant})-[:HAS_EMAIL]->(email:EMAIL)
            MATCH (email)-[auth_type]->(account:ACCOUNT)
            MATCH (account)-[:USING_APP]->(app:APPLICATION)
            MATCH (account)-[:HAS_FINDING]->(finding:FINDING)<-[:EVALUATED_TO]-(rule:RULE)-[:BELONGS_TO]->(behavior:BEHAVIOR {id: $behavior})

            OPTIONAL MATCH (finding)-[:TRIGGERED]->(action:ACTION)

            WITH DISTINCT app,
            COUNT(DISTINCT CASE WHEN action IS NOT NULL THEN account.id END) AS accountsWithActions,
            COUNT(DISTINCT CASE WHEN action IS NULL THEN account.id END) AS noActions

            RETURN 
                COUNT(DISTINCT app) AS total, 
                SUM(accountsWithActions) AS actioned, 
                SUM(noActions) AS pending"
  - id: BID_02
    name: ""
    label: Widget
    template: this_template
    enabled: true
    type: behavior_widget
    widget_type: behavior_widget
    dataSourceType: knowledgegraph
    allowed_params: true
    className: col-span-1
    query_id: ""
    input_params:
      endtime: $endtime
      behavior: $behavior
    queryFilters: []
    query: "MATCH (email:EMAIL {subscriber: $subscriber, tenant: $tenant})-[auth_type]->(account:ACCOUNT)-[:USING_APP]->(app:APPLICATION)
            MATCH (account)-[:HAS_FINDING]->(finding:FINDING)<-[:EVALUATED_TO]-(rule:RULE)-[:BELONGS_TO]->(behavior:BEHAVIOR {id: $behavior})

            OPTIONAL MATCH (finding)-[:TRIGGERED]->(action:ACTION)
            WITH DISTINCT account, email, CASE WHEN COUNT(action) > 0 THEN true ELSE false END as hasAction

            RETURN 
                COUNT(account.id) AS total,
                COUNT(CASE WHEN hasAction = true THEN account.id END) AS actioned,
                COUNT(CASE WHEN hasAction = false THEN account.id END) AS pending"
  - id: BID_03
    name: ""
    label: Widget
    template: this_template
    enabled: true
    type: behavior_widget
    widget_type: behavior_widget
    dataSourceType: knowledgegraph
    allowed_params: true
    className: col-span-1
    query_id: ""
    input_params:
      endtime: $endtime
      behavior: $behavior
    queryFilters: []
    query: "MATCH (user:USER {subscriber: $subscriber, tenant: $tenant})-[:HAS_EMAIL]->(email:EMAIL)
            MATCH (email)-[auth_type]->(account:ACCOUNT)
            MATCH (account)-[:USING_APP]->(app:APPLICATION)
            MATCH (account)-[:HAS_FINDING]->(finding:FINDING | FINDING_HISTORY)<-[:EVALUATED_TO]-(rule:RULE)-[:BELONGS_TO]->(behavior:BEHAVIOR {id: $behavior})

            OPTIONAL MATCH (finding)-[:TRIGGERED]->(action:ACTION)
            WITH account, CASE WHEN COUNT(action) > 0 THEN true ELSE false END as hasAction

            RETURN
                COUNT(DISTINCT account.id) AS total,
                COUNT(DISTINCT CASE WHEN hasAction = true THEN account.id END) AS actioned,
                COUNT(DISTINCT CASE WHEN hasAction = false THEN account.id END) AS pending"
  - id: BID_17
    name: "Newly Introduced AI Apps"
    label: Widget
    template: this_template
    enabled: true
    type: behavior_widget
    widget_type: behavior_widget
    dataSourceType: knowledgegraph
    allowed_params: true
    className: col-span-1
    query_id: ""
    input_params:
      endtime: $endtime
      behavior: $behavior
    queryFilters: []
    query: "MATCH (email:EMAIL {subscriber: $subscriber, tenant: $tenant})-[]-(acc:ACCOUNT)-[:HAS_FINDING]-(finding:FINDING)-[]
            -(rule:RULE)-[]-(behavior:BEHAVIOR {id: $behavior})
            MATCH (acc)-[:USING_APP]->(app:APPLICATION)
            WHERE COALESCE(app.name, app.domain) IS NOT NULL
            OPTIONAL MATCH (finding)-[]-(action:ACTION)
            WITH app, CASE WHEN COUNT(action) > 0 THEN true ELSE false END as hasAction
            RETURN
                COUNT(DISTINCT app.id_) AS total,
                COUNT(DISTINCT CASE WHEN hasAction = true THEN app.id_ END) AS actioned,
                COUNT(DISTINCT CASE WHEN hasAction = false THEN app.id_ END) AS pending"
  - id: BID_21
    name: "Blocked AI Apps"
    label: Widget
    template: this_template
    enabled: true
    type: behavior_widget
    widget_type: behavior_widget
    dataSourceType: knowledgegraph
    allowed_params: true
    className: col-span-1
    query_id: ""
    input_params:
      endtime: $endtime
      behavior: $behavior
    queryFilters: []
    query: "MATCH (email:EMAIL {subscriber: $subscriber, tenant: $tenant})-[]-(acc:ACCOUNT)-[:HAS_FINDING]-(finding:FINDING)-[]
            -(rule:RULE)-[]-(behavior:BEHAVIOR {id: $behavior})
            MATCH (acc)-[:USING_APP]->(app:APPLICATION)
            WHERE COALESCE(app.name, app.domain) IS NOT NULL
            OPTIONAL MATCH (finding)-[]-(action:ACTION)
            WITH app, CASE WHEN COUNT(action) > 0 THEN true ELSE false END as hasAction
            RETURN
                COUNT(DISTINCT app.id_) AS total,
                COUNT(DISTINCT CASE WHEN hasAction = true THEN app.id_ END) AS actioned,
                COUNT(DISTINCT CASE WHEN hasAction = false THEN app.id_ END) AS pending"
  - id: behaviorWidget
    name: ""
    label: Widget
    template: this_template
    enabled: true
    type: behavior_widget
    widget_type: behavior_widget
    dataSourceType: knowledgegraph
    allowed_params: true
    className: col-span-1
    query_id: ""
    input_params:
      endtime: $endtime
      behavior: $behavior
    queryFilters: []
    query: "MATCH (u:USER {subscriber: $subscriber, tenant: $tenant})-[:HAS_EMAIL]->(email:EMAIL)
            MATCH (email)-[auth_type]->(account:ACCOUNT)
            MATCH (account)-[:USING_APP]->(app:APPLICATION)
            MATCH (account)-[:HAS_FINDING]->(finding:FINDING)<-[:EVALUATED_TO]-(rule:RULE)-[:BELONGS_TO]->(behavior:BEHAVIOR {id: $behavior})

            OPTIONAL MATCH (finding)-[:TRIGGERED]->(a:ACTION)
            WHERE a.state IN ['open', 'inprogress']

            WITH DISTINCT app,
            COUNT(DISTINCT CASE WHEN a IS NOT NULL THEN account.id END) AS accountsWithActions,
            COUNT(DISTINCT CASE WHEN a IS NULL THEN account.id END) AS noActions
            WHERE toLower(COALESCE(app.name, app.domain, app.id)) =~ toLower('.*{searchText}.*')

            RETURN 
                COUNT(DISTINCT app) AS totalApps, 
                SUM(accountsWithActions) AS totalAccountsWithActions, 
                SUM(noActions) AS totalAccountsWithNoActions"
  - id: apps_detailed
    name: "Apps Detailed"
    label: Widget
    template: this_template
    enabled: true
    type: drilldown_widget
    widget_type: drilldown_widget
    dataSourceType: knowledgegraph
    allowed_params: true
    className: col-span-1
    query_id: ""
    input_params:
      endtime: $endtime
      appId: $appId
      behavior: $behavior
    queryFilters: []
    query: "MATCH (app:APPLICATION {id_: $appId})
            MATCH (app)<-[using_app:USING_APP]-(account:ACCOUNT)
            MATCH (account)-[:HAS_FINDING]->(finding:FINDING)
            MATCH (finding)<-[:EVALUATED_TO]-(rule:RULE)-[:BELONGS_TO]->(behavior:BEHAVIOR {id: $behavior})

            OPTIONAL MATCH (app)-[has:HAS_APP_SETTINGS]-(tenant:TENANT {id: $tenant})
            OPTIONAL MATCH (category:APP_CATEGORY {name: 'generative ai'})<-[:HAS_APP_CATEGORY]-(alternative_app:APPLICATION)-[has1:HAS_APP_SETTINGS]-(tenant1:TENANT {id: $tenant})
            WHERE COALESCE(has1.approval_status, alternative_app.approval_status, 'NOT SET') = 'APPROVED'

            OPTIONAL MATCH (app)-[:HAS_GRANT]-(:GRANT)-[:HAS_SCOPE]-(scope:SCOPE)
            WHERE scope.severity IN ['High', 'Medium', 'Low']

            OPTIONAL MATCH (finding)-[:TRIGGERED]->(action:ACTION)
            OPTIONAL MATCH (finding)-[:HAS_ARTIFACT]->(dlp:ORIGINAL_CLASS | FINAL_CLASS)

            WITH 
                app,
                has,
                dlp,
                scope,
                action,
                account,
                using_app,
                alternative_app

            WITH 
                app,
                has,
                dlp,
                scope,
                action,
                account,
                using_app,
                alternative_app,
                COLLECT(DISTINCT scope.severity) AS severityList

            RETURN
                COALESCE(app.id_, app.internalId) AS id,
                COALESCE(app.name, app.domain, app.id) AS app,
                app.logoUrl AS appLogoUrl,
                app.description AS description,
                MIN(using_app.creationTime) AS firstAccessed,
                MAX(using_app.last_access_time) AS lastAccessed,
                COALESCE(has.approval_status, 'Not Defined') AS approvalStatus,
                COALESCE(has.criticality, 'Not Defined') AS criticality,
                app.domain AS domain,
                CASE
                    WHEN app.complianceScore <= 2 THEN 'Very High'
                    WHEN app.complianceScore <= 4 THEN 'High'
                    WHEN app.complianceScore <= 6 THEN 'Moderate'
                    WHEN app.complianceScore <= 8 THEN 'Low'
                    WHEN app.complianceScore <= 10 THEN 'Very Low'
                    ELSE ''
                END AS complianceRisk,
                [key IN keys(app) WHERE key STARTS WITH 'Compliance' AND app[key] = true | 
                    replace(key, 'Compliance', '')] AS complianceList,
                CASE
                    WHEN app.securityScore <= 2 THEN 'Very High'
                    WHEN app.securityScore <= 4 THEN 'High'
                    WHEN app.securityScore <= 6 THEN 'Moderate'
                    WHEN app.securityScore <= 8 THEN 'Low'
                    WHEN app.securityScore <= 10 THEN 'Very Low'
                    ELSE ''
                END AS securityRisk,
                [
                    CASE 
                        WHEN app.SecuritySupportsSAML = true THEN 'SAML SUPPORTED' 
                        ELSE 'SAML NOT SUPPORTED' 
                    END,
                    CASE 
                        WHEN app.isMfaSupported = true THEN 'MFA SUPPORTED' 
                        ELSE 'MFA NOT SUPPORTED' 
                    END
                ] AS securitySupportedList,
                CASE
                    WHEN 'High' IN severityList THEN 'High'
                    WHEN 'Medium' IN severityList THEN 'Medium'
                    ELSE 'Low'
                END AS severityRisk,
                apoc.map.fromPairs(COLLECT([severityList, SIZE(severityList)])) AS oauthSeverity,
                apoc.map.fromPairs([
                    ['breachDate', app.breachDate],
                    ['breachDataClasses', app.breachDataClasses]
                ]) AS breachData,
                COLLECT(DISTINCT dlp.id) AS sensitiveDataClasses,
                COLLECT(DISTINCT alternative_app.name) AS alternativeApps,
                COUNT(DISTINCT CASE WHEN action IS NOT NULL THEN account.id END) AS accountsWithActions,
                COUNT(DISTINCT CASE WHEN action IS NULL THEN account.id END) AS accountsWithNoActions"
  - id: apps_detailed_BID_04
    name: "Apps Detailed"
    label: Widget
    template: this_template
    enabled: true
    type: drilldown_widget
    widget_type: drilldown_widget
    dataSourceType: knowledgegraph
    allowed_params: true
    className: col-span-1
    query_id: ""
    input_params:
      endtime: $endtime
      appId: $appId
      behavior: $behavior
    queryFilters: []
    query: "MATCH (app:APPLICATION {id_: $appId})
            MATCH (app)-[:USING_APP]-(account:ACCOUNT)-[]-(finding:FINDING)-[]-(rule:RULE)-[]-(behavior:BEHAVIOR {id: $behavior})
            MATCH (user:USER {subscriber: $subscriber, tenant: $tenant})-[]-(email:EMAIL)-[auth_type]-(account)
            
            OPTIONAL MATCH (app)-[]-(grant:GRANT)-[]-(scope:SCOPE)
            WHERE toLower(scope.severity) IN ['high', 'medium', 'low']
            OPTIONAL MATCH (app)-[has:HAS_APP_SETTINGS]-(tenant:TENANT {id: $tenant})
            OPTIONAL MATCH (finding)-[:TRIGGERED]-(action:ACTION)
            OPTIONAL MATCH (action)-[:RESULTED_IN]-(outcome:OUTCOME)
            OPTIONAL MATCH (finding)-[:HAS_ARTIFACT]->(dlp:DLP_FINAL_CLASS | DLP_ORIGINAL_CLASS)
            
            OPTIONAL MATCH (category)<-[:HAS_APP_CATEGORY]-(alternative_app:APPLICATION)-[has1:HAS_APP_SETTINGS]-(:TENANT {id: $tenant})
            WHERE COALESCE(has1.approval_status, alternative_app.approval_status, 'NOT SET') = 'APPROVED'
            
            WITH app, auth_type, account, COLLECT(DISTINCT scope.severity) as severities, has, finding, action, outcome, dlp, alternative_app
            
            WITH app, auth_type, account, severities, has, finding, action, dlp, alternative_app,
                COALESCE(action.name, '-') AS actionName,
                COUNT(DISTINCT action) AS actionCount,
                CASE WHEN action IS NOT NULL AND outcome IS NULL THEN 'Not Responded'
                    WHEN outcome IS NOT NULL THEN COALESCE(outcome.value, outcome.message, '-')
                END as outcomeValue
            WHERE actionName IS NOT NULL
            
            WITH app, auth_type, account, severities, has, finding, action, dlp, alternative_app, actionName, actionCount,
                outcomeValue, COUNT(outcomeValue) AS outcomeCount
            
            WITH app, auth_type, account, severities, has, finding, action, dlp, alternative_app, actionName, actionCount,
                apoc.map.fromPairs(COLLECT([outcomeValue, outcomeCount])) as outcomeMap
            
            WITH app, severities, has, alternative_app,
                COUNT(DISTINCT finding.id) as totalFindings,
                COUNT(DISTINCT CASE WHEN action IS NOT NULL THEN finding.id END) as actionedCount,
                COUNT(DISTINCT CASE WHEN action IS NULL THEN finding.id END) as pendingCount,
                MIN(COALESCE(
                    CASE WHEN account.creationTime <> '-' THEN account.creationTime ELSE NULL END, timestamp()
                )) AS firstAccessed,
                MAX(auth_type.last_access_time) AS lastAccessed,
                COLLECT(DISTINCT dlp.id) AS sensitiveDataClasses,
                apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, actionCount] END)) AS combinedActionTracker,
                apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, outcomeMap] END)) AS combinedActionOutcomes
            
            RETURN DISTINCT
                COALESCE(app.id_, app.internalId) AS id,
                COALESCE(app.name, app.domain, app.id) AS app,
                app.logoUrl AS appLogoUrl,
                app.description AS description,
                firstAccessed,
                lastAccessed,
                COALESCE(has.approval_status, 'Not Defined') AS approvalStatus,
                COALESCE(has.criticality, 'Not Defined') AS criticality,
                app.domain AS domain,
                CASE
                    WHEN app.complianceScore <= 2 THEN 'Very High'
                    WHEN app.complianceScore <= 4 THEN 'High'
                    WHEN app.complianceScore <= 6 THEN 'Moderate'
                    WHEN app.complianceScore <= 8 THEN 'Low'
                    WHEN app.complianceScore <= 10 THEN 'Very Low'
                    ELSE ''
                END AS complianceRisk,
                apoc.map.fromPairs([key IN keys(app) WHERE key STARTS WITH 'Compliance' | [replace(key, 'Compliance', ''), app[key] = true]]) AS complianceList,
                CASE
                    WHEN app.securityScore <= 2 THEN 'Very High'
                    WHEN app.securityScore <= 4 THEN 'High'
                    WHEN app.securityScore <= 6 THEN 'Moderate'
                    WHEN app.securityScore <= 8 THEN 'Low'
                    WHEN app.securityScore <= 10 THEN 'Very Low'
                    ELSE ''
                END AS securityRisk,
                apoc.map.fromPairs([key IN keys(app) WHERE key STARTS WITH 'Security' | [replace(key, 'Security', ''), app[key] = true]]) AS securitySupportedList,
                app.SecuritySupportsSAML = true AS isSamlSupported,
                app.isMfaSupported = true AS isMfaSupported,
                CASE
                    WHEN 'High' IN severities THEN 'High'
                    WHEN 'Medium' IN severities THEN 'Medium'
                    ELSE 'Low'
                END AS severityRisk,
                apoc.map.fromPairs([
                    ['High', SIZE([x IN severities WHERE toLower(x) = 'high'])],
                    ['Medium', SIZE([x IN severities WHERE toLower(x) = 'medium'])],
                    ['Low', SIZE([x IN severities WHERE toLower(x) = 'low'])]
                ]) AS oauthSeverity,
                apoc.map.fromPairs([
                    ['breachDate', app.breachDate],
                    ['breachDataClasses', app.breachDataClasses]
                ]) AS breachData,
                sensitiveDataClasses,
                COLLECT(DISTINCT alternative_app.name) AS alternativeApps,
                totalFindings,
                actionedCount,
                pendingCount,
                combinedActionTracker AS actionTracker,
                combinedActionOutcomes AS actionOutcomes"
  - id: apps_detailed_BID_02
    name: "Apps Detailed"
    label: Widget
    template: this_template
    enabled: true
    type: drilldown_widget
    widget_type: drilldown_widget
    dataSourceType: knowledgegraph
    allowed_params: true
    className: col-span-1
    query_id: ""
    input_params:
      endtime: $endtime
      appId: $appId
      behavior: $behavior
      accountId: $accountId
    queryFilters: []
    query: "MATCH (app:APPLICATION {id_: $appId})
            MATCH (app)-[:USING_APP]-(account:ACCOUNT)-[]-(finding:FINDING)-[]-(rule:RULE)-[]-(behavior:BEHAVIOR {id: $behavior})
            MATCH (user:USER {subscriber: $subscriber, tenant: $tenant})-[]-(email:EMAIL)-[auth_type]-(account)
            
            OPTIONAL MATCH (app)-[]-(grant:GRANT)-[]-(scope:SCOPE)
            WHERE toLower(scope.severity) IN ['high', 'medium', 'low']
            OPTIONAL MATCH (app)-[has:HAS_APP_SETTINGS]-(tenant:TENANT {id: $tenant})
            OPTIONAL MATCH (finding)-[:TRIGGERED]-(action:ACTION)
            OPTIONAL MATCH (action)-[:RESULTED_IN]-(outcome:OUTCOME)
            OPTIONAL MATCH (finding)-[:HAS_ARTIFACT]->(dlp:DLP_FINAL_CLASS | DLP_ORIGINAL_CLASS)
            
            WITH app, auth_type, account, COLLECT(DISTINCT scope.severity) as severities, has, finding, action, outcome, dlp
            
            WITH app, auth_type, account, severities, has, finding, action, dlp,
                COALESCE(action.name, '-') AS actionName,
                COUNT(DISTINCT action) AS actionCount,
                CASE WHEN action IS NOT NULL AND outcome IS NULL THEN 'Not Responded'
                    WHEN outcome IS NOT NULL THEN COALESCE(outcome.value, outcome.message, '-')
                END as outcomeValue
            WHERE actionName IS NOT NULL
            
            WITH app, auth_type, account, severities, has, finding, action, dlp, actionName, actionCount,
                outcomeValue, COUNT(outcomeValue) AS outcomeCount
            
            WITH app, auth_type, account, severities, has, finding, action, dlp, actionName, actionCount,
                apoc.map.fromPairs(COLLECT([outcomeValue, outcomeCount])) as outcomeMap
            
            WITH app, severities, has,
                COUNT(DISTINCT finding.id) as totalFindings,
                COUNT(DISTINCT CASE WHEN action IS NOT NULL THEN finding.id END) as actionedCount,
                COUNT(DISTINCT CASE WHEN action IS NULL THEN finding.id END) as pendingCount,
                MIN(COALESCE(
                    CASE WHEN account.creationTime <> '-' THEN account.creationTime ELSE NULL END, timestamp()
                )) AS firstAccessed,
                MAX(auth_type.last_access_time) AS lastAccessed,
                COLLECT(DISTINCT dlp.id) AS sensitiveDataClasses,
                apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, actionCount] END)) AS combinedActionTracker,
                apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, outcomeMap] END)) AS combinedActionOutcomes
            
            RETURN DISTINCT
                COALESCE(app.id_, app.internalId) AS id,
                COALESCE(app.name, app.domain, app.id) AS app,
                app.logoUrl AS appLogoUrl,
                app.description AS description,
                firstAccessed,
                lastAccessed,
                COALESCE(has.approval_status, 'Not Defined') AS approvalStatus,
                COALESCE(has.criticality, 'Not Defined') AS criticality,
                app.domain AS domain,
                CASE
                    WHEN app.complianceScore <= 2 THEN 'Very High'
                    WHEN app.complianceScore <= 4 THEN 'High'
                    WHEN app.complianceScore <= 6 THEN 'Moderate'
                    WHEN app.complianceScore <= 8 THEN 'Low'
                    WHEN app.complianceScore <= 10 THEN 'Very Low'
                    ELSE ''
                END AS complianceRisk,
                apoc.map.fromPairs([key IN keys(app) WHERE key STARTS WITH 'Compliance' | [replace(key, 'Compliance', ''), app[key] = true]]) AS complianceList,
                CASE
                    WHEN app.securityScore <= 2 THEN 'Very High'
                    WHEN app.securityScore <= 4 THEN 'High'
                    WHEN app.securityScore <= 6 THEN 'Moderate'
                    WHEN app.securityScore <= 8 THEN 'Low'
                    WHEN app.securityScore <= 10 THEN 'Very Low'
                    ELSE ''
                END AS securityRisk,
                apoc.map.fromPairs([key IN keys(app) WHERE key STARTS WITH 'Security' | [replace(key, 'Security', ''), app[key] = true]]) AS securitySupportedList,
                app.SecuritySupportsSAML = true AS isSamlSupported,
                app.isMfaSupported = true AS isMfaSupported,
                CASE
                    WHEN 'High' IN severities THEN 'High'
                    WHEN 'Medium' IN severities THEN 'Medium'
                    ELSE 'Low'
                END AS severityRisk,
                apoc.map.fromPairs([
                    ['High', SIZE([x IN severities WHERE toLower(x) = 'high'])],
                    ['Medium', SIZE([x IN severities WHERE toLower(x) = 'medium'])],
                    ['Low', SIZE([x IN severities WHERE toLower(x) = 'low'])]
                ]) AS oauthSeverity,
                apoc.map.fromPairs([
                    ['breachDate', app.breachDate],
                    ['breachDataClasses', app.breachDataClasses]
                ]) AS breachData,
                sensitiveDataClasses,
                totalFindings,
                actionedCount,
                pendingCount,
                combinedActionTracker AS actionTracker,
                combinedActionOutcomes AS actionOutcomes"
  - id: apps_detailed_BID_17
    name: "Apps Detailed"
    label: Widget
    template: this_template
    enabled: true
    type: drilldown_widget
    widget_type: drilldown_widget
    dataSourceType: knowledgegraph
    allowed_params: true
    className: col-span-1
    query_id: ""
    input_params:
      endtime: $endtime
      appId: $appId
      behavior: $behavior
      accountId: $accountId
    queryFilters: []
    query: "MATCH (app:APPLICATION {id_: $appId})
            MATCH (app)-[:USING_APP]-(account:ACCOUNT)-[]-(finding:FINDING)-[]-(rule:RULE)-[]-(behavior:BEHAVIOR {id: $behavior})
            MATCH (user:USER {subscriber: $subscriber, tenant: $tenant})-[]-(email:EMAIL)-[auth_type]-(account)
            
            OPTIONAL MATCH (app)-[]-(grant:GRANT)-[]-(scope:SCOPE)
            WHERE toLower(scope.severity) IN ['high', 'medium', 'low']
            OPTIONAL MATCH (app)-[has:HAS_APP_SETTINGS]-(tenant:TENANT {id: $tenant})
            OPTIONAL MATCH (finding)-[:TRIGGERED]-(action:ACTION)
            OPTIONAL MATCH (action)-[:RESULTED_IN]-(outcome:OUTCOME)
            OPTIONAL MATCH (finding)-[:HAS_ARTIFACT]->(dlp:DLP_FINAL_CLASS | DLP_ORIGINAL_CLASS)
            
            WITH app, auth_type, account, COLLECT(DISTINCT scope.severity) as severities, has, finding, action, outcome, dlp
            
            WITH app, auth_type, account, severities, has, finding, action, dlp,
                COALESCE(action.name, '-') AS actionName,
                COUNT(DISTINCT action) AS actionCount,
                CASE WHEN action IS NOT NULL AND outcome IS NULL THEN 'Not Responded'
                    WHEN outcome IS NOT NULL THEN COALESCE(outcome.value, outcome.message, '-')
                END as outcomeValue
            WHERE actionName IS NOT NULL
            
            WITH app, auth_type, account, severities, has, finding, action, dlp, actionName, actionCount,
                outcomeValue, COUNT(outcomeValue) AS outcomeCount
            
            WITH app, auth_type, account, severities, has, finding, action, dlp, actionName, actionCount,
                apoc.map.fromPairs(COLLECT([outcomeValue, outcomeCount])) as outcomeMap
            
            WITH app, severities, has,
                COUNT(DISTINCT finding.id) as totalFindings,
                COUNT(DISTINCT CASE WHEN action IS NOT NULL THEN finding.id END) as actionedCount,
                COUNT(DISTINCT CASE WHEN action IS NULL THEN finding.id END) as pendingCount,
                MIN(COALESCE(
                    CASE WHEN account.creationTime <> '-' THEN account.creationTime ELSE NULL END, timestamp()
                )) AS firstAccessed,
                MAX(auth_type.last_access_time) AS lastAccessed,
                COLLECT(DISTINCT dlp.id) AS sensitiveDataClasses,
                apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, actionCount] END)) AS combinedActionTracker,
                apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, outcomeMap] END)) AS combinedActionOutcomes
            
            RETURN DISTINCT
                COALESCE(app.id_, app.internalId) AS id,
                COALESCE(app.name, app.domain, app.id) AS app,
                app.logoUrl AS appLogoUrl,
                app.description AS description,
                firstAccessed,
                lastAccessed,
                COALESCE(has.approval_status, 'Not Defined') AS approvalStatus,
                COALESCE(has.criticality, 'Not Defined') AS criticality,
                app.domain AS domain,
                CASE
                    WHEN app.complianceScore <= 2 THEN 'Very High'
                    WHEN app.complianceScore <= 4 THEN 'High'
                    WHEN app.complianceScore <= 6 THEN 'Moderate'
                    WHEN app.complianceScore <= 8 THEN 'Low'
                    WHEN app.complianceScore <= 10 THEN 'Very Low'
                    ELSE ''
                END AS complianceRisk,
                apoc.map.fromPairs([key IN keys(app) WHERE key STARTS WITH 'Compliance' | [replace(key, 'Compliance', ''), app[key] = true]]) AS complianceList,
                CASE
                    WHEN app.securityScore <= 2 THEN 'Very High'
                    WHEN app.securityScore <= 4 THEN 'High'
                    WHEN app.securityScore <= 6 THEN 'Moderate'
                    WHEN app.securityScore <= 8 THEN 'Low'
                    WHEN app.securityScore <= 10 THEN 'Very Low'
                    ELSE ''
                END AS securityRisk,
                apoc.map.fromPairs([key IN keys(app) WHERE key STARTS WITH 'Security' | [replace(key, 'Security', ''), app[key] = true]]) AS securitySupportedList,
                app.SecuritySupportsSAML = true AS isSamlSupported,
                app.isMfaSupported = true AS isMfaSupported,
                CASE
                    WHEN 'High' IN severities THEN 'High'
                    WHEN 'Medium' IN severities THEN 'Medium'
                    ELSE 'Low'
                END AS severityRisk,
                apoc.map.fromPairs([
                    ['High', SIZE([x IN severities WHERE toLower(x) = 'high'])],
                    ['Medium', SIZE([x IN severities WHERE toLower(x) = 'medium'])],
                    ['Low', SIZE([x IN severities WHERE toLower(x) = 'low'])]
                ]) AS oauthSeverity,
                apoc.map.fromPairs([
                    ['breachDate', app.breachDate],
                    ['breachDataClasses', app.breachDataClasses]
                ]) AS breachData,
                sensitiveDataClasses,
                totalFindings,
                actionedCount,
                pendingCount,
                combinedActionTracker AS actionTracker,
                combinedActionOutcomes AS actionOutcomes"
  - id: apps_detailed_BID_21
    name: "Blocked AI Apps Detailed"
    label: Widget
    template: this_template
    enabled: true
    type: drilldown_widget
    widget_type: drilldown_widget
    dataSourceType: knowledgegraph
    allowed_params: true
    className: col-span-1
    query_id: ""
    input_params:
      endtime: $endtime
      appId: $appId
      behavior: $behavior
    queryFilters: []
    query: "MATCH (app:APPLICATION {id_: $appId})
            MATCH (app)-[:USING_APP]-(account:ACCOUNT)-[]-(finding:FINDING)-[]-(rule:RULE)-[]-(behavior:BEHAVIOR {id: $behavior})
            MATCH (user:USER {subscriber: $subscriber, tenant: $tenant})-[]-(email:EMAIL)-[auth_type]-(account)
            
            OPTIONAL MATCH (app)-[]-(grant:GRANT)-[]-(scope:SCOPE)
            WHERE toLower(scope.severity) IN ['high', 'medium', 'low']
            OPTIONAL MATCH (app)-[has:HAS_APP_SETTINGS]-(tenant:TENANT {id: $tenant})
            OPTIONAL MATCH (finding)-[:TRIGGERED]-(action:ACTION)
            OPTIONAL MATCH (action)-[:RESULTED_IN]-(outcome:OUTCOME)
            OPTIONAL MATCH (finding)-[:HAS_ARTIFACT]->(dlp:DLP_FINAL_CLASS | DLP_ORIGINAL_CLASS)
            
            OPTIONAL MATCH (category)<-[:HAS_APP_CATEGORY]-(alternative_app:APPLICATION)-[has1:HAS_APP_SETTINGS]-(:TENANT {id: $tenant})
            WHERE COALESCE(has1.approval_status, alternative_app.approval_status, 'NOT SET') = 'APPROVED'
            
            WITH app, auth_type, account, COLLECT(DISTINCT scope.severity) as severities, has, finding, action, outcome, dlp, alternative_app
            
            WITH app, auth_type, account, severities, has, finding, action, dlp, alternative_app,
                COALESCE(action.name, '-') AS actionName,
                COUNT(DISTINCT action) AS actionCount,
                CASE WHEN action IS NOT NULL AND outcome IS NULL THEN 'Not Responded'
                    WHEN outcome IS NOT NULL THEN COALESCE(outcome.value, outcome.message, '-')
                END as outcomeValue
            WHERE actionName IS NOT NULL
            
            WITH app, auth_type, account, severities, has, finding, action, dlp, alternative_app, actionName, actionCount,
                outcomeValue, COUNT(outcomeValue) AS outcomeCount
            
            WITH app, auth_type, account, severities, has, finding, action, dlp, alternative_app, actionName, actionCount,
                apoc.map.fromPairs(COLLECT([outcomeValue, outcomeCount])) as outcomeMap
            
            WITH app, severities, has, alternative_app,
                COUNT(DISTINCT finding.id) as totalFindings,
                COUNT(DISTINCT CASE WHEN action IS NOT NULL THEN finding.id END) as actionedCount,
                COUNT(DISTINCT CASE WHEN action IS NULL THEN finding.id END) as pendingCount,
                MIN(COALESCE(
                    CASE WHEN account.creationTime <> '-' THEN account.creationTime ELSE NULL END, timestamp()
                )) AS firstAccessed,
                MAX(auth_type.last_access_time) AS lastAccessed,
                COLLECT(DISTINCT dlp.id) AS sensitiveDataClasses,
                apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, actionCount] END)) AS combinedActionTracker,
                apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, outcomeMap] END)) AS combinedActionOutcomes
            
            RETURN DISTINCT
                COALESCE(app.id_, app.internalId) AS id,
                COALESCE(app.name, app.domain, app.id) AS app,
                app.logoUrl AS appLogoUrl,
                app.description AS description,
                firstAccessed,
                lastAccessed,
                COALESCE(has.approval_status, 'Not Defined') AS approvalStatus,
                COALESCE(has.criticality, 'Not Defined') AS criticality,
                app.domain AS domain,
                CASE
                    WHEN app.complianceScore <= 2 THEN 'Very High'
                    WHEN app.complianceScore <= 4 THEN 'High'
                    WHEN app.complianceScore <= 6 THEN 'Moderate'
                    WHEN app.complianceScore <= 8 THEN 'Low'
                    WHEN app.complianceScore <= 10 THEN 'Very Low'
                    ELSE ''
                END AS complianceRisk,
                apoc.map.fromPairs([key IN keys(app) WHERE key STARTS WITH 'Compliance' | [replace(key, 'Compliance', ''), app[key] = true]]) AS complianceList,
                CASE
                    WHEN app.securityScore <= 2 THEN 'Very High'
                    WHEN app.securityScore <= 4 THEN 'High'
                    WHEN app.securityScore <= 6 THEN 'Moderate'
                    WHEN app.securityScore <= 8 THEN 'Low'
                    WHEN app.securityScore <= 10 THEN 'Very Low'
                    ELSE ''
                END AS securityRisk,
                apoc.map.fromPairs([key IN keys(app) WHERE key STARTS WITH 'Security' | [replace(key, 'Security', ''), app[key] = true]]) AS securitySupportedList,
                app.SecuritySupportsSAML = true AS isSamlSupported,
                app.isMfaSupported = true AS isMfaSupported,
                CASE
                    WHEN 'High' IN severities THEN 'High'
                    WHEN 'Medium' IN severities THEN 'Medium'
                    ELSE 'Low'
                END AS severityRisk,
                apoc.map.fromPairs([
                    ['High', SIZE([x IN severities WHERE toLower(x) = 'high'])],
                    ['Medium', SIZE([x IN severities WHERE toLower(x) = 'medium'])],
                    ['Low', SIZE([x IN severities WHERE toLower(x) = 'low'])]
                ]) AS oauthSeverity,
                apoc.map.fromPairs([
                    ['breachDate', app.breachDate],
                    ['breachDataClasses', app.breachDataClasses]
                ]) AS breachData,
                sensitiveDataClasses,
                COLLECT(DISTINCT alternative_app.name) AS alternativeApps,
                totalFindings,
                actionedCount,
                pendingCount,
                combinedActionTracker AS actionTracker,
                combinedActionOutcomes AS actionOutcomes"
  - id: apps_detailed_BID_01
    name: "Apps Detailed"
    label: Widget
    template: this_template
    enabled: true
    type: drilldown_widget
    widget_type: drilldown_widget
    dataSourceType: knowledgegraph
    allowed_params: true
    className: col-span-1
    query_id: ""
    input_params:
      endtime: $endtime
      appId: $appId
      behavior: $behavior
      accountId: $accountId
    queryFilters: []
    query: "MATCH (app:APPLICATION {id_: $appId})
            MATCH (app)-[:USING_APP]-(account:ACCOUNT)-[]-(finding:FINDING)-[]-(rule:RULE)-[]-(behavior:BEHAVIOR {id: $behavior})
            MATCH (user:USER {subscriber: $subscriber, tenant: $tenant})-[]-(email:EMAIL)-[auth_type]-(account)
            
            OPTIONAL MATCH (app)-[]-(grant:GRANT)-[]-(scope:SCOPE)
            WHERE toLower(scope.severity) IN ['high', 'medium', 'low']
            OPTIONAL MATCH (app)-[has:HAS_APP_SETTINGS]-(tenant:TENANT {id: $tenant})
            OPTIONAL MATCH (finding)-[:TRIGGERED]-(action:ACTION)
            OPTIONAL MATCH (action)-[:RESULTED_IN]-(outcome:OUTCOME)
            
            WITH app, auth_type, account, COLLECT(DISTINCT scope.severity) as severities, has, finding, action, outcome
            
            WITH app, auth_type, account, severities, has, finding, action,
                COALESCE(action.name, '-') AS actionName,
                COUNT(DISTINCT action) AS actionCount,
                CASE WHEN action IS NOT NULL AND outcome IS NULL THEN 'Not Responded'
                    WHEN outcome IS NOT NULL THEN COALESCE(outcome.value, outcome.message, '-')
                END as outcomeValue
            WHERE actionName IS NOT NULL
            
            WITH app, auth_type, account, severities, has, finding, action, actionName, actionCount,
                outcomeValue, COUNT(outcomeValue) AS outcomeCount
            
            WITH app, auth_type, account, severities, has, finding, action, actionName, actionCount,
                apoc.map.fromPairs(COLLECT([outcomeValue, outcomeCount])) as outcomeMap
            
            WITH app, severities, has,
                COUNT(DISTINCT finding.id) as totalFindings,
                COUNT(DISTINCT CASE WHEN action IS NOT NULL THEN finding.id END) as actionedCount,
                COUNT(DISTINCT CASE WHEN action IS NULL THEN finding.id END) as pendingCount,
                MIN(COALESCE(
                    CASE WHEN account.creationTime <> '-' THEN account.creationTime ELSE NULL END, timestamp()
                )) AS firstAccessed,
                MAX(auth_type.last_access_time) AS lastAccessed,
                apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, actionCount] END)) AS combinedActionTracker,
                apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, outcomeMap] END)) AS combinedActionOutcomes
            
            RETURN DISTINCT
                COALESCE(app.id_, app.internalId) AS id,
                COALESCE(app.name, app.domain, app.id) AS app,
                app.logoUrl AS appLogoUrl,
                app.description AS description,
                firstAccessed,
                lastAccessed,
                COALESCE(has.approval_status, 'Not Defined') AS approvalStatus,
                COALESCE(has.criticality, 'Not Defined') AS criticality,
                app.domain AS domain,
                CASE
                    WHEN app.complianceScore <= 2 THEN 'Very High'
                    WHEN app.complianceScore <= 4 THEN 'High'
                    WHEN app.complianceScore <= 6 THEN 'Moderate'
                    WHEN app.complianceScore <= 8 THEN 'Low'
                    WHEN app.complianceScore <= 10 THEN 'Very Low'
                    ELSE ''
                END AS complianceRisk,
                apoc.map.fromPairs([key IN keys(app) WHERE key STARTS WITH 'Compliance' | [replace(key, 'Compliance', ''), app[key] = true]]) AS complianceList,
                CASE
                    WHEN app.securityScore <= 2 THEN 'Very High'
                    WHEN app.securityScore <= 4 THEN 'High'
                    WHEN app.securityScore <= 6 THEN 'Moderate'
                    WHEN app.securityScore <= 8 THEN 'Low'
                    WHEN app.securityScore <= 10 THEN 'Very Low'
                    ELSE ''
                END AS securityRisk,
                apoc.map.fromPairs([key IN keys(app) WHERE key STARTS WITH 'Security' | [replace(key, 'Security', ''), app[key] = true]]) AS securitySupportedList,
                app.SecuritySupportsSAML = true AS isSamlSupported,
                app.isMfaSupported = true AS isMfaSupported,
                CASE
                    WHEN 'High' IN severities THEN 'High'
                    WHEN 'Medium' IN severities THEN 'Medium'
                    ELSE 'Low'
                END AS severityRisk,
                apoc.map.fromPairs([
                    ['High', SIZE([x IN severities WHERE toLower(x) = 'high'])],
                    ['Medium', SIZE([x IN severities WHERE toLower(x) = 'medium'])],
                    ['Low', SIZE([x IN severities WHERE toLower(x) = 'low'])]
                ]) AS oauthSeverity,
                apoc.map.fromPairs([
                    ['breachDate', app.breachDate],
                    ['breachDataClasses', app.breachDataClasses]
                ]) AS breachData,
                totalFindings,
                actionedCount,
                pendingCount,
                combinedActionTracker AS actionTracker,
                combinedActionOutcomes AS actionOutcomes"
  - id: apps_detailed_BID_03
    name: "Apps Detailed"
    label: Widget
    template: this_template
    enabled: true
    type: drilldown_widget
    widget_type: drilldown_widget
    dataSourceType: knowledgegraph
    allowed_params: true
    className: col-span-1
    query_id: ""
    input_params:
      endtime: $endtime
      appId: $appId
      behavior: $behavior
      accountId: $accountId
    queryFilters: []
    query: "MATCH (app:APPLICATION {id_: $appId})
            MATCH (app)-[:USING_APP]-(account:ACCOUNT)-[]-(finding:FINDING)-[]-(rule:RULE)-[]-(behavior:BEHAVIOR {id: $behavior})
            MATCH (user:USER {subscriber: $subscriber, tenant: $tenant})-[]-(email:EMAIL)-[auth_type]-(account)
            
            OPTIONAL MATCH (app)-[]-(grant:GRANT)-[]-(scope:SCOPE)
            WHERE toLower(scope.severity) IN ['high', 'medium', 'low']
            OPTIONAL MATCH (app)-[has:HAS_APP_SETTINGS]-(tenant:TENANT {id: $tenant})
            OPTIONAL MATCH (finding)-[:TRIGGERED]-(action:ACTION)
            OPTIONAL MATCH (action)-[:RESULTED_IN]-(outcome:OUTCOME)
            OPTIONAL MATCH (finding)-[:HAS_ARTIFACT]->(dlp:DLP_FINAL_CLASS | DLP_ORIGINAL_CLASS)
            OPTIONAL MATCH (other_app:APPLICATION)<-[using_app:USING_APP]-(:ACCOUNT)-[:HAS_FINDING]->(:FINDING)-[:HAS_ARTIFACT]-(:DLP_ORIGINAL_CLASS | DLP_FINAL_CLASS)
            
            OPTIONAL MATCH (category)<-[:HAS_APP_CATEGORY]-(alternative_app:APPLICATION)-[has1:HAS_APP_SETTINGS]-(:TENANT {id: $tenant})
            WHERE COALESCE(has1.approval_status, alternative_app.approval_status, 'NOT SET') = 'APPROVED'
            
            WITH app, auth_type, account, COLLECT(DISTINCT scope.severity) as severities, has, finding, action, outcome, dlp, alternative_app, 
                COLLECT(DISTINCT other_app.name) AS otherAppsDateShared, 
                apoc.date.format(finding.creationTime, 'ms', 'yyyy-MM-dd') AS date,
                COUNT(finding) AS findingCount
            WITH app, auth_type, account, severities, has, finding, dlp, alternative_app, otherAppsDateShared,
                collect({date: date, count: findingCount}) AS initialTimeline,
                range(0, 59) as dayRange,
                COALESCE(action.name, '-') AS actionName,
                COUNT(DISTINCT action.id) AS actionCount,
                CASE WHEN action IS NOT NULL AND outcome IS NULL THEN 'Not Responded'
                    WHEN outcome IS NOT NULL THEN COALESCE(outcome.value, outcome.message, '-')
                END as outcomeValue,
                COUNT(DISTINCT action.id) as outcomeCount,
                COUNT(DISTINCT CASE WHEN action IS NOT NULL THEN finding.id END) as actionedCount,
                COUNT(DISTINCT CASE WHEN action IS NULL THEN finding.id END) as pendingCount
            WHERE actionName IS NOT NULL
            
            UNWIND dayRange as day
            
            WITH app, auth_type, account, severities, has, finding, dlp, alternative_app, otherAppsDateShared,
                actionName, actionCount, actionedCount, pendingCount, initialTimeline,
                apoc.map.fromPairs(COLLECT([outcomeValue, outcomeCount])) as outcomeMap,
                apoc.date.format(datetime().epochMillis - (day * 24 * 60 * 60 * 1000), 'ms', 'yyyy-MM-dd') AS dateStr
            
            WITH app, auth_type, account, severities, has, finding, dlp, alternative_app, otherAppsDateShared,
                actionName, actionCount, actionedCount, pendingCount, outcomeMap,
                COLLECT({
                    date: dateStr,
                    count: CASE 
                        WHEN any(t IN initialTimeline WHERE t.date = dateStr) 
                        THEN head([t IN initialTimeline WHERE t.date = dateStr]).count 
                        ELSE 0 
                    END
                }) AS dlpTimeline
            
            RETURN DISTINCT
                COALESCE(app.id_, app.internalId) AS id,
                COALESCE(app.name, app.domain, app.id) AS app,
                app.logoUrl AS appLogoUrl,
                app.description AS description,
                MIN(COALESCE(
                    CASE WHEN account.creationTime <> '-' THEN account.creationTime ELSE NULL END, timestamp()
                )) AS firstAccessed,
                MAX(auth_type.last_access_time) AS lastAccessed,
                COALESCE(has.approval_status, 'Not Defined') AS approvalStatus,
                COALESCE(has.criticality, 'Not Defined') AS criticality,
                app.domain AS domain,
                CASE
                    WHEN app.complianceScore <= 2 THEN 'Very High'
                    WHEN app.complianceScore <= 4 THEN 'High'
                    WHEN app.complianceScore <= 6 THEN 'Moderate'
                    WHEN app.complianceScore <= 8 THEN 'Low'
                    WHEN app.complianceScore <= 10 THEN 'Very Low'
                    ELSE ''
                END AS complianceRisk,
                apoc.map.fromPairs([key IN keys(app) WHERE key STARTS WITH 'Compliance' | [replace(key, 'Compliance', ''), app[key] = true]]) AS complianceList,
                CASE
                    WHEN app.securityScore <= 2 THEN 'Very High'
                    WHEN app.securityScore <= 4 THEN 'High'
                    WHEN app.securityScore <= 6 THEN 'Moderate'
                    WHEN app.securityScore <= 8 THEN 'Low'
                    WHEN app.securityScore <= 10 THEN 'Very Low'
                    ELSE ''
                END AS securityRisk,
                apoc.map.fromPairs([key IN keys(app) WHERE key STARTS WITH 'Security' | [replace(key, 'Security', ''), app[key] = true]]) AS securitySupportedList,
                app.SecuritySupportsSAML = true AS isSamlSupported,
                app.isMfaSupported = true AS isMfaSupported,
                CASE
                    WHEN 'High' IN severities THEN 'High'
                    WHEN 'Medium' IN severities THEN 'Medium'
                    ELSE 'Low'
                END AS severityRisk,
                apoc.map.fromPairs([
                    ['High', SIZE([x IN severities WHERE toLower(x) = 'high'])],
                    ['Medium', SIZE([x IN severities WHERE toLower(x) = 'medium'])],
                    ['Low', SIZE([x IN severities WHERE toLower(x) = 'low'])]
                ]) AS oauthSeverity,
                apoc.map.fromPairs([
                    ['breachDate', app.breachDate],
                    ['breachDataClasses', app.breachDataClasses]
                ]) AS breachData,
                otherAppsDateShared,
                COLLECT(DISTINCT dlp.id) AS sensitiveDataClasses,
                COLLECT(DISTINCT alternative_app.name) AS alternativeApps,
                COUNT(DISTINCT finding.id) as totalFindings,
                actionedCount,
                pendingCount,
                apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, actionCount] END)) AS actionTracker,
                apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, outcomeMap] END)) AS actionOutcomes,
                dlpTimeline"
table_render:
  insights:
    queries:
      - id: "aiTrend"
        queryParam: posture
        paramValue: posture
        defaultValue: "AI Risk"
      - id: "appsGraph"
        queryParam: limit
        paramValue: limit
        defaultValue: "1"
      - id: "behaviorWidget"
        queryParam: behavior
        paramValue: code
  viewby:
    queries:
      - id: "status"
        queryParam: approvalStatus
        paramValue: approvalStatus
  table_additional_data:
    no_hover: true
    row_border: true
    alternate_row_colors: true
    no_table_padding: true
    table_heading_bg: bg-dark-300
    table_filters_wrapper_class: grid grid-cols-12
    no_calendar: true
    no_drilldown: true
  table_filters:
  apps_table:
    application:
      id: application
      type: ApplicationView
      label: Application
      valuePath: application
      sortable: false
      order: 1
    approval_status:
      id: approval_status
      type: StatusView
      label: Approval Status
      valuePath: approvalStatus
      sortable: false
      order: 2
    no_of_accounts:
      id: no_of_accounts
      type: NumberView
      label: No. of Accounts
      valuePath: totalAccounts
      sortable: false
      order: 3
    first_seen:
      id: first_seen
      type: DateView
      label: First Seen
      valuePath: firstAccessTime
      sortable: false
      order: 4
    last_seen:
      id: last_seen
      type: DateView
      label: Last Seen
      valuePath: lastAccessTime
      sortable: false
      order: 5
    review_status:
      id: review_status
      type: ReviewStatusView
      label: Review Status
      valuePath: reviewStatus
      sortable: false
      order: 6
    action_results:
      id: action_results
      type: ActionResultsView
      label: Action Results
      valuePath: actionResults
      sortable: false
      order: 7
    accounts_with_findings:
      id: accounts_with_findings
      type: ModalView
      label: Accounts with Findings
      valuePath: accountsWithFindings
      sortable: false
      order: 8
    category:
      id: category
      type: CategoryView
      label: Category
      valuePath: category
      sortable: false
      order: 9
      optional: true
    usage_level:
      id: usage_level
      type: UsageView
      label: Usage Level
      valuePath: usageLevel
      sortable: false
      order: 10
      optional: true
    technical_owner:
      id: technical_owner
      type: OwnerView
      label: Technical Owner
      valuePath: technicalOwner
      sortable: false
      order: 11
      optional: true
    criticality:
      id: criticality
      type: CriticalityView
      label: Criticality
      valuePath: criticality
      sortable: false
      order: 12
      optional: true
    newly_discovered:
      id: newly_discovered
      type: StatusView
      label: Newly Discovered
      valuePath: newlyDiscovered
      sortable: false
      order: 13
      optional: true
    risk_level:
      id: risk_level
      type: RiskView
      label: Risk Level
      valuePath: riskLevel
      sortable: false
      order: 14
      optional: true
  accounts_table:
    account:
      id: account
      type: AccountView
      label: Account
      valuePath: account
      sortable: false
      order: 1
    app_category:
      id: app_category
      type: TextWithEditView
      label: App Category
      valuePath: appCategory
      sortable: false
      order: 2
    app_status:
      id: app_status
      type: TextView
      label: App Status
      valuePath: appStatus
      sortable: false
      order: 3
    first_seen:
      id: first_seen
      type: DateColumnCellView
      label: First Seen
      valuePath: firstSeen
      sortable: false
      order: 4
    last_seen:
      id: last_seen
      type: DateColumnCellView
      label: Last Seen
      valuePath: lastSeen
      sortable: false
      order: 5
    review_status:
      id: review_status
      type: ReviewStatusView
      label: Review Status
      valuePath: reviewStatus
      sortable: false
      order: 7
    technical_owner:
      id: technical_owner
      type: TextView
      label: Technical Owner
      valuePath: technicalOwner
      sortable: false
      order: 8
  BID_04:
    application:
      id: application
      type: ApplicationView
      label: Application
      valuePath: application
      sortable: false
      order: 1
    approval_status:
      id: approval_status
      type: StatusView
      label: Approval Status
      valuePath: approvalStatus
      sortable: false
      order: 2
    no_of_accounts:
      id: no_of_accounts
      type: NumberView
      label: No. of Accounts
      valuePath: totalAccounts
      sortable: false
      order: 3
    first_seen:
      id: first_seen
      type: DateView
      label: First Seen
      valuePath: firstAccessTime
      sortable: false
      order: 4
    last_seen:
      id: last_seen
      type: DateView
      label: Last Seen
      valuePath: lastAccessTime
      sortable: false
      order: 5
    sensitive_data_shared:
      id: sensitive_data_shared
      type: TextView
      label: Sensitive Data Shared
      valuePath: SensitiveDataShared
      sortable: false
      order: 6
    risky_oauth_scopes:
      id: risky_oauth_scopes
      type: TextView
      label: Risky Oauth Scopes
      valuePath: RiskyOauthScopes
      sortable: false
      order: 7
    review_status:
      id: review_status
      type: ReviewStatusView
      label: Review Status
      valuePath: reviewStatus
      sortable: false
      order: 8
    action_results:
      id: action_results
      type: ActionResultsView
      label: Action Results
      valuePath: actionResults
      sortable: false
      order: 9
    accounts_with_findings:
      id: accounts_with_findings
      type: ModalView
      label: Accounts with Findings
      valuePath: accountsWithFindings
      sortable: false
      order: 10
    criticality:
      id: criticality
      type: CriticalityView
      label: Criticality
      valuePath: criticality
      sortable: false
      order: 11
      optional: true
  ai_applications_with_risky_oauth_scopes:
  newly_introduced_ai_users:
  users_leaking_sensitive_data:
pagination_query:
  query: "MATCH (u:USER)-[:HAS_EMAIL]->(email:EMAIL)
    OPTIONAL MATCH (u)-[:HAS_MANAGER]->(manager: USER)
    OPTIONAL MATCH (email)-[hasaccount]->(account:ACCOUNT)
    OPTIONAL MATCH (account)-[:HAS_BROWSER]->(browser:BROWSER)
    OPTIONAL MATCH (account)-[:USING_APP]->(app:APPLICATION)
    OPTIONAL MATCH (u)-[:BELONGS_TO]->(g:GROUP{userDefined : true})
    OPTIONAL MATCH (account)-[hi:HAS_ISSUE]->(i:ISSUE)
    OPTIONAL MATCH (r:RULE)-[:EVALUATED_TO]->(i)
    OPTIONAL MATCH (rule)-[:BELONGS_TO]->(behavior:behavior)
    OPTIONAL MATCH (behavior)-[:BELONGS_TO]->(posture:POSTURE)
    WHERE
    u.subscriber = $subscriber
    AND u.tenant = $tenant
    AND toLower(u.displayName) =~ '.*{searchText}.*'
    {placeholder}
    RETURN
    COUNT(DISTINCT u.id) AS totalCount"
  dataSourceType: knowledgegraph
table_widget: []
