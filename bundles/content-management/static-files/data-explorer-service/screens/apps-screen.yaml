id: a80dd540-8134-43aa-a6e0-393fe4de6cb9
name: Applications
type: screen
enabled: true
version: 1.0.788
icon_url: https://staticcontent1.blob.core.windows.net/finding-icons/apps-svgrepo-com-2.svg
table_query:
  id: 745c143e-0853-4975-9817-c004ec43cf8c
  name: Display Table Data
  queryString: "
    MATCH (email:EMAIL {subscriber: $subscriber, tenant: $tenant})-[auth]-(account:ACCOUNT)-[:USING_APP]-(app:APPLICATION)
    USING INDEX email:EMAIL(subscriber, tenant)
    
    // Early aggregation to reduce data volume\n
    WITH app,
        COLLECT(DISTINCT {auth: type(auth), account: account, last_accessed: auth.last_access_time, auth_rel: auth}) AS auth_data
    WHERE app.domain IS NOT NULL AND NOT app.domain IN ['','-']
    
    // Optimized critical property access first\n
    WITH app, 
         COALESCE(CASE WHEN NOT app.name IN ['', '-'] THEN app.name END, app.domain) AS app_name,
         auth_data
    
    WHERE app_name IS NOT NULL
        AND CASE '{searchText}'
          WHEN <> '' THEN toLower(btrim(app_name)) contains toLower('{searchText}')
          ELSE true
        END
    
    // Convert optional matches to pattern comprehensions\n
    OPTIONAL MATCH (app)-[:HAS_APP_CATEGORY]->(category:APP_CATEGORY)
    WITH app, app_name, COLLECT(DISTINCT category.name) AS categories, auth_data
    
    // Optimized admin lookup using pattern comprehension\n
    WITH app, app_name, categories,
        apoc.coll.toSet(
            [(app)-[:HAS_ADMIN]->(admin_account:ACCOUNT)--(:EMAIL)--(app_admin:USER {subscriber: $subscriber, tenant: $tenant}) | {userId: app_admin.id, displayName: app_admin.displayName, profilePic: app_admin.profilePicUrl, email: app_admin.mail}]
        ) AS owners,
        auth_data
    
    // Consolidated tenant settings lookup\n
    OPTIONAL MATCH (app)<-[hs:HAS_APP_SETTINGS]-(:TENANT {tenant: $tenant})
    WITH app, app_name, categories, owners,
        COALESCE(hs.criticality, app.criticality, 'NOT SET') AS app_criticality,
        COALESCE(
            CASE WHEN hs.approval_status <> '-' THEN hs.approval_status ELSE NULL END, 
            CASE WHEN app.approval_status <> '-' THEN app.approval_status ELSE NULL END, 
            'NEEDS REVIEW'
        ) AS app_status,
        COALESCE(
            CASE WHEN hs.isLicensed <> '-' THEN hs.isLicensed ELSE NULL END, 
            'No'
        ) AS isLicensed,
        COALESCE(
            CASE WHEN hs.isBlocked <> '-' THEN hs.isBlocked ELSE NULL END, 
            'No'
        ) AS isBlocked,
        auth_data
    
    // Pre-calculate risk levels before aggregation\n
    WITH *, CASE app.totalScore
        WHEN <= 2 THEN 'Very High'
        WHEN <= 4 THEN 'High'
        WHEN <= 6 THEN 'Moderate'
        WHEN <= 8 THEN 'Low'
        WHEN <= 10 THEN 'Very Low'
        ELSE 'Unknown' 
      END AS appRiskLevel
    
    WITH app, app_name, app_criticality, app_status, isLicensed, isBlocked, appRiskLevel, categories, owners,
        auth_data,
        datetime().epochMillis - duration('P1M').days*86400000 AS one_month_ago_epoch
    
	OPTIONAL MATCH (app)-[:WHITELISTED_FOR {subscriber: $subscriber, tenant: $tenant}]->(behavior:BEHAVIOR)
    WITH app, app_name, app_criticality, app_status, isLicensed, isBlocked, appRiskLevel, categories, owners, auth_data, one_month_ago_epoch,
    COLLECT(DISTINCT behavior) AS behaviors
    
    UNWIND auth_data AS data
    WITH app, app_name, app_criticality, app_status, isLicensed, isBlocked, appRiskLevel, categories, owners, one_month_ago_epoch,
    data.auth AS auth_type,
    data.account AS account,
    data.auth_rel AS auth,
    data.last_accessed AS last_accessed

    WHERE true
        {placeholder}
 
    WITH app, app_name, app_criticality, app_status, isLicensed, isBlocked, appRiskLevel, categories, owners, one_month_ago_epoch,
    auth_type,
    MIN(CASE WHEN account.creationTime <> '-' THEN account.creationTime END) AS firstAccessTime,
    MAX(last_accessed) AS last_accessed,
    COUNT(DISTINCT CASE WHEN auth_type <> 'GUEST_ACCOUNT' THEN account END) AS accounts
    
    // Final aggregation using apoc.agg functions\n
    RETURN DISTINCT
      app.id_ AS id,
      app_name AS app,
      app.description AS description,
      app.logoUrl AS logo,
      COALESCE(CASE WHEN app.isMfaSupported <> '' THEN app.isMfaSupported END, true) AS isMfaSupported,
      [b IN [(app)-[:WHITELISTED_FOR {subscriber: $subscriber, tenant: $tenant}]->(whitelisted) | {id: whitelisted.id, name: whitelisted.name}] WHERE b IS NOT NULL] AS whitelistedBehaviors,
      COALESCE(app.breachDate, '') AS breachDate,
      MIN(firstAccessTime) AS firstAccessTime,
      MAX(last_accessed) AS lastAccessTime,
      appRiskLevel,
      app_status AS status,
      app_criticality AS criticality,
      isLicensed AS isLicensed,
      isBlocked AS isBlocked,
      categories,
      [o IN owners WHERE o IS NOT NULL] AS owner,
      SUM(accounts) AS accounts,
      apoc.map.fromPairs(
          COLLECT(
              [CASE WHEN auth_type <> 'GUEST_ACCOUNT' THEN auth_type END, accounts]
          )
      ) AS authTypesCount,
      COALESCE(MIN(firstAccessTime) > apoc.agg.first(one_month_ago_epoch), true) AS newlyDiscovered"
  type: merge
  allowed_params: true
  allowed_body: true
  multi_value_params:
    - id: behaviour
      delimiter: ","
    - id: authType
      delimiter: ","
    - id: category
      delimiter: ","
    - id: status
      delimiter: ","
  input_params:
    status: AND app_status IN [$status]
    category: AND ANY(cat IN categories WHERE toLower(cat) IN [ x IN [$category] | toLower(x) ])
    behaviour: AND toLower(behavior.name) IN [ x IN [$behaviour] | toLower(x) ]
    createdAfter: AND app.timestamp >= $createdAfter
    authType: AND TYPE(auth) IN [ x IN [$authType] | x ]
    criticality: AND toLower(app_criticality) = toLower($criticality)
    breachedAfter: AND toInteger(COALESCE(app.breachDate, 0)) >= $breachedAfter
    accCreatedAfter: AND toInteger(COALESCE(account.creationTime, 0)) > $accCreatedAfter
    unusedAccount: AND ($unusedAccount IS NULL OR ANY(b IN behaviors WHERE b.id = $unusedAccount))
    isBlocked: AND toLower(isBlocked) = toLower($isBlocked)
  input_body: null
  dataSourceType: knowledgegraph
  sortOrder: desc
  sortColumn: accounts
  limit: 10
  offset: 0
detailed_widget:
  - id: c0cc98da-e08c-43b8-a48c-ddd1091810cd
    name: Findings_drill_down
    position: main
    template: findings_detailed_view
  - id: 02747005-c25f-494a-868f-715da9f0ccef
    name: user_view
    position: offset
    template: users_view
  - id: behaviorAccount
    name: Behavior Account
    template: behaviorAccount
    enabled: true
    dataSourceType: knowledgegraph
    allowed_params: true
    className: col-span-3
    input_params:
      appId: $appId
      behavior: $behavior
    query: "
      MATCH (email:EMAIL {subscriber: $subscriber, tenant: $tenant})-[auth]->(account:ACCOUNT)-[:USING_APP]->(app:APPLICATION {id_: $appId})
      MATCH (account)-[:HAS_FINDING]-(finding:FINDING)-[]-(rule:RULE)-[]-(behavior:BEHAVIOR {id: $behavior})
      RETURN DISTINCT
        account.id AS id,
        COALESCE(CASE WHEN account.email <> '-' THEN account.email ELSE NULL END, email.id) AS email"
    pagination_query: "
      MATCH (u:USER {subscriber: $subscriber, tenant: $tenant})-[:HAS_EMAIL]-(email:EMAIL)-[auth]->(account:ACCOUNT)-[:USING_APP]->(app:APPLICATION {id_: $appId})
      MATCH (account)-[:HAS_FINDING]-(finding:FINDING)-[]-(rule:RULE)-[]-(behavior:BEHAVIOR {id: $behavior})
      RETURN
          COUNT(DISTINCT account.id) AS totalCount"
view_by:
  - id: taggedAccounts
    name: Accounts with finding
    type: widget
    active: true
    requestType: POST
    defaultValue: null
    queryFilters: []
    className: ""
    query: "
      MATCH (app:APPLICATION)
      WHERE app.id_ IN [$appId]
      MATCH (email:EMAIL {subscriber: $subscriber, tenant: $tenant})-[auth]->(account:ACCOUNT)-[:USING_APP]->(app)
      WITH DISTINCT app, account
      MATCH (account)-[:HAS_FINDING]-(finding:FINDING)-[:EVALUATED_TO]-(rule:RULE)-[:BELONGS_TO]-(behavior:BEHAVIOR)
      WITH
        app.id_ AS app_id,
        COALESCE(app.name, app.domain) AS app_name,
        behavior.id AS behavior_id,
        behavior.name AS behavior_name,
        count(DISTINCT account) AS accounts_count
      RETURN app_id, app_name, COLLECT({
        id: behavior_id,
        name: behavior_name,
        count: accounts_count
      }) AS accountsWithFinding"
    allowed_params: true
    input_params:
      appId: $appId
    multi_value_params:
      - id: appId
        delimiter: ","
    dataSourceType: "knowledgegraph"
    pagination_query: "
      MATCH (app:APPLICATION) 
      WHERE app.id_ IN [$appId] 
      MATCH (email:EMAIL {subscriber: $subscriber, tenant: $tenant})-[auth]->(account:ACCOUNT)-[:USING_APP]->(app) 
      WITH DISTINCT app, account 
      MATCH (account)-[:HAS_FINDING]-(finding:FINDING)-[:EVALUATED_TO]-(rule:RULE)-[:BELONGS_TO]-(behavior:BEHAVIOR) 
      WITH app.id_ as app_id, COALESCE(app.name, app.domain) as app_name, behavior.id as behavior_id, behavior.name as behavior_name, count(distinct account) as accounts 
      RETURN COUNT(DISTINCT app_id) AS totalCount"
table_filters:
  - id: owner
    name: Owner
    active: true
    dataSourceType: knowledgegraph
    allowed_params: true
    type: select
    input_params:
      starttime: ""
    query: " 
      MATCH (u:USER)-[:HAS_EMAIL]-(email:EMAIL:PRIMARY)
      MATCH (email)-[AUTH_TYPE]->(account:ACCOUNT)
		  WHERE 
        u.accountEnabled = 'ACTIVE' 
        AND u.subscriber = $subscriber
        AND u.tenant = $tenant
		  WITH   
        COLLECT(distinct{ label: u.displayName, value: u.id, profilePic: u.profilePicUrl, id: 'owner_' + u.id}) AS filters 
      RETURN filters
      "
  - id: status
    name: Status
    defaultValue: All
    active: true
    dataSourceType: knowledgegraph
    allowed_params: true
    type: select
    input_params:
      starttime: ""
    query: " MATCH (u:USER)-[:HAS_EMAIL]-(email:EMAIL)
      MATCH (email)-[]->(account:ACCOUNT)
      OPTIONAL MATCH (account)-[:HAS_FINDING]->(f:FINDING)
      OPTIONAL MATCH (r:RULE)-[:EVALUATED_TO]->(f)
      OPTIONAL MATCH (r)-[:BELONGS_TO]->(b:BEHAVIOR)
      OPTIONAL MATCH (b)-[:BELONGS_TO]->(p:POSTURE)
      MATCH (account)-[:USING_APP]->(app:APPLICATION)
      OPTIONAL MATCH (app)-[:HAS_APP_CATEGORY]->(category:APP_CATEGORY)
      OPTIONAL MATCH (email)-[:CREDSBASED_ACCOUNT]->(credsAcc:ACCOUNT)
      OPTIONAL MATCH (email)-[:SAML_ACCOUNT]->(sso:ACCOUNT)
      OPTIONAL MATCH (email)-[:OAUTH_ACCOUNT]->(oauth:ACCOUNT)
      OPTIONAL MATCH (app)-[:HAS_ADMIN]-(adminAccount:ACCOUNT)
      OPTIONAL MATCH (adminAccount)<-[]-(:EMAIL)<-[:HAS_EMAIL]-(ad:USER)
      OPTIONAL MATCH (idp:INSTANCE)-[:HAS_IDP]->(idpApp:APPLICATION)
      OPTIONAL MATCH (app)<-[hs:HAS_APP_SETTINGS]-(tenant:TENANT)

      WITH
      collect(distinct {id: 'status_' + apoc.util.md5(['All']), label: 'All', value: 'All'}) +
      collect(distinct {id: 'status_' + apoc.util.md5(['Approved']), label: 'Approved', value: 'APPROVED'}) +
      collect(distinct {id: 'status_' + apoc.util.md5(['Unapproved']), label: 'Unapproved', value: 'UNAPPROVED'}) +
      collect(distinct {id: 'status_' + apoc.util.md5(['Tolerated']), label: 'Tolerated', value: 'TOLERATED'}) +
      collect(distinct {id: 'status_' + apoc.util.md5(['Needs Review']), label: 'Needs Review', value: 'NEEDS REVIEW'}) as filters
      RETURN filters"
  - id: category
    name: Category
    active: true
    input_params:
      starttime: ""
    defaultValue: All
    dataSourceType: knowledgegraph
    allowed_params: true
    type: select
    query: "
      MATCH (u:USER)-[:HAS_EMAIL]-(email:EMAIL)
      MATCH (email)-[]->(account:ACCOUNT)
      MATCH (account)-[:USING_APP]->(app:APPLICATION)
      OPTIONAL MATCH (app)-[:HAS_APP_CATEGORY]->(category:APP_CATEGORY)
      WHERE u.subscriber = $subscriber
      AND u.tenant = $tenant
      WITH
      collect(distinct {id: 'category_' + apoc.util.md5(['All']), label: 'All', value: 'All'}) +
      [category in collect(distinct {id: 'category_' + apoc.util.md5([category.name]), label: category.name, value: category.name}) where category.value is not null] as filters
      UNWIND filters AS filter
      WITH filter
      ORDER BY filter.value
      WITH collect(filter) AS sortedFilters
      RETURN sortedFilters AS filters"
  - id: behaviour
    name: Findings
    type: select
    active: true
    dataSourceType: knowledgegraph
    allowed_params: true
    input_params:
      starttime: AND finding.timestamp >= $starttime
      endtime: AND finding.timestamp <= $endtime
    defaultValue: All
    query:
      "
      MATCH (u:USER { subscriber: $subscriber, tenant: $tenant })-[:HAS_EMAIL]->(email:EMAIL)
      OPTIONAL MATCH (email)-[rel]->(acc:ACCOUNT)
      OPTIONAL MATCH (acc)-[:USING_APP]->(app:APPLICATION)
      MATCH (acc)-[:HAS_FINDING]->(f:FINDING)
      OPTIONAL MATCH (acc)-[:HAS_FINDING]->(fh:FINDING_HISTORY)
      WHERE toLower(f.status) IN ['open', 'inprogress'] AND toLower(fh.status) IN ['closed']
      OPTIONAL MATCH (r:RULE)-[:EVALUATED_TO]->(f)
      OPTIONAL MATCH (r)-[:BELONGS_TO]->(b:BEHAVIOR)
      
      WITH COLLECT(DISTINCT b.name) AS behList
      WITH 
          [{id: 'behavior_' + apoc.util.md5(['All']), label: 'All', value: 'All'}] +
          [beh IN behList WHERE beh IS NOT NULL | 
              {id: 'behavior_' + apoc.util.md5([beh]), label: beh, value: beh}
          ] AS filters
      RETURN filters"
  
      # 541217bf-6576-497a-ba24-fdc268cf7fb0
  # - id: cf21f158-0dea-4975-816d-ca3e1a2c5d74
  #   name: Co-Pilot Status
  #   type: Drop Down Menu
  #   active: false
  #   options:
  #     query_id: ""
  #     mergeQueryString: ""
  #     label: ""
  #     value: ""
widgets:
  - id: appsGraph
    name: "Apps"
    label: Widget
    template: this_template
    enabled: true
    type: detailed
    dataSourceType: knowledgegraph
    allowed_params: true
    className: col-span-6
    query_id: ""
    input_params:
      starttime: $starttime
      endtime: $endtime
    queryFilters: []
    query:
      "WITH (timestamp() - 30 * 24 * 60 * 60 * 1000) AS compareTime
       MATCH (email:EMAIL {subscriber: $subscriber, tenant: $tenant})-[auth]-(acc:ACCOUNT)-[ua:USING_APP]-(a:APPLICATION)
       OPTIONAL MATCH (u:USER)-[]-(email)
       WITH u, email, auth, acc, ua, a, compareTime
       WHERE TYPE(auth) IN ['OAUTH_ACCOUNT','CREDSBASED_ACCOUNT','SAML_ACCOUNT', 'GUEST_ACCOUNT']
           AND a.domain IS NOT NULL 
           AND NOT a.domain IN ['','-']
       OPTIONAL MATCH (a)<-[hs:HAS_APP_SETTINGS]-(tenant:TENANT {tenant: $tenant})
       OPTIONAL MATCH (a)-[:HAS_APP_CATEGORY]->(category:APP_CATEGORY)
       WITH u, email, auth, acc, ua, a, hs, compareTime,
       COALESCE(a.name, a.domain) AS app_name
       CALL {
           OPTIONAL MATCH (acc)-[:HAS_FINDING]-(finding:FINDING)-[]-(rule:RULE)-[]-(behavior:BEHAVIOR)
           WHERE behavior.id = 'BID_15'
           RETURN acc.id as unusedAccount
       }
       WITH 
           COLLECT(DISTINCT CASE WHEN toLower(COALESCE(hs.criticality, a.criticality)) = toLower('CRITICAL') THEN a END ) AS criticalApps,
           COLLECT(DISTINCT u) AS allUserIds,
           COLLECT(DISTINCT a) AS allApps,
           COLLECT(DISTINCT CASE WHEN ua is not null AND type(auth) <> 'GUEST_ACCOUNT' then acc end) AS allAccounts,
           COLLECT(DISTINCT CASE WHEN ua is not null AND type(auth) <> 'GUEST_ACCOUNT' then auth end) AS allLoginAccounts,
           COLLECT(DISTINCT CASE WHEN unusedAccount IS NOT NULL THEN unusedAccount END) AS unusedAccounts,
           compareTime
       WITH 
           allUserIds,
           allApps,
           allAccounts,
           allLoginAccounts,
           unusedAccounts,
           compareTime,
           criticalApps,
           [app IN allApps WHERE app.timestamp >= compareTime] AS newApps,
           [ath IN allLoginAccounts WHERE ath.creationTime >= compareTime] AS newAccounts,
           [usr IN allUserIds WHERE toLower(usr.accountEnabled) = 'active'] AS activeUsers,
           [app IN allApps WHERE COALESCE(app.breachDate, 0) >= compareTime] AS recentlyBreachedApps
       RETURN 
           SIZE(allApps) AS total_app_count,
           SIZE(newApps) AS new_apps_count,
           SIZE(criticalApps) AS critical_apps_count,
           SIZE(recentlyBreachedApps) AS recentlyBreachedApps,
           CASE 
               WHEN SIZE(allApps) > 0 
               THEN round(toFloat((toFloat(SIZE(newApps)) / SIZE(allApps)) * 100) * 100) / 100
               ELSE 0
           END AS percentage_new_apps,
           CASE 
               WHEN SIZE(criticalApps) > 0 
               THEN round(toFloat((toFloat(SIZE(criticalApps)) / toInteger(SIZE(allApps))) * 100) * 100) / 100
               ELSE 0
           END AS percentage_critical_apps,
           CASE 
               WHEN SIZE(recentlyBreachedApps) > 0 
               THEN round(toFloat((toFloat(SIZE(recentlyBreachedApps)) / toInteger(SIZE(allApps))) * 100) * 100) / 100
               ELSE 0
           END AS percentage_breached_apps"
  - id: status
    name: Distribution by status
    label: Widget
    template: status
    enabled: true
    dataSourceType: knowledgegraph
    allowed_params: false
    type: variable_pie_chart
    className: col-span-3
    query_id: ""
    input_params: null
    queryFilters: []
    query: "
      MATCH (u:USER{subscriber: $subscriber , tenant: $tenant})-[]-(email:EMAIL)-[auth]-(account:ACCOUNT)-[ua:USING_APP]-(app:APPLICATION)
      WHERE 
        COALESCE(app.name, app.domain) IS NOT NULL
      OPTIONAL MATCH (app)<-[hs:HAS_APP_SETTINGS]-(tenant:TENANT{tenant: $tenant})
      WITH u, email, account, app, hs, tenant
      WITH 
      COUNT(DISTINCT CASE WHEN toLower(COALESCE(hs.approval_status, app.approval_status, 'NEEDS REVIEW')) = 'needs review' THEN app END) AS needsReviewCount,
      COUNT(DISTINCT CASE WHEN toLower(COALESCE(hs.approval_status, app.approval_status, 'NEEDS REVIEW')) = 'approved' THEN app END) AS approvedCount,
      COUNT(DISTINCT CASE WHEN toLower(COALESCE(hs.approval_status, app.approval_status, 'NEEDS REVIEW')) = 'unapproved' THEN app END) AS unapprovedCount,
      COUNT(DISTINCT CASE WHEN toLower(COALESCE(hs.approval_status, app.approval_status, 'NEEDS REVIEW')) = 'tolerated' THEN app END) AS toleratedCount
      RETURN [
      { value: needsReviewCount, name: 'Needs Review' },
      { value: approvedCount, name: 'Approved' },
      { value: unapprovedCount, name: 'Unapproved' },
      { value: toleratedCount, name: 'Tolerated' }
      ] AS results"
  - id: loginMethods
    name: Login Methods
    label: Widget
    template: loginMethod
    enabled: true
    dataSourceType: knowledgegraph
    allowed_params: false
    type: bar_chart_with_icon
    className: col-span-3
    query_id:
    input_params: null
    queryFilters: []
    query: "WITH [
      {id: 'OAUTH_ACCOUNT', label: 'OAuth', userCount: 0},
      {id: 'CREDSBASED_ACCOUNT', label: 'Creds', userCount: 0},
      {id: 'SAML_ACCOUNT', label: 'SSO', userCount: 0}
      ] AS login_types
      UNWIND login_types AS login_type
      MATCH (user:USER{subscriber: $subscriber, tenant: $tenant})-[:HAS_EMAIL]-(email:EMAIL)-[accountEmailRelation]-(account:ACCOUNT)-[:USING_APP]-(application:APPLICATION)
      WHERE application.domain IS NOT NULL 
      AND NOT application.domain IN ['','-']
      AND toLower(user.accountEnabled) = 'active'
      AND login_type.id = TYPE(accountEmailRelation)
      OPTIONAL MATCH (user)-[]-(i:INSTANCE)-[]-(idpApp:APPLICATION)
      WITH login_type, COUNT(DISTINCT accountEmailRelation) AS accounts_count, COLLECT(DISTINCT idpApp)[0] AS idpAppl
      RETURN 
      COLLECT({loginMethod:login_type.id, logo: CASE WHEN login_type.id = 'CREDSBASED_ACCOUNT' THEN null ELSE idpAppl.logoUrl END, provider: idpAppl.name, count: accounts_count}) AS results"
  - id: accountsGraph
    name: Accounts
    label: Widget
    template: this_template
    enabled: true
    dataSourceType: knowledgegraph
    allowed_params: false
    type: detailed
    className: col-span-3
    query_id:
    input_params: null
    queryFilters: []
    query: "
      MATCH (u:USER {subscriber: $subscriber, tenant: $tenant})-[:HAS_EMAIL]-(email:EMAIL)
      MATCH (email)-[AUTH_TYPE]->(account:ACCOUNT)
      MATCH (account)-[:USING_APP]->(app:APPLICATION)

      WITH TYPE(AUTH_TYPE) AS authType, app
      WITH COLLECT(authType) AS authTypes

      WITH 
          SIZE([type IN authTypes WHERE type = 'SAML_ACCOUNT']) AS ssoCount,
          SIZE([type IN authTypes WHERE type = 'OAUTH_ACCOUNT']) AS oAuthCount,
          SIZE([type IN authTypes WHERE type = 'CREDSBASED_ACCOUNT']) AS credsCount

      WITH 
          COALESCE(ssoCount, 0) AS ssoCount,
          COALESCE(oAuthCount, 0) AS oAuthCount,
          COALESCE(credsCount, 0) AS credsCount

      RETURN [
          { value: ssoCount, name: 'SSO' },
          { value: oAuthCount, name: 'OAuth' },
          { value: credsCount, name: 'Creds' }
      ] AS results"
table_render:
  table_additional_data:
    no_hover: true
    row_border: true
    min_row_height: "h-[80px]" 
    alternate_row_colors: true
    no_table_padding: true
    table_heading_bg: "bg-dark-300"
    no_calendar: true
    no_drilldown: true
  widgets:
    status:
      id: status
      map:
        Approved:
          color: "#8AC926"
        Tolerated:
          color: "#1982C4"
        Unapproved:
          color: "#FF595E"
        "Needs Review":
          color: "#FFCA3A"
    loginMethods:
      map:
        SSO:
          color: "#6A4C93"
          logo: https://staticcontent1.blob.core.windows.net/static-images-company-logos/okta.png
        OAuth:
          color: "#6A4C93"
          logo: https://staticcontent1.blob.core.windows.net/static-images-company-logos/microsoft.png
        Creds:
          color: "#6A4C93"
          imageClasses: invert
          logo: https://staticcontent1.blob.core.windows.net/finding-icons/credential-icon-white.svg
  table:
    app:
      id: app
      type: multi_icon
      label: App
      sortable: false
      valuePath: app
      groupByKey: app
      order: 1
    # owner:
    #   id: owner
    #   type: select
    #   label: Owner
    #   valuePath: owner
    #   sortable: false
    #   groupByKey: owner
    #   order: 2
    #   onChange:
    #     apiCall: /browser-extension/browser/activity/modify/appSettings
    #     method: POST
    #     args:
    #       query:
    #         - name: app_id
    #           position: query
    #           value: "$id"
    #       body:
    #         - name: owner
    #           position: body
    #           value: "{val}"
    category:
      id: category
      type: categoryCell
      extraClasses: text-center
      label: Category
      # bgColor: "#"
      valuePath: Category
      width: w-[8%]
      sortable: false
      groupByKey: Category
      order: 3
    criticality:
      id: criticality
      type: select
      label: Criticality
      valuePath: criticality
      sortable: false
      groupByKey: criticality
      order: 4
      onChange:
        apiCall: /browser-extension/browser/activity/modify/appSettings
        method: POST
        args:
          query:
            - name: app_id
              position: query
              value: "$id"
          body:
            - name: criticality
              position: body
              value: "{val}"
      options:
        - id: criticality-not-available
          label: Not Set
          value: "NOT SET"
        - id: criticality-select-yes
          label: "Critical"
          value: "CRITICAL"
        - id: criticality-select-no
          label: "Not Critical"
          value: "NOT CRITICAL"
    status:
      id: status
      type: coloredDropDown
      label: Status
      valuePath: Status
      sortable: false
      groupByKey: Status
      onChange:
        apiCall: /browser-extension/browser/activity/modify/appSettings
        method: POST
        args:
          query:
            - name: app_id
              position: query
              value: "$id"
          body:
            - name: approval_status
              position: body
              value: "{val}"
      order: 5
      options:
        - id: status-not-available
          label: Needs Review
          value: "NEEDS REVIEW"
        - id: status-select-approved
          label: Approved
          value: APPROVED
          color: "#75FC72BE"
        - id: status-select-tolerated
          label: Tolerated
          value: TOLERATED
        - id: status-select-not-approved
          label: Unapproved
          value: UNAPPROVED
          color: "#FC7272BE"
    isLicensed:
      id: isLicensed
      type: select
      label: isLicensed
      valuePath: isLicensed
      sortable: false
      groupByKey: isLicensed
      onChange:
        apiCall: /browser-extension/browser/activity/modify/appSettings
        method: POST
        args:
          query:
            - name: app_id
              position: query
              value: "$id"
          body:
            - name: isLicensed
              position: body
              value: "{val}"
      order: 3
      options:
        - id: yes
          label: Yes
          value: "Yes"
        - id: no
          label: No
          value: "No"
    accounts:
      id: accounts
      type: text
      extraClasses: text-center
      label: Accounts
      sortable: false
      width: w-[8%]
      valuePath: Accounts
      groupByKey: Accounts
      order: 6
    login_methods:
      id: login_method
      type: loginMethod
      label: Login Method
      valuePath: App
      sortable: false
      groupByKey: App
      order: 7
      map:
        SSO:
          logo: https://staticcontent1.blob.core.windows.net/static-images-company-logos/okta.png
          color: "#383838"
        OAuth:
          logo: https://staticcontent1.blob.core.windows.net/static-images-company-logos/microsoft.png
          color: "#383838"
        "User & Pass":
          logo: https://staticcontent1.blob.core.windows.net/finding-icons/credential-icon-white.svg
          color: "#D5C0C0"
    # owners:
    #   id: admin
    #   type: userIcon
    #   width: w-[10%]
    #   label: Owners
    #   valuePath: Owners
    #   sortable: false
    #   order: 7
    last_breached:
      id: last_breached
      width: w-[10%]
      type: USFormattedDate
      emptyValue: Never
      extraClasses: text-center
      label: Last Accessed
      valuePath: last_breached
      sortable: false
      order: 8
    findings:
      id: findings
      type: findingsCell
      label: Findings
      valuePath: findings
      sortable: false
      order: 9
      map:
        "Password Hygiene":
          logo: https://staticcontent1.blob.core.windows.net/finding-icons/posture-password-hygiene.svg
          color: "#2B2B2B"
        "SaaS Usage":
          logo: https://staticcontent1.blob.core.windows.net/finding-icons/posture-saas-usage.svg
          color: "#2B2B2B"
        "MFA usage":
          logo: https://staticcontent1.blob.core.windows.net/finding-icons/posture-mfa-usage.svg
          color: "#2B2B2B"
        "Human Risks":
          logo: https://staticcontent1.blob.core.windows.net/finding-icons/posture-human-risk.svg
          color: "#2B2B2B"
        "Data Handling":
          logo: https://staticcontent1.blob.core.windows.net/finding-icons/posture-data-handling.svg
          color: "#2B2B2B"
        "AI Usage":
          logo: https://staticcontent1.blob.core.windows.net/finding-icons/posture-ai-usage.svg
          color: "#2B2B2B"
        "Social Engineering":
          logo: https://staticcontent1.blob.core.windows.net/finding-icons/posture-social-engineering.svg
          color: "#2B2B2B"
        "Web Browsing":
          logo: https://staticcontent1.blob.core.windows.net/finding-icons/posture-web-browsing.svg
          color: "#2B2B2B"
        "Workstation Risks":
          logo: https://staticcontent1.blob.core.windows.net/finding-icons/posture-workstation-risks.svg
          color: "#2B2B2B"
pagination_query:
  query: "MATCH (email:EMAIL {subscriber: $subscriber, tenant: $tenant})-[auth]-(account:ACCOUNT)-[:USING_APP]-(app:APPLICATION)
    USING INDEX email:EMAIL(subscriber, tenant)
    
    // Early aggregation to reduce data volume\n
    WITH app,
        COLLECT(DISTINCT {auth: type(auth), account: account, last_accessed: auth.last_access_time, auth_rel: auth}) AS auth_data
    WHERE app.domain IS NOT NULL AND NOT app.domain IN ['','-']
    
    // Optimized critical property access first\n
    WITH app, 
         COALESCE(CASE WHEN NOT app.name IN ['', '-'] THEN app.name END, app.domain) AS app_name,
         auth_data
    
    WHERE app_name IS NOT NULL
        AND CASE '{searchText}'
          WHEN <> '' THEN toLower(btrim(app_name)) contains toLower('{searchText}')
          ELSE true
        END
    
    OPTIONAL MATCH (app)-[:HAS_APP_CATEGORY]->(category:APP_CATEGORY)
    OPTIONAL MATCH (app)<-[hs:HAS_APP_SETTINGS]-(tenant:TENANT{tenant: $tenant})
    OPTIONAL MATCH (app)-[:WHITELISTED_FOR {subscriber: $subscriber, tenant: $tenant}]->(behavior:BEHAVIOR)
    
    WITH app, app_name, hs, 
    COLLECT(DISTINCT category.name) AS categories,
    COLLECT(DISTINCT behavior) AS behaviors,
    auth_data
    
    UNWIND auth_data AS data
    WITH app, app_name,
        COALESCE(hs.criticality, app.criticality, 'NOT SET') AS app_criticality, 
        COALESCE(
            CASE WHEN hs.approval_status <> '-' THEN hs.approval_status ELSE NULL END, 
            CASE WHEN app.approval_status <> '-' THEN app.approval_status ELSE NULL END, 
            'NEEDS REVIEW'
        ) AS app_status,
        COALESCE(
            CASE WHEN hs.isBlocked <> '-' THEN hs.isBlocked ELSE NULL END, 'No'
        ) AS isBlocked,
        CASE app.totalScore
            WHEN <= 2 THEN 'Very High'
            WHEN <= 4 THEN 'High'
            WHEN <= 6 THEN 'Moderate'
            WHEN <= 8 THEN 'Low'
            WHEN <= 10 THEN 'Very Low'
            ELSE 'Unknown' 
        END AS appRiskLevel,
        data.auth AS auth_type,
        data.account AS account,
        data.auth_rel AS auth,
        MAX(data.last_accessed) AS lastAccessTime,
        categories,
        behaviors
        
    WHERE true
        {placeholder}
        
    RETURN COUNT(DISTINCT app.id_) AS totalCount"
  dataSourceType: knowledgegraph
table_widget:
  - id: 324b1443-e4ed-4a16-87ef-94afd92c05a8
    name: Finding Status
    label: Widget
    template: status
    enabled: true
    type: polar_graph
    className: col-span-3
    allowed_params: true
    dataSourceType: knowledgegraph
    input_params:
      starttime: AND f.timestamp >= {starttime} AND fh.timestamp >= {starttime}
      endtime: AND f.timestamp <= {endtime} AND fh.timestamp <= {endtime}
    queryFilters:
      - id: c58d1d61-6422-449f-96fd-b2b740bcd6f3
        name: Time Filter
        type: multiselect
        options: null
    query: "MATCH (u:USER)-[hv:HAS_VIOLATION]->(f:FINDING)
      OPTIONAL MATCH (u)-[hv1:HAS_VIOLATION]->(fh:FINDING_HISTORY)
      WHERE
      u.subscriber = $subscriber
      AND u.tenant = $tenant
      {placeholder}
      WITH
      COUNT(DISTINCT CASE WHEN f.status = 'open' THEN f END) AS openCount,
      COUNT(DISTINCT CASE WHEN fh.status = 'closed' THEN fh END) AS closedCount,
      COUNT(DISTINCT CASE WHEN f.status = 'inprogress' THEN f END) AS inprogressCount

      RETURN [
      { value: closedCount, name: 'Closed' },
      { value: inprogressCount, name: 'In Progress' },
      { value: openCount, name: 'Open' }
      ] AS results"