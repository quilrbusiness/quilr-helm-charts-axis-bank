id: saas-risk
name: SaaS Risks
type: screen
enabled: true
version: 1.0.29
icon_url: https://staticcontent1.blob.core.windows.net/finding-icons/posture-ai-usage.svg
table_query:
  id: 82f39be8-e238-4a2e-bee3-5ecb6bd420a3
  name: Display Table Data
  queryString: null
  type: merge
  allowed_params: true
  allowed_body: true
  input_params:
    sample: value
  input_body: null
  dataSourceType: knowledgegraph
  sortOrder: desc
  sortColumn: lastseen
  limit: 10
  offset: 0
detailed_widget:
  - id: BID_12_detailed
    name: "High Risk Oauth Scope Drilldown Table"
    input_params:
      appId: $appId
      behavior: $behavior
    dataSourceType: "knowledgegraph"
    enabled: true
    allowed_params: true
    sortOrder: ""
    sortColumn: ""
    position: null
    template: null
    className: null
    multi_value_params:
      - id: appId
        delimiter: ","
    query: "MATCH (app:APPLICATION)
            WHERE app.id_ IN [$appId]
            MATCH (app)<-[using_app:USING_APP]-(account:ACCOUNT {subscriber: $subscriber, tenant: $tenant})
            MATCH (account)-[:HAS_FINDING]->(finding:FINDING)<-[:EVALUATED_TO]-(rule:RULE)-[:BELONGS_TO]->(behavior:BEHAVIOR {id: $behavior})
            MATCH (account)<-[auth_type]-(email:EMAIL)<-[:HAS_EMAIL]-(user:USER)
            
            OPTIONAL MATCH (app)-[has:HAS_APP_SETTINGS]-(tenant:TENANT {id: $tenant})
            OPTIONAL MATCH (app)-[:HAS_GRANT]-(grant:GRANT)-[:HAS_SCOPE]-(scope:SCOPE)
            OPTIONAL MATCH (user)-[:HAS_DEPARTMENT]->(department:DEPARTMENT)
            OPTIONAL MATCH (app)-[:HAS_APP_CATEGORY]->(app_category:APP_CATEGORY)
            
            OPTIONAL MATCH (finding)-[:TRIGGERED]->(action:ACTION)
            OPTIONAL MATCH (action)-[:RESULTED_IN]-(outcome:OUTCOME)
            OPTIONAL MATCH (action)-[:HAS_INTERACTION]->(interaction:INTERACTION)
            
            UNWIND ['High', 'Medium', 'Low'] AS severity
            
            WITH app, has, department, app_category, account, auth_type, replace(type(auth_type), '_ACCOUNT', '') AS loginMethod, email, user, finding, action, interaction, outcome,
                datetime.truncate('day', datetime() - duration('P1M')).epochMillis AS one_month_ago_epoch,
                severity, COUNT(DISTINCT CASE WHEN scope.severity = severity THEN scope END) as scopeCount
            
            WITH app, has, department, app_category, account, auth_type, loginMethod, email, user, finding, one_month_ago_epoch,
                apoc.map.fromPairs(COLLECT(DISTINCT
                    [action.name, CASE WHEN outcome IS NOT NULL THEN outcome.description ELSE action.description END]
                )) AS actionCurrentState,
                COLLECT(
                    CASE WHEN interaction IS NOT NULL THEN 
                        {message: interaction.message,
                        name: interaction.name,
                        messageTime: interaction.messageTime,
                        initiator: interaction.initiator,
                        channel: interaction.channel,
                        mode: interaction.mode
                        }
                    END
                ) AS interactionsList,
                apoc.map.fromPairs(COLLECT([severity, scopeCount])) AS oauthScopes
            
            UNWIND
                CASE WHEN SIZE(interactionsList) > 0 THEN interactionsList
                ELSE [NULL]
            END AS interactionData
                        
            WITH app, has, department, app_category, account, auth_type, loginMethod, email, user, finding,
                actionCurrentState, interactionData, one_month_ago_epoch, oauthScopes
            ORDER BY interactionData.messageTime
            
            WITH app, has, department, app_category, account, auth_type, loginMethod, email, user, finding,
                actionCurrentState, one_month_ago_epoch, oauthScopes, COLLECT(interactionData) AS sortedInteractions
            
            RETURN DISTINCT
                email.id AS userMail,
                user.displayName AS userName,
                COALESCE(app.name, app.domain, app.id) AS appName,
                user.profilePicUrl AS userProfilePicUrl,
                COLLECT(DISTINCT department.name) AS departments,
                app.logoUrl AS appLogoUrl,
                COLLECT(DISTINCT app_category.name) AS appCategories,
                has.approval_status AS appStatus,
                actionCurrentState,
                sortedInteractions,
                auth_type.creationTime < one_month_ago_epoch AS newlyDiscovered,
                app.breachDate * 1000 AS breachDate,
                oauthScopes,
                {
                    credsbased: COUNT(DISTINCT CASE WHEN loginMethod = 'CREDSBASED' THEN account END),
                    oauth: COUNT(DISTINCT CASE WHEN loginMethod = 'OAUTH' THEN account END),
                    saml: COUNT(DISTINCT CASE WHEN loginMethod = 'SAML' THEN account END)
                } AS loginMethodCount"
    pagination_query: "MATCH (app:APPLICATION)
                      WHERE app.id_ IN [$appId]
                      MATCH (app)<-[using_app:USING_APP]-(account:ACCOUNT {subscriber: $subscriber, tenant: $tenant})
                      MATCH (account)-[:HAS_FINDING]->(finding:FINDING)<-[:EVALUATED_TO]-(rule:RULE)-[:BELONGS_TO]->(behavior:BEHAVIOR {id: $behavior})
                      MATCH (account)<-[auth_type]-(email:EMAIL)<-[:HAS_EMAIL]-(user:USER)
                      
                      OPTIONAL MATCH (app)-[has:HAS_APP_SETTINGS]-(tenant:TENANT {id: $tenant})
                      OPTIONAL MATCH (app)-[:HAS_GRANT]-(grant:GRANT)-[:HAS_SCOPE]-(scope:SCOPE)
                      OPTIONAL MATCH (user)-[:HAS_DEPARTMENT]->(department:DEPARTMENT)
                      OPTIONAL MATCH (app)-[:HAS_APP_CATEGORY]->(app_category:APP_CATEGORY)
                      
                      OPTIONAL MATCH (finding)-[:TRIGGERED]->(action:ACTION)
                      OPTIONAL MATCH (action)-[:RESULTED_IN]-(outcome:OUTCOME)
                      OPTIONAL MATCH (action)-[:HAS_INTERACTION]->(interaction:INTERACTION)
                      
                      UNWIND ['High', 'Medium', 'Low'] AS severity
                      
                      WITH app, has, department, app_category, account, auth_type, replace(type(auth_type), '_ACCOUNT', '') AS loginMethod, email, user, finding, action, interaction, outcome,
                          datetime.truncate('day', datetime() - duration('P1M')).epochMillis AS one_month_ago_epoch,
                          severity, COUNT(DISTINCT CASE WHEN scope.severity = severity THEN scope END) as scopeCount
                      
                      WITH app, has, department, app_category, account, auth_type, loginMethod, email, user, finding, one_month_ago_epoch,
                          apoc.map.fromPairs(COLLECT(DISTINCT
                              [action.name, CASE WHEN outcome IS NOT NULL THEN outcome.description ELSE action.description END]
                          )) AS actionCurrentState,
                          COLLECT(
                              CASE WHEN interaction IS NOT NULL THEN 
                                  {message: interaction.message,
                                  name: interaction.name,
                                  messageTime: interaction.messageTime,
                                  initiator: interaction.initiator,
                                  channel: interaction.channel,
                                  mode: interaction.mode
                                  }
                              END
                          ) AS interactionsList,
                          apoc.map.fromPairs(COLLECT([severity, scopeCount])) AS oauthScopes
                      
                      UNWIND
                          CASE WHEN SIZE(interactionsList) > 0 THEN interactionsList
                          ELSE [NULL]
                      END AS interactionData
                                  
                      WITH app, has, department, app_category, account, auth_type, loginMethod, email, user, finding,
                          actionCurrentState, interactionData, one_month_ago_epoch, oauthScopes
                      ORDER BY interactionData.messageTime
                      
                      WITH app, has, department, app_category, account, auth_type, loginMethod, email, user, finding,
                          actionCurrentState, one_month_ago_epoch, oauthScopes, COLLECT(interactionData) AS sortedInteractions
                      
                      RETURN DISTINCT
                          COUNT(DISTINCT account.id) AS totalCount"
  - id: BID_13_detailed
    name: "Terminated User with enabled account Drilldown Table"
    input_params:
      appId: $appId
      behavior: $behavior
    dataSourceType: "knowledgegraph"
    enabled: true
    allowed_params: true
    sortOrder: ""
    sortColumn: ""
    position: null
    template: null
    className: null
    multi_value_params:
      - id: appId
        delimiter: ","
    query: "MATCH (app:APPLICATION)
            WHERE app.id_ IN [$appId]
            MATCH (app)<-[using_app:USING_APP]-(account:ACCOUNT {subscriber: $subscriber, tenant: $tenant})
            MATCH (account)-[:HAS_FINDING]->(finding:FINDING)<-[:EVALUATED_TO]-(rule:RULE)-[:BELONGS_TO]->(behavior:BEHAVIOR {id: $behavior})
            MATCH (account)<-[auth_type]-(email:EMAIL)<-[:HAS_EMAIL]-(user:USER)
            
            OPTIONAL MATCH (app)-[has:HAS_APP_SETTINGS]-(tenant:TENANT {id: $tenant})
            OPTIONAL MATCH (app)-[:HAS_GRANT]-(grant:GRANT)-[:HAS_SCOPE]-(scope:SCOPE)
            OPTIONAL MATCH (user)-[:HAS_DEPARTMENT]->(department:DEPARTMENT)
            OPTIONAL MATCH (app)-[:HAS_APP_CATEGORY]->(app_category:APP_CATEGORY)
            
            OPTIONAL MATCH (finding)-[:TRIGGERED]->(action:ACTION)
            OPTIONAL MATCH (action)-[:RESULTED_IN]-(outcome:OUTCOME)
            OPTIONAL MATCH (action)-[:HAS_INTERACTION]->(interaction:INTERACTION)
            
            UNWIND ['High', 'Medium', 'Low'] AS severity
            
            WITH app, has, department, app_category, account, auth_type, replace(type(auth_type), '_ACCOUNT', '') AS loginMethod, email, user, finding, action, interaction, outcome,
                datetime.truncate('day', datetime() - duration('P1M')).epochMillis AS one_month_ago_epoch,
                severity, COUNT(DISTINCT CASE WHEN scope.severity = severity THEN scope END) as scopeCount
            
            WITH app, has, department, app_category, account, auth_type, loginMethod, email, user, finding, one_month_ago_epoch,
                apoc.map.fromPairs(COLLECT(DISTINCT
                    [action.name, CASE WHEN outcome IS NOT NULL THEN outcome.description ELSE action.description END]
                )) AS actionCurrentState,
                COLLECT(
                    CASE WHEN interaction IS NOT NULL THEN 
                        {message: interaction.message,
                        name: interaction.name,
                        messageTime: interaction.messageTime,
                        initiator: interaction.initiator,
                        channel: interaction.channel,
                        mode: interaction.mode
                        }
                    END
                ) AS interactionsList,
                apoc.map.fromPairs(COLLECT([severity, scopeCount])) AS oauthScopes
            
            UNWIND
                CASE WHEN SIZE(interactionsList) > 0 THEN interactionsList
                ELSE [NULL]
            END AS interactionData
                        
            WITH app, has, department, app_category, account, auth_type, loginMethod, email, user, finding,
                actionCurrentState, interactionData, one_month_ago_epoch, oauthScopes
            ORDER BY interactionData.messageTime
            
            WITH app, has, department, app_category, account, auth_type, loginMethod, email, user, finding,
                actionCurrentState, one_month_ago_epoch, oauthScopes, COLLECT(interactionData) AS sortedInteractions
            
            RETURN DISTINCT
                email.id AS userMail,
                user.displayName AS userName,
                COALESCE(app.name, app.domain, app.id) AS appName,
                user.profilePicUrl AS userProfilePicUrl,
                COLLECT(DISTINCT department.name) AS departments,
                app.logoUrl AS appLogoUrl,
                COLLECT(DISTINCT app_category.name) AS appCategories,
                has.approval_status AS appStatus,
                actionCurrentState,
                sortedInteractions,
                auth_type.creationTime < one_month_ago_epoch AS newlyDiscovered,
                app.breachDate * 1000 AS breachDate,
                oauthScopes,
                {
                    credsbased: COUNT(DISTINCT CASE WHEN loginMethod = 'CREDSBASED' THEN account END),
                    oauth: COUNT(DISTINCT CASE WHEN loginMethod = 'OAUTH' THEN account END),
                    saml: COUNT(DISTINCT CASE WHEN loginMethod = 'SAML' THEN account END)
                } AS loginMethodCount"
    pagination_query: "MATCH (app:APPLICATION)
                      WHERE app.id_ IN [$appId]
                      MATCH (app)<-[using_app:USING_APP]-(account:ACCOUNT {subscriber: $subscriber, tenant: $tenant})
                      MATCH (account)-[:HAS_FINDING]->(finding:FINDING)<-[:EVALUATED_TO]-(rule:RULE)-[:BELONGS_TO]->(behavior:BEHAVIOR {id: $behavior})
                      MATCH (account)<-[auth_type]-(email:EMAIL)<-[:HAS_EMAIL]-(user:USER)
                      
                      OPTIONAL MATCH (app)-[has:HAS_APP_SETTINGS]-(tenant:TENANT {id: $tenant})
                      OPTIONAL MATCH (app)-[:HAS_GRANT]-(grant:GRANT)-[:HAS_SCOPE]-(scope:SCOPE)
                      OPTIONAL MATCH (user)-[:HAS_DEPARTMENT]->(department:DEPARTMENT)
                      OPTIONAL MATCH (app)-[:HAS_APP_CATEGORY]->(app_category:APP_CATEGORY)
                      
                      OPTIONAL MATCH (finding)-[:TRIGGERED]->(action:ACTION)
                      OPTIONAL MATCH (action)-[:RESULTED_IN]-(outcome:OUTCOME)
                      OPTIONAL MATCH (action)-[:HAS_INTERACTION]->(interaction:INTERACTION)
                      
                      UNWIND ['High', 'Medium', 'Low'] AS severity
                      
                      WITH app, has, department, app_category, account, auth_type, replace(type(auth_type), '_ACCOUNT', '') AS loginMethod, email, user, finding, action, interaction, outcome,
                          datetime.truncate('day', datetime() - duration('P1M')).epochMillis AS one_month_ago_epoch,
                          severity, COUNT(DISTINCT CASE WHEN scope.severity = severity THEN scope END) as scopeCount
                      
                      WITH app, has, department, app_category, account, auth_type, loginMethod, email, user, finding, one_month_ago_epoch,
                          apoc.map.fromPairs(COLLECT(DISTINCT
                              [action.name, CASE WHEN outcome IS NOT NULL THEN outcome.description ELSE action.description END]
                          )) AS actionCurrentState,
                          COLLECT(
                              CASE WHEN interaction IS NOT NULL THEN 
                                  {message: interaction.message,
                                  name: interaction.name,
                                  messageTime: interaction.messageTime,
                                  initiator: interaction.initiator,
                                  channel: interaction.channel,
                                  mode: interaction.mode
                                  }
                              END
                          ) AS interactionsList,
                          apoc.map.fromPairs(COLLECT([severity, scopeCount])) AS oauthScopes
                      
                      UNWIND
                          CASE WHEN SIZE(interactionsList) > 0 THEN interactionsList
                          ELSE [NULL]
                      END AS interactionData
                                  
                      WITH app, has, department, app_category, account, auth_type, loginMethod, email, user, finding,
                          actionCurrentState, interactionData, one_month_ago_epoch, oauthScopes
                      ORDER BY interactionData.messageTime
                      
                      WITH app, has, department, app_category, account, auth_type, loginMethod, email, user, finding,
                          actionCurrentState, one_month_ago_epoch, oauthScopes, COLLECT(interactionData) AS sortedInteractions
                      
                      RETURN DISTINCT
                          COUNT(DISTINCT account.id) AS totalCount"
  - id: BID_14_detailed
    name: "Unapproved SaaS app Drilldown Table"
    input_params:
      appId: $appId
      behavior: $behavior
    dataSourceType: "knowledgegraph"
    enabled: true
    allowed_params: true
    sortOrder: ""
    sortColumn: ""
    position: null
    template: null
    className: null
    multi_value_params:
      - id: appId
        delimiter: ","
    query: "MATCH (app:APPLICATION)
            WHERE app.id_ IN [$appId]
            MATCH (app)<-[using_app:USING_APP]-(account:ACCOUNT {subscriber: $subscriber, tenant: $tenant})
            MATCH (account)-[:HAS_FINDING]->(finding:FINDING)<-[:EVALUATED_TO]-(rule:RULE)-[:BELONGS_TO]->(behavior:BEHAVIOR {id: $behavior})
            MATCH (account)<-[auth_type]-(email:EMAIL)<-[:HAS_EMAIL]-(user:USER)
            
            OPTIONAL MATCH (app)-[has:HAS_APP_SETTINGS]-(tenant:TENANT {id: $tenant})
            OPTIONAL MATCH (app)-[:HAS_GRANT]-(grant:GRANT)-[:HAS_SCOPE]-(scope:SCOPE)
            OPTIONAL MATCH (user)-[:HAS_DEPARTMENT]->(department:DEPARTMENT)
            OPTIONAL MATCH (app)-[:HAS_APP_CATEGORY]->(app_category:APP_CATEGORY)
            
            OPTIONAL MATCH (finding)-[:TRIGGERED]->(action:ACTION)
            OPTIONAL MATCH (action)-[:RESULTED_IN]-(outcome:OUTCOME)
            OPTIONAL MATCH (action)-[:HAS_INTERACTION]->(interaction:INTERACTION)
            
            UNWIND ['High', 'Medium', 'Low'] AS severity
            
            WITH app, has, department, app_category, account, auth_type, replace(type(auth_type), '_ACCOUNT', '') AS loginMethod, email, user, finding, action, interaction, outcome,
                datetime.truncate('day', datetime() - duration('P1M')).epochMillis AS one_month_ago_epoch,
                severity, COUNT(DISTINCT CASE WHEN scope.severity = severity THEN scope END) as scopeCount
            
            WITH app, has, department, app_category, account, auth_type, loginMethod, email, user, finding, one_month_ago_epoch,
                apoc.map.fromPairs(COLLECT(DISTINCT
                    [action.name, CASE WHEN outcome IS NOT NULL THEN outcome.description ELSE action.description END]
                )) AS actionCurrentState,
                COLLECT(
                    CASE WHEN interaction IS NOT NULL THEN 
                        {message: interaction.message,
                        name: interaction.name,
                        messageTime: interaction.messageTime,
                        initiator: interaction.initiator,
                        channel: interaction.channel,
                        mode: interaction.mode
                        }
                    END
                ) AS interactionsList,
                apoc.map.fromPairs(COLLECT([severity, scopeCount])) AS oauthScopes
            
            UNWIND
                CASE WHEN SIZE(interactionsList) > 0 THEN interactionsList
                ELSE [NULL]
            END AS interactionData
                        
            WITH app, has, department, app_category, account, auth_type, loginMethod, email, user, finding,
                actionCurrentState, interactionData, one_month_ago_epoch, oauthScopes
            ORDER BY interactionData.messageTime
            
            WITH app, has, department, app_category, account, auth_type, loginMethod, email, user, finding,
                actionCurrentState, one_month_ago_epoch, oauthScopes, COLLECT(interactionData) AS sortedInteractions
            
            RETURN DISTINCT
                email.id AS userMail,
                user.displayName AS userName,
                COALESCE(app.name, app.domain, app.id) AS appName,
                user.profilePicUrl AS userProfilePicUrl,
                COLLECT(DISTINCT department.name) AS departments,
                app.logoUrl AS appLogoUrl,
                COLLECT(DISTINCT app_category.name) AS appCategories,
                has.approval_status AS appStatus,
                actionCurrentState,
                sortedInteractions,
                auth_type.creationTime < one_month_ago_epoch AS newlyDiscovered,
                app.breachDate * 1000 AS breachDate,
                oauthScopes,
                {
                    credsbased: COUNT(DISTINCT CASE WHEN loginMethod = 'CREDSBASED' THEN account END),
                    oauth: COUNT(DISTINCT CASE WHEN loginMethod = 'OAUTH' THEN account END),
                    saml: COUNT(DISTINCT CASE WHEN loginMethod = 'SAML' THEN account END)
                } AS loginMethodCount"
    pagination_query: "MATCH (app:APPLICATION)
                      WHERE app.id_ IN [$appId]
                      MATCH (app)<-[using_app:USING_APP]-(account:ACCOUNT {subscriber: $subscriber, tenant: $tenant})
                      MATCH (account)-[:HAS_FINDING]->(finding:FINDING)<-[:EVALUATED_TO]-(rule:RULE)-[:BELONGS_TO]->(behavior:BEHAVIOR {id: $behavior})
                      MATCH (account)<-[auth_type]-(email:EMAIL)<-[:HAS_EMAIL]-(user:USER)
                      
                      OPTIONAL MATCH (app)-[has:HAS_APP_SETTINGS]-(tenant:TENANT {id: $tenant})
                      OPTIONAL MATCH (app)-[:HAS_GRANT]-(grant:GRANT)-[:HAS_SCOPE]-(scope:SCOPE)
                      OPTIONAL MATCH (user)-[:HAS_DEPARTMENT]->(department:DEPARTMENT)
                      OPTIONAL MATCH (app)-[:HAS_APP_CATEGORY]->(app_category:APP_CATEGORY)
                      
                      OPTIONAL MATCH (finding)-[:TRIGGERED]->(action:ACTION)
                      OPTIONAL MATCH (action)-[:RESULTED_IN]-(outcome:OUTCOME)
                      OPTIONAL MATCH (action)-[:HAS_INTERACTION]->(interaction:INTERACTION)
                      
                      UNWIND ['High', 'Medium', 'Low'] AS severity
                      
                      WITH app, has, department, app_category, account, auth_type, replace(type(auth_type), '_ACCOUNT', '') AS loginMethod, email, user, finding, action, interaction, outcome,
                          datetime.truncate('day', datetime() - duration('P1M')).epochMillis AS one_month_ago_epoch,
                          severity, COUNT(DISTINCT CASE WHEN scope.severity = severity THEN scope END) as scopeCount
                      
                      WITH app, has, department, app_category, account, auth_type, loginMethod, email, user, finding, one_month_ago_epoch,
                          apoc.map.fromPairs(COLLECT(DISTINCT
                              [action.name, CASE WHEN outcome IS NOT NULL THEN outcome.description ELSE action.description END]
                          )) AS actionCurrentState,
                          COLLECT(
                              CASE WHEN interaction IS NOT NULL THEN 
                                  {message: interaction.message,
                                  name: interaction.name,
                                  messageTime: interaction.messageTime,
                                  initiator: interaction.initiator,
                                  channel: interaction.channel,
                                  mode: interaction.mode
                                  }
                              END
                          ) AS interactionsList,
                          apoc.map.fromPairs(COLLECT([severity, scopeCount])) AS oauthScopes
                      
                      UNWIND
                          CASE WHEN SIZE(interactionsList) > 0 THEN interactionsList
                          ELSE [NULL]
                      END AS interactionData
                                  
                      WITH app, has, department, app_category, account, auth_type, loginMethod, email, user, finding,
                          actionCurrentState, interactionData, one_month_ago_epoch, oauthScopes
                      ORDER BY interactionData.messageTime
                      
                      WITH app, has, department, app_category, account, auth_type, loginMethod, email, user, finding,
                          actionCurrentState, one_month_ago_epoch, oauthScopes, COLLECT(interactionData) AS sortedInteractions
                      
                      RETURN DISTINCT
                          COUNT(DISTINCT account.id) AS totalCount"
  - id: BID_15_detailed
    name: "Unused Account Drilldown Table"
    input_params:
      appId: $appId
      behavior: $behavior
    dataSourceType: "knowledgegraph"
    enabled: true
    allowed_params: true
    sortOrder: ""
    sortColumn: ""
    position: null
    template: null
    className: null
    multi_value_params:
      - id: appId
        delimiter: ","
    query: "MATCH (app:APPLICATION)
            WHERE app.id_ IN [$appId]
            MATCH (app)<-[using_app:USING_APP]-(account:ACCOUNT {subscriber: $subscriber, tenant: $tenant})
            MATCH (account)-[:HAS_FINDING]->(finding:FINDING)<-[:EVALUATED_TO]-(rule:RULE)-[:BELONGS_TO]->(behavior:BEHAVIOR {id: $behavior})
            MATCH (account)<-[auth_type]-(email:EMAIL)<-[:HAS_EMAIL]-(user:USER)
            
            OPTIONAL MATCH (app)-[has:HAS_APP_SETTINGS]-(tenant:TENANT {id: $tenant})
            OPTIONAL MATCH (app)-[:HAS_GRANT]-(grant:GRANT)-[:HAS_SCOPE]-(scope:SCOPE)
            OPTIONAL MATCH (user)-[:HAS_DEPARTMENT]->(department:DEPARTMENT)
            OPTIONAL MATCH (app)-[:HAS_APP_CATEGORY]->(app_category:APP_CATEGORY)
            
            OPTIONAL MATCH (finding)-[:TRIGGERED]->(action:ACTION)
            OPTIONAL MATCH (action)-[:RESULTED_IN]-(outcome:OUTCOME)
            OPTIONAL MATCH (action)-[:HAS_INTERACTION]->(interaction:INTERACTION)
            
            UNWIND ['High', 'Medium', 'Low'] AS severity
            
            WITH app, has, department, app_category, account, auth_type, replace(type(auth_type), '_ACCOUNT', '') AS loginMethod, email, user, finding, action, interaction, outcome,
                datetime.truncate('day', datetime() - duration('P1M')).epochMillis AS one_month_ago_epoch,
                severity, COUNT(DISTINCT CASE WHEN scope.severity = severity THEN scope END) as scopeCount
            
            WITH app, has, department, app_category, account, auth_type, loginMethod, email, user, finding, one_month_ago_epoch,
                apoc.map.fromPairs(COLLECT(DISTINCT
                    [action.name, CASE WHEN outcome IS NOT NULL THEN outcome.description ELSE action.description END]
                )) AS actionCurrentState,
                COLLECT(
                    CASE WHEN interaction IS NOT NULL THEN 
                        {message: interaction.message,
                        name: interaction.name,
                        messageTime: interaction.messageTime,
                        initiator: interaction.initiator,
                        channel: interaction.channel,
                        mode: interaction.mode
                        }
                    END
                ) AS interactionsList,
                apoc.map.fromPairs(COLLECT([severity, scopeCount])) AS oauthScopes
            
            UNWIND
                CASE WHEN SIZE(interactionsList) > 0 THEN interactionsList
                ELSE [NULL]
            END AS interactionData
                        
            WITH app, has, department, app_category, account, auth_type, loginMethod, email, user, finding,
                actionCurrentState, interactionData, one_month_ago_epoch, oauthScopes
            ORDER BY interactionData.messageTime
            
            WITH app, has, department, app_category, account, auth_type, loginMethod, email, user, finding,
                actionCurrentState, one_month_ago_epoch, oauthScopes, COLLECT(interactionData) AS sortedInteractions
            
            RETURN DISTINCT
                email.id AS userMail,
                user.displayName AS userName,
                COALESCE(app.name, app.domain, app.id) AS appName,
                user.profilePicUrl AS userProfilePicUrl,
                COLLECT(DISTINCT department.name) AS departments,
                app.logoUrl AS appLogoUrl,
                COLLECT(DISTINCT app_category.name) AS appCategories,
                has.approval_status AS appStatus,
                actionCurrentState,
                sortedInteractions,
                auth_type.creationTime < one_month_ago_epoch AS newlyDiscovered,
                app.breachDate * 1000 AS breachDate,
                oauthScopes,
                {
                    credsbased: COUNT(DISTINCT CASE WHEN loginMethod = 'CREDSBASED' THEN account END),
                    oauth: COUNT(DISTINCT CASE WHEN loginMethod = 'OAUTH' THEN account END),
                    saml: COUNT(DISTINCT CASE WHEN loginMethod = 'SAML' THEN account END)
                } AS loginMethodCount"
    pagination_query: "MATCH (app:APPLICATION)
                      WHERE app.id_ IN [$appId]
                      MATCH (app)<-[using_app:USING_APP]-(account:ACCOUNT {subscriber: $subscriber, tenant: $tenant})
                      MATCH (account)-[:HAS_FINDING]->(finding:FINDING)<-[:EVALUATED_TO]-(rule:RULE)-[:BELONGS_TO]->(behavior:BEHAVIOR {id: $behavior})
                      MATCH (account)<-[auth_type]-(email:EMAIL)<-[:HAS_EMAIL]-(user:USER)
                      
                      OPTIONAL MATCH (app)-[has:HAS_APP_SETTINGS]-(tenant:TENANT {id: $tenant})
                      OPTIONAL MATCH (app)-[:HAS_GRANT]-(grant:GRANT)-[:HAS_SCOPE]-(scope:SCOPE)
                      OPTIONAL MATCH (user)-[:HAS_DEPARTMENT]->(department:DEPARTMENT)
                      OPTIONAL MATCH (app)-[:HAS_APP_CATEGORY]->(app_category:APP_CATEGORY)
                      
                      OPTIONAL MATCH (finding)-[:TRIGGERED]->(action:ACTION)
                      OPTIONAL MATCH (action)-[:RESULTED_IN]-(outcome:OUTCOME)
                      OPTIONAL MATCH (action)-[:HAS_INTERACTION]->(interaction:INTERACTION)
                      
                      UNWIND ['High', 'Medium', 'Low'] AS severity
                      
                      WITH app, has, department, app_category, account, auth_type, replace(type(auth_type), '_ACCOUNT', '') AS loginMethod, email, user, finding, action, interaction, outcome,
                          datetime.truncate('day', datetime() - duration('P1M')).epochMillis AS one_month_ago_epoch,
                          severity, COUNT(DISTINCT CASE WHEN scope.severity = severity THEN scope END) as scopeCount
                      
                      WITH app, has, department, app_category, account, auth_type, loginMethod, email, user, finding, one_month_ago_epoch,
                          apoc.map.fromPairs(COLLECT(DISTINCT
                              [action.name, CASE WHEN outcome IS NOT NULL THEN outcome.description ELSE action.description END]
                          )) AS actionCurrentState,
                          COLLECT(
                              CASE WHEN interaction IS NOT NULL THEN 
                                  {message: interaction.message,
                                  name: interaction.name,
                                  messageTime: interaction.messageTime,
                                  initiator: interaction.initiator,
                                  channel: interaction.channel,
                                  mode: interaction.mode
                                  }
                              END
                          ) AS interactionsList,
                          apoc.map.fromPairs(COLLECT([severity, scopeCount])) AS oauthScopes
                      
                      UNWIND
                          CASE WHEN SIZE(interactionsList) > 0 THEN interactionsList
                          ELSE [NULL]
                      END AS interactionData
                                  
                      WITH app, has, department, app_category, account, auth_type, loginMethod, email, user, finding,
                          actionCurrentState, interactionData, one_month_ago_epoch, oauthScopes
                      ORDER BY interactionData.messageTime
                      
                      WITH app, has, department, app_category, account, auth_type, loginMethod, email, user, finding,
                          actionCurrentState, one_month_ago_epoch, oauthScopes, COLLECT(interactionData) AS sortedInteractions
                      
                      RETURN DISTINCT
                          COUNT(DISTINCT account.id) AS totalCount"
  - id: BID_16_detailed
    name: "Breached app usage Drilldown Table"
    input_params:
      appId: $appId
      behavior: $behavior
    dataSourceType: "knowledgegraph"
    enabled: true
    allowed_params: true
    sortOrder: ""
    sortColumn: ""
    position: null
    template: null
    className: null
    multi_value_params:
      - id: appId
        delimiter: ","
    query: "MATCH (app:APPLICATION)
            WHERE app.id_ IN [$appId]
            MATCH (app)<-[using_app:USING_APP]-(account:ACCOUNT {subscriber: $subscriber, tenant: $tenant})
            MATCH (account)-[:HAS_FINDING]->(finding:FINDING)<-[:EVALUATED_TO]-(rule:RULE)-[:BELONGS_TO]->(behavior:BEHAVIOR {id: $behavior})
            MATCH (account)<-[auth_type]-(email:EMAIL)<-[:HAS_EMAIL]-(user:USER)
            
            OPTIONAL MATCH (app)-[has:HAS_APP_SETTINGS]-(tenant:TENANT {id: $tenant})
            OPTIONAL MATCH (app)-[:HAS_GRANT]-(grant:GRANT)-[:HAS_SCOPE]-(scope:SCOPE)
            OPTIONAL MATCH (user)-[:HAS_DEPARTMENT]->(department:DEPARTMENT)
            OPTIONAL MATCH (app)-[:HAS_APP_CATEGORY]->(app_category:APP_CATEGORY)
            
            OPTIONAL MATCH (finding)-[:TRIGGERED]->(action:ACTION)
            OPTIONAL MATCH (action)-[:RESULTED_IN]-(outcome:OUTCOME)
            OPTIONAL MATCH (action)-[:HAS_INTERACTION]->(interaction:INTERACTION)
            
            UNWIND ['High', 'Medium', 'Low'] AS severity
            
            WITH app, has, department, app_category, account, auth_type, replace(type(auth_type), '_ACCOUNT', '') AS loginMethod, email, user, finding, action, interaction, outcome,
                datetime.truncate('day', datetime() - duration('P1M')).epochMillis AS one_month_ago_epoch,
                severity, COUNT(DISTINCT CASE WHEN scope.severity = severity THEN scope END) as scopeCount
            
            WITH app, has, department, app_category, account, auth_type, loginMethod, email, user, finding, one_month_ago_epoch,
                apoc.map.fromPairs(COLLECT(DISTINCT
                    [action.name, CASE WHEN outcome IS NOT NULL THEN outcome.description ELSE action.description END]
                )) AS actionCurrentState,
                COLLECT(
                    CASE WHEN interaction IS NOT NULL THEN 
                        {message: interaction.message,
                        name: interaction.name,
                        messageTime: interaction.messageTime,
                        initiator: interaction.initiator,
                        channel: interaction.channel,
                        mode: interaction.mode
                        }
                    END
                ) AS interactionsList,
                apoc.map.fromPairs(COLLECT([severity, scopeCount])) AS oauthScopes
            
            UNWIND
                CASE WHEN SIZE(interactionsList) > 0 THEN interactionsList
                ELSE [NULL]
            END AS interactionData
                        
            WITH app, has, department, app_category, account, auth_type, loginMethod, email, user, finding,
                actionCurrentState, interactionData, one_month_ago_epoch, oauthScopes
            ORDER BY interactionData.messageTime
            
            WITH app, has, department, app_category, account, auth_type, loginMethod, email, user, finding,
                actionCurrentState, one_month_ago_epoch, oauthScopes, COLLECT(interactionData) AS sortedInteractions
            
            RETURN DISTINCT
                email.id AS userMail,
                user.displayName AS userName,
                COALESCE(app.name, app.domain, app.id) AS appName,
                user.profilePicUrl AS userProfilePicUrl,
                COLLECT(DISTINCT department.name) AS departments,
                app.logoUrl AS appLogoUrl,
                COLLECT(DISTINCT app_category.name) AS appCategories,
                has.approval_status AS appStatus,
                actionCurrentState,
                sortedInteractions,
                auth_type.creationTime < one_month_ago_epoch AS newlyDiscovered,
                app.breachDate * 1000 AS breachDate,
                oauthScopes,
                {
                    credsbased: COUNT(DISTINCT CASE WHEN loginMethod = 'CREDSBASED' THEN account END),
                    oauth: COUNT(DISTINCT CASE WHEN loginMethod = 'OAUTH' THEN account END),
                    saml: COUNT(DISTINCT CASE WHEN loginMethod = 'SAML' THEN account END)
                } AS loginMethodCount"
    pagination_query: "MATCH (app:APPLICATION)
                      WHERE app.id_ IN [$appId]
                      MATCH (app)<-[using_app:USING_APP]-(account:ACCOUNT {subscriber: $subscriber, tenant: $tenant})
                      MATCH (account)-[:HAS_FINDING]->(finding:FINDING)<-[:EVALUATED_TO]-(rule:RULE)-[:BELONGS_TO]->(behavior:BEHAVIOR {id: $behavior})
                      MATCH (account)<-[auth_type]-(email:EMAIL)<-[:HAS_EMAIL]-(user:USER)
                      
                      OPTIONAL MATCH (app)-[has:HAS_APP_SETTINGS]-(tenant:TENANT {id: $tenant})
                      OPTIONAL MATCH (app)-[:HAS_GRANT]-(grant:GRANT)-[:HAS_SCOPE]-(scope:SCOPE)
                      OPTIONAL MATCH (user)-[:HAS_DEPARTMENT]->(department:DEPARTMENT)
                      OPTIONAL MATCH (app)-[:HAS_APP_CATEGORY]->(app_category:APP_CATEGORY)
                      
                      OPTIONAL MATCH (finding)-[:TRIGGERED]->(action:ACTION)
                      OPTIONAL MATCH (action)-[:RESULTED_IN]-(outcome:OUTCOME)
                      OPTIONAL MATCH (action)-[:HAS_INTERACTION]->(interaction:INTERACTION)
                      
                      UNWIND ['High', 'Medium', 'Low'] AS severity
                      
                      WITH app, has, department, app_category, account, auth_type, replace(type(auth_type), '_ACCOUNT', '') AS loginMethod, email, user, finding, action, interaction, outcome,
                          datetime.truncate('day', datetime() - duration('P1M')).epochMillis AS one_month_ago_epoch,
                          severity, COUNT(DISTINCT CASE WHEN scope.severity = severity THEN scope END) as scopeCount
                      
                      WITH app, has, department, app_category, account, auth_type, loginMethod, email, user, finding, one_month_ago_epoch,
                          apoc.map.fromPairs(COLLECT(DISTINCT
                              [action.name, CASE WHEN outcome IS NOT NULL THEN outcome.description ELSE action.description END]
                          )) AS actionCurrentState,
                          COLLECT(
                              CASE WHEN interaction IS NOT NULL THEN 
                                  {message: interaction.message,
                                  name: interaction.name,
                                  messageTime: interaction.messageTime,
                                  initiator: interaction.initiator,
                                  channel: interaction.channel,
                                  mode: interaction.mode
                                  }
                              END
                          ) AS interactionsList,
                          apoc.map.fromPairs(COLLECT([severity, scopeCount])) AS oauthScopes
                      
                      UNWIND
                          CASE WHEN SIZE(interactionsList) > 0 THEN interactionsList
                          ELSE [NULL]
                      END AS interactionData
                                  
                      WITH app, has, department, app_category, account, auth_type, loginMethod, email, user, finding,
                          actionCurrentState, interactionData, one_month_ago_epoch, oauthScopes
                      ORDER BY interactionData.messageTime
                      
                      WITH app, has, department, app_category, account, auth_type, loginMethod, email, user, finding,
                          actionCurrentState, one_month_ago_epoch, oauthScopes, COLLECT(interactionData) AS sortedInteractions
                      
                      RETURN DISTINCT
                          COUNT(DISTINCT account.id) AS totalCount"
  - id: BID_22_detailed
    name: "Blocked SaaS Apps Drilldown Table"
    input_params:
      appId: $appId
      behavior: $behavior
    dataSourceType: "knowledgegraph"
    enabled: true
    allowed_params: true
    sortOrder: ""
    sortColumn: ""
    position: null
    template: null
    className: null
    multi_value_params:
      - id: appId
        delimiter: ","
    query: "MATCH (app:APPLICATION)
            WHERE app.id_ IN [$appId]
            MATCH (account:ACCOUNT {subscriber: $subscriber, tenant: $tenant})-[:USING_APP]->(app)
            MATCH (email:EMAIL)-[auth_type]->(account)
            MATCH (user:USER)-[:HAS_EMAIL]->(email) 
            MATCH (finding:FINDING)<-[:HAS_FINDING]-(account)
            MATCH (finding)<-[:EVALUATED_TO]-(rule:RULE)-[:BELONGS_TO]->(behavior:BEHAVIOR {id: $behavior})

            WITH app, account, COLLECT(DISTINCT auth_type) AS auth_types, email, user, finding, rule, 
            datetime.truncate('day', datetime() - duration('P1M')).epochMillis AS one_month_ago_epoch

            OPTIONAL MATCH (finding)-[:TRIGGERED]->(action:ACTION)
            OPTIONAL MATCH (action)-[:RESULTED_IN]-(outcome:OUTCOME)
            OPTIONAL MATCH (finding)-[:HAS_ARTIFACT]->(dlp:DLP_FINAL_CLASS | DLP_ORIGINAL_CLASS)
            OPTIONAL MATCH (action)-[:HAS_INTERACTION]->(interaction:INTERACTION)

            WITH app, account, auth_types, email, user, rule, one_month_ago_epoch, dlp, 
            {actioned: COUNT(DISTINCT CASE WHEN action IS NOT NULL THEN finding.id END),
                pending: COUNT(DISTINCT CASE WHEN action IS NULL THEN finding.id END)} AS actionStatus, 
            COLLECT({
                 findingId: finding.id,
                 rule: rule.name, 
                 action: action.name,
                 outcomeDesc: outcome.description,
                 actionDesc: action.description,
                 interaction: CASE WHEN interaction IS NOT NULL THEN true ELSE false END
            }) AS findingData

            WITH app, account, auth_types, email, user, one_month_ago_epoch, findingData, 
                rule, dlp, actionStatus,
                ANY(data IN findingData WHERE data.interaction IS NOT NULL AND data.interaction) AS interactionsExist,
                apoc.map.fromPairs(apoc.coll.flatten(COLLECT(DISTINCT [
                   data IN findingData | [data.action, COALESCE(data.outcomeDesc, data.actionDesc)]
               ]))) AS actionCurrentState

            WITH app, account, auth_types, email, user, one_month_ago_epoch, actionStatus, 
                actionCurrentState, findingData, dlp, 
                interactionsExist

            OPTIONAL MATCH (app)-[:HAS_GRANT]->(grant:GRANT)-[:HAS_SCOPE]->(scope:SCOPE)
            WHERE scope.severity IN ['High', 'Medium', 'Low']
            WITH app, account, auth_types, email, user, actionStatus, actionCurrentState, 
                interactionsExist,
                one_month_ago_epoch, dlp, 
                COLLECT(DISTINCT CASE WHEN scope.severity = 'High' THEN scope.name END) AS highSeverityScopes,
                COLLECT(DISTINCT scope.severity) AS severityList,
                apoc.map.fromPairs(
                    CASE 
                        WHEN interactionsExist IS NOT NULL AND interactionsExist 
                        THEN [data IN findingData WHERE data.interaction IS NOT NULL AND data.interaction | [data.rule, true]]
                        ELSE []
                    END
                ) AS ruleInteractionMap

            OPTIONAL MATCH (app)-[has:HAS_APP_SETTINGS]-(tenant:TENANT {id: $tenant})
            OPTIONAL MATCH (user)-[:HAS_DEPARTMENT]->(department:DEPARTMENT)
            OPTIONAL MATCH (user)-[:BELONGS_TO]->(group:GROUP {userDefined: true})
            OPTIONAL MATCH (app)-[:HAS_APP_CATEGORY]->(app_category:APP_CATEGORY)

            WITH app, account, auth_types, email, user, actionStatus, actionCurrentState, 
                interactionsExist, 
                ruleInteractionMap, 
                one_month_ago_epoch, dlp, 
                highSeverityScopes, severityList, has, department, group, app_category,
                (EXISTS((app)-[:WHITELISTED_FOR {tenant: $tenant}]->(:BEHAVIOR {id: $behavior})) OR EXISTS((account)-[:WHITELISTED_FOR]->(:BEHAVIOR {id: $behavior}))) AS is_whitelisted,
                apoc.coll.min([auth in auth_types | auth.creationTime]) AS firstAccessed,
                apoc.coll.max([auth in auth_types | auth.last_access_time]) AS lastAccessed
    
                WHERE toLower(user.displayName) CONTAINS toLower('{searchText}') OR toLower(email.id) CONTAINS toLower('{searchText}')
                {placeholder}

            RETURN DISTINCT
                email.id AS userMail,
                user.displayName AS userName,
                COALESCE(app.name, app.domain, app.id) AS appName,
                user.profilePicUrl AS userProfilePicUrl,
                COLLECT(DISTINCT department.name) AS departments,
                is_whitelisted,
                account.id AS accountId,
                app.id_ as appId,
                app.logoUrl AS appLogoUrl,
                COLLECT(DISTINCT app_category.name) AS appCategories,
                has.approval_status AS appStatus,
                actionStatus,
                actionCurrentState,
                firstAccessed,
                lastAccessed,
                CASE 
                    WHEN COUNT(dlp.id) = 0 THEN 'No Sensitive Data Shared' 
                    ELSE COLLECT(DISTINCT dlp.id) 
                END AS sensitiveDataClasses,
                CASE
                    WHEN size(highSeverityScopes) = 0 THEN 'No High Risk Oauth Scopes'
                    ELSE highSeverityScopes
                END AS highSeverityScopes,
                CASE
                    WHEN 'High' IN severityList THEN 'High'
                    WHEN 'Medium' IN severityList THEN 'Medium'
                    WHEN 'Low' IN severityList THEN 'Low'
                END AS severityRisk,
                interactionsExist,
                ruleInteractionMap, 
                firstAccessed < one_month_ago_epoch AS newlyDiscovered
            ORDER BY lastAccessed DESC"
    pagination_query: "MATCH (app:APPLICATION)
            WHERE app.id_ IN [$appId]
            MATCH (account:ACCOUNT {subscriber: $subscriber, tenant: $tenant})-[:USING_APP]->(app)
            MATCH (email:EMAIL)-[auth_type]->(account)
            MATCH (user:USER)-[:HAS_EMAIL]->(email) 
            MATCH (finding:FINDING)<-[:HAS_FINDING]-(account)
            MATCH (finding)<-[:EVALUATED_TO]-(rule:RULE)-[:BELONGS_TO]->(behavior:BEHAVIOR {id: $behavior})

            WITH app, account, COLLECT(DISTINCT auth_type) AS auth_types, email, user, finding, rule, 
            datetime.truncate('day', datetime() - duration('P1M')).epochMillis AS one_month_ago_epoch

            OPTIONAL MATCH (finding)-[:TRIGGERED]->(action:ACTION)
            OPTIONAL MATCH (action)-[:RESULTED_IN]-(outcome:OUTCOME)
            OPTIONAL MATCH (finding)-[:HAS_ARTIFACT]->(dlp:DLP_FINAL_CLASS | DLP_ORIGINAL_CLASS)
            OPTIONAL MATCH (action)-[:HAS_INTERACTION]->(interaction:INTERACTION)

            WITH app, account, auth_types, email, user, rule, one_month_ago_epoch, dlp, 
            {actioned: COUNT(DISTINCT CASE WHEN action IS NOT NULL THEN finding.id END),
                pending: COUNT(DISTINCT CASE WHEN action IS NULL THEN finding.id END)} AS actionStatus, 
            COLLECT({
                 findingId: finding.id,
                 rule: rule.name, 
                 action: action.name,
                 outcomeDesc: outcome.description,
                 actionDesc: action.description,
                 interaction: CASE WHEN interaction IS NOT NULL THEN true ELSE false END
            }) AS findingData

            WITH app, account, auth_types, email, user, one_month_ago_epoch, findingData, 
                rule, dlp, actionStatus,
                ANY(data IN findingData WHERE data.interaction IS NOT NULL AND data.interaction) AS interactionsExist,
                apoc.map.fromPairs(apoc.coll.flatten(COLLECT(DISTINCT [
                   data IN findingData | [data.action, COALESCE(data.outcomeDesc, data.actionDesc)]
               ]))) AS actionCurrentState

            WITH app, account, auth_types, email, user, one_month_ago_epoch, actionStatus, 
                actionCurrentState, findingData, dlp, 
                interactionsExist

            OPTIONAL MATCH (app)-[:HAS_GRANT]->(grant:GRANT)-[:HAS_SCOPE]->(scope:SCOPE)
            WHERE scope.severity IN ['High', 'Medium', 'Low']
            WITH app, account, auth_types, email, user, actionStatus, actionCurrentState, 
                interactionsExist,
                one_month_ago_epoch, dlp, 
                COLLECT(DISTINCT CASE WHEN scope.severity = 'High' THEN scope.name END) AS highSeverityScopes,
                COLLECT(DISTINCT scope.severity) AS severityList,
                apoc.map.fromPairs(
                    CASE 
                        WHEN interactionsExist IS NOT NULL AND interactionsExist 
                        THEN [data IN findingData WHERE data.interaction IS NOT NULL AND data.interaction | [data.rule, true]]
                        ELSE []
                    END
                ) AS ruleInteractionMap

            OPTIONAL MATCH (app)-[has:HAS_APP_SETTINGS]-(tenant:TENANT {id: $tenant})
            OPTIONAL MATCH (user)-[:HAS_DEPARTMENT]->(department:DEPARTMENT)
            OPTIONAL MATCH (user)-[:BELONGS_TO]->(group:GROUP {userDefined: true})
            OPTIONAL MATCH (app)-[:HAS_APP_CATEGORY]->(app_category:APP_CATEGORY)

            WITH app, account, auth_types, email, user, actionStatus, actionCurrentState, 
                interactionsExist, 
                ruleInteractionMap, 
                one_month_ago_epoch, dlp, 
                highSeverityScopes, severityList, has, department, group, app_category,
                (EXISTS((app)-[:WHITELISTED_FOR {tenant: $tenant}]->(:BEHAVIOR {id: $behavior})) OR EXISTS((account)-[:WHITELISTED_FOR]->(:BEHAVIOR {id: $behavior}))) AS is_whitelisted,
                apoc.coll.min([auth in auth_types | auth.creationTime]) AS firstAccessed,
                apoc.coll.max([auth in auth_types | auth.last_access_time]) AS lastAccessed
    
                WHERE toLower(user.displayName) CONTAINS toLower('{searchText}') OR toLower(email.id) CONTAINS toLower('{searchText}')
                {placeholder}

            RETURN DISTINCT
                COUNT(DISTINCT account.id) AS totalCount"
  - id: interactions_metadata
    query: "MATCH (account:ACCOUNT {id: $accountId, subscriber: $subscriber, tenant: $tenant})
            MATCH (email:EMAIL)-[auth_type]->(account)
            MATCH (user:USER)-[:HAS_EMAIL]->(email) 
            MATCH (finding:FINDING)<-[:HAS_FINDING]-(account)
            MATCH (finding)<-[:EVALUATED_TO]-(rule:RULE)-[:BELONGS_TO]->(behavior:BEHAVIOR {id: $behavior})

            OPTIONAL MATCH (finding)-[:TRIGGERED]->(action:ACTION)-[:HAS_INTERACTION]->(interaction:INTERACTION)
            WHERE interaction IS NOT NULL
            {placeholder}
                        
            WITH rule, interaction, action
            WHERE interaction IS NOT NULL 
              AND action IS NOT NULL
              AND interaction.messageTime IS NOT NULL
              AND btrim(COALESCE(interaction.message, apoc.text.join([interaction.header, interaction.title, interaction.description], ' '))) <> ''
              AND btrim(COALESCE(interaction.message, apoc.text.join([interaction.header, interaction.title, interaction.description], ' '))) IS NOT NULL
            
            RETURN DISTINCT 
                rule.name AS ruleName,
                btrim(COALESCE(interaction.message, apoc.text.join([interaction.header, interaction.title, interaction.description], ' '))) AS message,
                interaction.messageTime AS messageTime,
                interaction.initiator AS initiator, 
                action.name AS action, 
                interaction.channel AS channel, 
                interaction.mode AS mode
            ORDER BY interaction.messageTime ASC"
    input_params:
      behavior: $behavior
      accountId: $accountId
      ruleName: AND tolower(rule.name) = tolower($ruleName)
    dataSourceType: "knowledgegraph"
    enabled: true
    allowed_params: true
    sortOrder: ""
    sortColumn: ""
    requestType: POST
    name: "Interaction Metadata"
    position: null
    template: null
    className: null
    multi_value_params: []
    pagination_query: "MATCH (account:ACCOUNT {id: $accountId, subscriber: $subscriber, tenant: $tenant})
                       MATCH (email:EMAIL)-[auth_type]->(account)
                       MATCH (user:USER)-[:HAS_EMAIL]->(email) 
                       MATCH (finding:FINDING)<-[:HAS_FINDING]-(account)
                       MATCH (finding)<-[:EVALUATED_TO]-(rule:RULE)-[:BELONGS_TO]->(behavior:BEHAVIOR {id: $behavior})

                       OPTIONAL MATCH (finding)-[:TRIGGERED]->(action:ACTION)-[:HAS_INTERACTION]->(interaction:INTERACTION)
                       WHERE interaction IS NOT NULL
                       {placeholder}
                       
                       WITH rule, interaction, action
                       WHERE interaction IS NOT NULL 
                         AND action IS NOT NULL
                         AND interaction.messageTime IS NOT NULL
                         AND btrim(COALESCE(interaction.message, apoc.text.join([interaction.header, interaction.title, interaction.description], ' '))) <> ''
                         AND btrim(COALESCE(interaction.message, apoc.text.join([interaction.header, interaction.title, interaction.description], ' '))) IS NOT NULL
            
                       WITH DISTINCT 
                           rule.name AS ruleName,
                           btrim(COALESCE(interaction.message, apoc.text.join([interaction.header, interaction.title, interaction.description], ' '))) AS message,
                           interaction.messageTime AS messageTime,
                           interaction.initiator AS initiator, 
                           action.name AS action, 
                           interaction.channel AS channel, 
                           interaction.mode AS mode

                       RETURN COUNT(*) AS totalCount"
view_by:
  - id: BID_12
    name: "High Risk Oauth Scope"
    type: widget
    active: true
    defaultValue: null
    queryFilters: []
    className: ""
    query: "CALL {
              WITH datetime.truncate('day', datetime() - duration('P1M')).epochMillis AS one_month_ago_epoch
          
              MATCH (finding:FINDING {subscriber: $subscriber, tenant: $tenant})<-[:EVALUATED_TO]-(rule:RULE)-[:BELONGS_TO]->(behavior:BEHAVIOR {id: $behavior})
              MATCH (u:USER)-[:HAS_EMAIL]->(email:EMAIL)-[AUTH_TYPE]->(account:ACCOUNT)-[:HAS_FINDING]->(finding)
              MATCH (account)-[:USING_APP]->(app:APPLICATION)-[:HAS_APP_CATEGORY]->(category:APP_CATEGORY)
              OPTIONAL MATCH (account)-[:HAS_CRED_FINGERPRINT]-(cred:CRED_FINGERPRINT)-[]-(same_password_account:ACCOUNT)
          
              OPTIONAL MATCH (app)-[:HAS_ADMIN]->(owner:ACCOUNT)
              OPTIONAL MATCH (finding)-[:TRIGGERED]->(action:ACTION)
              OPTIONAL MATCH (action)-[:RESULTED_IN]->(outcome:OUTCOME)
              OPTIONAL MATCH (app)<-[hs:HAS_APP_SETTINGS]-(t:TENANT {id: $tenant})
              OPTIONAL MATCH (app)-[:HAS_GRANT]->(grant:GRANT)-[:HAS_SCOPE]->(scope:SCOPE)
              
              UNWIND ['High', 'Medium', 'Low'] AS severity
          
              WITH app, owner, account, AUTH_TYPE, replace(type(AUTH_TYPE), '_ACCOUNT', '') AS loginMethod, hs, category, finding, action, severity, COUNT(DISTINCT CASE WHEN scope.severity = severity THEN scope END) as scopeCount,
              COALESCE(action.name, '-') AS actionName, COUNT(DISTINCT action.id) AS actionCount,
              CASE WHEN action IS NOT NULL AND outcome IS NULL THEN 'Not Responded'
                  WHEN outcome IS NOT NULL THEN COALESCE(outcome.value, outcome.message, '-')
              END as outcomeValue,
              COUNT(DISTINCT action.id) as outcomeCount,
              one_month_ago_epoch
          
              WITH app, owner, account, AUTH_TYPE, loginMethod, hs, category, finding, action,
              COLLECT([severity, scopeCount]) AS scopeSeverities,
              actionName, actionCount, apoc.map.fromPairs(COLLECT([outcomeValue, outcomeCount])) as outcomeMap,
              one_month_ago_epoch
          
              RETURN 
                  app, 
                  owner.email AS appAdmin, 
                  COUNT(DISTINCT account) AS accounts, 
                  COLLECT(DISTINCT {name: category.name, priority: category.priority}) AS categories, 
                  MIN(CASE WHEN account.creationTime = '-' THEN NULL ELSE account.creationTime END) AS firstAccessTime,
                  MAX(COALESCE(AUTH_TYPE.last_access_time, 0)) AS lastAccessTime,  
                  COALESCE(hs.approval_status, 'NEEDS REVIEW') AS status, 
                  COALESCE(hs.logoUrl, app.logoUrl) AS logo, 
                  COUNT(DISTINCT CASE WHEN finding IS NOT NULL THEN account.id END) AS accountsWithFindings,
                  apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, actionCount] END)) AS actionResults,
                  apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, outcomeMap] END)) AS actionOutcomes,
                  {actioned: COUNT(DISTINCT CASE WHEN action IS NOT NULL THEN finding.id END),
                      pending: COUNT(DISTINCT CASE WHEN action IS NULL THEN finding.id END)} AS reviewStatus,
                  CASE 
                      WHEN app.totalScore IN [1, 2] THEN 'Very High'
                      WHEN app.totalScore IN [3, 4] THEN 'High'
                      WHEN app.totalScore IN [5, 6] THEN 'Moderate'
                      WHEN app.totalScore IN [7, 8] THEN 'Low'
                      WHEN app.totalScore IN [9, 10] THEN 'Very Low'
                      ELSE 'Unknown'
                  END AS appRiskLevel,
                  COUNT(DISTINCT CASE WHEN AUTH_TYPE.last_access_time < one_month_ago_epoch THEN account END) AS unusedAccounts,
                  apoc.map.fromPairs(scopeSeverities) AS oauthScopesSeverity,
                  one_month_ago_epoch,
                  {
                      credsbased: COUNT(DISTINCT CASE WHEN loginMethod = 'CREDSBASED' THEN account END),
                      oauth: COUNT(DISTINCT CASE WHEN loginMethod = 'OAUTH' THEN account END),
                      saml: COUNT(DISTINCT CASE WHEN loginMethod = 'SAML' THEN account END)
                  } AS loginMethodCount
          }
          
          WITH app, appAdmin, appRiskLevel, categories, lastAccessTime, firstAccessTime, accountsWithFindings,
              status, logo, accounts AS totalAccounts, reviewStatus, 
              one_month_ago_epoch, actionResults, actionOutcomes, unusedAccounts, oauthScopesSeverity, loginMethodCount
          
          WHERE toLower(COALESCE(app.name, app.domain)) CONTAINS toLower('{searchText}') 
          {placeholder}
          
          RETURN DISTINCT
              COALESCE(app.id_, app.internalId) AS id, 
              COALESCE(app.name, app.domain, app.id) AS app, 
              appAdmin, 
              appRiskLevel,
              COALESCE(app.criticality, 'Not Set') AS criticality, 
              status, 
              NOT status in ['APPROVED', 'UNAPPROVED'] AND COALESCE(firstAccessTime > one_month_ago_epoch, true) AS newlyDiscovered,
              logo, 
              [cat IN categories WHERE cat.priority = 2 | cat.name] AS highPriorityCategories, 
              totalAccounts, 
              accountsWithFindings, 
              reviewStatus,
              firstAccessTime,
              lastAccessTime,
              actionResults,
              actionOutcomes,
              CASE WHEN app.breachDate > 0 THEN app.breachDate * 1000 ELSE NULL END AS breachDate,
              unusedAccounts,
              oauthScopesSeverity,
              loginMethodCount
          ORDER BY totalAccounts DESC, lastAccessTime DESC"
    allowed_params: true
    input_params:
      behavior: $behavior
      risk_level: AND appRiskLevel = $risk_level
      criticality: AND toLower(COALESCE(hs.criticality, app.criticality)) = toLower($criticality)
      approval_status: AND toLower(status) = toLower($approval_status)
      number_of_accounts_greater_than: AND totalAccounts > $number_of_accounts_greater_than
      number_of_accounts_less_than: AND totalAccounts < $number_of_accounts_less_than
      technical_owner: AND appAdmin = $technical_owner
      newly_discovered: AND NOT status in ['APPROVED', 'UNAPPROVED'] AND COALESCE(firstAccessTime > one_month_ago_epoch, true) = $newly_discovered
      action_status: AND CASE WHEN toLower($action_status) = 'actioned' THEN reviewStatus['actioned'] > 0 ELSE reviewStatus['actioned'] = 0 END
      password_hygiene: AND passwordHygiene[$password_hygiene] > 0
      mfa_status: AND CASE WHEN $mfa_status = 'null' THEN mfaStatus IS NULL ELSE mfaStatus[$mfa_status] > 0 END
    dataSourceType: "knowledgegraph"
    pagination_query: "
          CALL {
              WITH datetime.truncate('day', datetime() - duration('P1M')).epochMillis AS one_month_ago_epoch
          
              MATCH (finding:FINDING {subscriber: $subscriber, tenant: $tenant})<-[:EVALUATED_TO]-(rule:RULE)-[:BELONGS_TO]->(behavior:BEHAVIOR {id: $behavior})
              MATCH (u:USER)-[:HAS_EMAIL]->(email:EMAIL)-[AUTH_TYPE]->(account:ACCOUNT)-[:HAS_FINDING]->(finding)
              MATCH (account)-[:USING_APP]->(app:APPLICATION)-[:HAS_APP_CATEGORY]->(category:APP_CATEGORY)
              OPTIONAL MATCH (account)-[:HAS_CRED_FINGERPRINT]-(cred:CRED_FINGERPRINT)-[]-(same_password_account:ACCOUNT)
          
              OPTIONAL MATCH (app)-[:HAS_ADMIN]->(owner:ACCOUNT)
              OPTIONAL MATCH (finding)-[:TRIGGERED]->(action:ACTION)
              OPTIONAL MATCH (action)-[:RESULTED_IN]->(outcome:OUTCOME)
              OPTIONAL MATCH (app)<-[hs:HAS_APP_SETTINGS]-(t:TENANT {id: $tenant})
              OPTIONAL MATCH (app)-[:HAS_GRANT]->(grant:GRANT)-[:HAS_SCOPE]->(scope:SCOPE)
              
              UNWIND ['High', 'Medium', 'Low'] AS severity
          
              WITH app, owner, account, AUTH_TYPE, replace(type(AUTH_TYPE), '_ACCOUNT', '') AS loginMethod, hs, category, finding, action, severity, COUNT(DISTINCT CASE WHEN scope.severity = severity THEN scope END) as scopeCount,
              COALESCE(action.name, '-') AS actionName, COUNT(DISTINCT action.id) AS actionCount,
              CASE WHEN action IS NOT NULL AND outcome IS NULL THEN 'Not Responded'
                  WHEN outcome IS NOT NULL THEN COALESCE(outcome.value, outcome.message, '-')
              END as outcomeValue,
              COUNT(DISTINCT action.id) as outcomeCount,
              one_month_ago_epoch
          
              WITH app, owner, account, AUTH_TYPE, loginMethod, hs, category, finding, action,
              COLLECT([severity, scopeCount]) AS scopeSeverities,
              actionName, actionCount, apoc.map.fromPairs(COLLECT([outcomeValue, outcomeCount])) as outcomeMap,
              one_month_ago_epoch
          
              RETURN 
                  app, 
                  owner.email AS appAdmin, 
                  COUNT(DISTINCT account) AS accounts, 
                  COLLECT(DISTINCT {name: category.name, priority: category.priority}) AS categories, 
                  MIN(CASE WHEN account.creationTime = '-' THEN NULL ELSE account.creationTime END) AS firstAccessTime,
                  MAX(COALESCE(AUTH_TYPE.last_access_time, 0)) AS lastAccessTime,  
                  COALESCE(hs.approval_status, 'NEEDS REVIEW') AS status, 
                  COALESCE(hs.logoUrl, app.logoUrl) AS logo, 
                  COUNT(DISTINCT CASE WHEN finding IS NOT NULL THEN account.id END) AS accountsWithFindings,
                  apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, actionCount] END)) AS actionResults,
                  apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, outcomeMap] END)) AS actionOutcomes,
                  {actioned: COUNT(DISTINCT CASE WHEN action IS NOT NULL THEN finding.id END),
                      pending: COUNT(DISTINCT CASE WHEN action IS NULL THEN finding.id END)} AS reviewStatus,
                  CASE 
                      WHEN app.totalScore IN [1, 2] THEN 'Very High'
                      WHEN app.totalScore IN [3, 4] THEN 'High'
                      WHEN app.totalScore IN [5, 6] THEN 'Moderate'
                      WHEN app.totalScore IN [7, 8] THEN 'Low'
                      WHEN app.totalScore IN [9, 10] THEN 'Very Low'
                      ELSE 'Unknown'
                  END AS appRiskLevel,
                  COUNT(DISTINCT CASE WHEN AUTH_TYPE.last_access_time < one_month_ago_epoch THEN account END) AS unusedAccounts,
                  apoc.map.fromPairs(scopeSeverities) AS oauthScopesSeverity,
                  one_month_ago_epoch,
                  {
                      credsbased: COUNT(DISTINCT CASE WHEN loginMethod = 'CREDSBASED' THEN account END),
                      oauth: COUNT(DISTINCT CASE WHEN loginMethod = 'OAUTH' THEN account END),
                      saml: COUNT(DISTINCT CASE WHEN loginMethod = 'SAML' THEN account END)
                  } AS loginMethodCount
          }
          
          WITH app, appAdmin, appRiskLevel, categories, lastAccessTime, firstAccessTime, accountsWithFindings,
              status, logo, accounts AS totalAccounts, reviewStatus, 
              one_month_ago_epoch, actionResults, actionOutcomes, unusedAccounts, oauthScopesSeverity, loginMethodCount
          
          WHERE toLower(COALESCE(app.name, app.domain)) CONTAINS toLower('{searchText}')  
          {placeholder}

          RETURN
              COUNT(DISTINCT COALESCE(app.id_, app.internalId)) AS totalCount"
  - id: BID_13
    name: "Terminated User with enabled account"
    type: widget
    active: true
    defaultValue: null
    queryFilters: []
    className: ""
    query: "CALL {
              WITH datetime.truncate('day', datetime() - duration('P1M')).epochMillis AS one_month_ago_epoch
          
              MATCH (finding:FINDING {subscriber: $subscriber, tenant: $tenant})<-[:EVALUATED_TO]-(rule:RULE)-[:BELONGS_TO]->(behavior:BEHAVIOR {id: $behavior})
              MATCH (u:USER)-[:HAS_EMAIL]->(email:EMAIL)-[AUTH_TYPE]->(account:ACCOUNT)-[:HAS_FINDING]->(finding)
              MATCH (account)-[:USING_APP]->(app:APPLICATION)-[:HAS_APP_CATEGORY]->(category:APP_CATEGORY)
              OPTIONAL MATCH (account)-[:HAS_CRED_FINGERPRINT]-(cred:CRED_FINGERPRINT)-[]-(same_password_account:ACCOUNT)
          
              OPTIONAL MATCH (app)-[:HAS_ADMIN]->(owner:ACCOUNT)
              OPTIONAL MATCH (finding)-[:TRIGGERED]->(action:ACTION)
              OPTIONAL MATCH (action)-[:RESULTED_IN]->(outcome:OUTCOME)
              OPTIONAL MATCH (app)<-[hs:HAS_APP_SETTINGS]-(t:TENANT {id: $tenant})
              OPTIONAL MATCH (app)-[:HAS_GRANT]->(grant:GRANT)-[:HAS_SCOPE]->(scope:SCOPE)
              
              UNWIND ['High', 'Medium', 'Low'] AS severity
          
              WITH app, owner, account, AUTH_TYPE, replace(type(AUTH_TYPE), '_ACCOUNT', '') AS loginMethod, hs, category, finding, action, severity, COUNT(DISTINCT CASE WHEN scope.severity = severity THEN scope END) as scopeCount,
              COALESCE(action.name, '-') AS actionName, COUNT(DISTINCT action.id) AS actionCount,
              CASE WHEN action IS NOT NULL AND outcome IS NULL THEN 'Not Responded'
                  WHEN outcome IS NOT NULL THEN COALESCE(outcome.value, outcome.message, '-')
              END as outcomeValue,
              COUNT(DISTINCT action.id) as outcomeCount,
              one_month_ago_epoch
          
              WITH app, owner, account, AUTH_TYPE, loginMethod, hs, category, finding, action,
              COLLECT([severity, scopeCount]) AS scopeSeverities,
              actionName, actionCount, apoc.map.fromPairs(COLLECT([outcomeValue, outcomeCount])) as outcomeMap,
              one_month_ago_epoch
          
              RETURN 
                  app, 
                  owner.email AS appAdmin, 
                  COUNT(DISTINCT account) AS accounts, 
                  COLLECT(DISTINCT {name: category.name, priority: category.priority}) AS categories, 
                  MIN(CASE WHEN account.creationTime = '-' THEN NULL ELSE account.creationTime END) AS firstAccessTime,
                  MAX(COALESCE(AUTH_TYPE.last_access_time, 0)) AS lastAccessTime,  
                  COALESCE(hs.approval_status, 'NEEDS REVIEW') AS status, 
                  COALESCE(hs.logoUrl, app.logoUrl) AS logo, 
                  COUNT(DISTINCT CASE WHEN finding IS NOT NULL THEN account.id END) AS accountsWithFindings,
                  apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, actionCount] END)) AS actionResults,
                  apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, outcomeMap] END)) AS actionOutcomes,
                  {actioned: COUNT(DISTINCT CASE WHEN action IS NOT NULL THEN finding.id END),
                      pending: COUNT(DISTINCT CASE WHEN action IS NULL THEN finding.id END)} AS reviewStatus,
                  CASE 
                      WHEN app.totalScore IN [1, 2] THEN 'Very High'
                      WHEN app.totalScore IN [3, 4] THEN 'High'
                      WHEN app.totalScore IN [5, 6] THEN 'Moderate'
                      WHEN app.totalScore IN [7, 8] THEN 'Low'
                      WHEN app.totalScore IN [9, 10] THEN 'Very Low'
                      ELSE 'Unknown'
                  END AS appRiskLevel,
                  COUNT(DISTINCT CASE WHEN AUTH_TYPE.last_access_time < one_month_ago_epoch THEN account END) AS unusedAccounts,
                  apoc.map.fromPairs(scopeSeverities) AS oauthScopesSeverity,
                  one_month_ago_epoch,
                  {
                      credsbased: COUNT(DISTINCT CASE WHEN loginMethod = 'CREDSBASED' THEN account END),
                      oauth: COUNT(DISTINCT CASE WHEN loginMethod = 'OAUTH' THEN account END),
                      saml: COUNT(DISTINCT CASE WHEN loginMethod = 'SAML' THEN account END)
                  } AS loginMethodCount
          }
          
          WITH app, appAdmin, appRiskLevel, categories, lastAccessTime, firstAccessTime, accountsWithFindings,
              status, logo, accounts AS totalAccounts, reviewStatus, 
              one_month_ago_epoch, actionResults, actionOutcomes, unusedAccounts, oauthScopesSeverity, loginMethodCount
          
          WHERE toLower(COALESCE(app.name, app.domain)) CONTAINS toLower('{searchText}') 
          {placeholder}
          
          RETURN DISTINCT
              COALESCE(app.id_, app.internalId) AS id, 
              COALESCE(app.name, app.domain, app.id) AS app, 
              appAdmin, 
              appRiskLevel,
              COALESCE(app.criticality, 'Not Set') AS criticality, 
              status, 
              NOT status in ['APPROVED', 'UNAPPROVED'] AND COALESCE(firstAccessTime > one_month_ago_epoch, true) AS newlyDiscovered,
              logo, 
              [cat IN categories WHERE cat.priority = 2 | cat.name] AS highPriorityCategories, 
              totalAccounts, 
              accountsWithFindings, 
              reviewStatus,
              firstAccessTime,
              lastAccessTime,
              actionResults,
              actionOutcomes,
              CASE WHEN app.breachDate > 0 THEN app.breachDate * 1000 ELSE NULL END AS breachDate,
              unusedAccounts,
              oauthScopesSeverity,
              loginMethodCount
          ORDER BY totalAccounts DESC, lastAccessTime DESC"
    allowed_params: true
    input_params:
      behavior: $behavior
      risk_level: AND appRiskLevel = $risk_level
      criticality: AND toLower(COALESCE(hs.criticality, app.criticality)) = toLower($criticality)
      approval_status: AND toLower(status) = toLower($approval_status)
      number_of_accounts_greater_than: AND totalAccounts > $number_of_accounts_greater_than
      number_of_accounts_less_than: AND totalAccounts < $number_of_accounts_less_than
      technical_owner: AND appAdmin = $technical_owner
      newly_discovered: AND NOT status in ['APPROVED', 'UNAPPROVED'] AND COALESCE(firstAccessTime > one_month_ago_epoch, true) = $newly_discovered
      action_status: AND CASE WHEN toLower($action_status) = 'actioned' THEN reviewStatus['actioned'] > 0 ELSE reviewStatus['actioned'] = 0 END
      password_hygiene: AND passwordHygiene[$password_hygiene] > 0
      mfa_status: AND CASE WHEN $mfa_status = 'null' THEN mfaStatus IS NULL ELSE mfaStatus[$mfa_status] > 0 END
    dataSourceType: "knowledgegraph"
    pagination_query: "
          CALL {
              WITH datetime.truncate('day', datetime() - duration('P1M')).epochMillis AS one_month_ago_epoch
          
              MATCH (finding:FINDING {subscriber: $subscriber, tenant: $tenant})<-[:EVALUATED_TO]-(rule:RULE)-[:BELONGS_TO]->(behavior:BEHAVIOR {id: $behavior})
              MATCH (u:USER)-[:HAS_EMAIL]->(email:EMAIL)-[AUTH_TYPE]->(account:ACCOUNT)-[:HAS_FINDING]->(finding)
              MATCH (account)-[:USING_APP]->(app:APPLICATION)-[:HAS_APP_CATEGORY]->(category:APP_CATEGORY)
              OPTIONAL MATCH (account)-[:HAS_CRED_FINGERPRINT]-(cred:CRED_FINGERPRINT)-[]-(same_password_account:ACCOUNT)
          
              OPTIONAL MATCH (app)-[:HAS_ADMIN]->(owner:ACCOUNT)
              OPTIONAL MATCH (finding)-[:TRIGGERED]->(action:ACTION)
              OPTIONAL MATCH (action)-[:RESULTED_IN]->(outcome:OUTCOME)
              OPTIONAL MATCH (app)<-[hs:HAS_APP_SETTINGS]-(t:TENANT {id: $tenant})
              OPTIONAL MATCH (app)-[:HAS_GRANT]->(grant:GRANT)-[:HAS_SCOPE]->(scope:SCOPE)
              
              UNWIND ['High', 'Medium', 'Low'] AS severity
          
              WITH app, owner, account, AUTH_TYPE, replace(type(AUTH_TYPE), '_ACCOUNT', '') AS loginMethod, hs, category, finding, action, severity, COUNT(DISTINCT CASE WHEN scope.severity = severity THEN scope END) as scopeCount,
              COALESCE(action.name, '-') AS actionName, COUNT(DISTINCT action.id) AS actionCount,
              CASE WHEN action IS NOT NULL AND outcome IS NULL THEN 'Not Responded'
                  WHEN outcome IS NOT NULL THEN COALESCE(outcome.value, outcome.message, '-')
              END as outcomeValue,
              COUNT(DISTINCT action.id) as outcomeCount,
              one_month_ago_epoch
          
              WITH app, owner, account, AUTH_TYPE, loginMethod, hs, category, finding, action,
              COLLECT([severity, scopeCount]) AS scopeSeverities,
              actionName, actionCount, apoc.map.fromPairs(COLLECT([outcomeValue, outcomeCount])) as outcomeMap,
              one_month_ago_epoch
          
              RETURN 
                  app, 
                  owner.email AS appAdmin, 
                  COUNT(DISTINCT account) AS accounts, 
                  COLLECT(DISTINCT {name: category.name, priority: category.priority}) AS categories, 
                  MIN(CASE WHEN account.creationTime = '-' THEN NULL ELSE account.creationTime END) AS firstAccessTime,
                  MAX(COALESCE(AUTH_TYPE.last_access_time, 0)) AS lastAccessTime,  
                  COALESCE(hs.approval_status, 'NEEDS REVIEW') AS status, 
                  COALESCE(hs.logoUrl, app.logoUrl) AS logo, 
                  COUNT(DISTINCT CASE WHEN finding IS NOT NULL THEN account.id END) AS accountsWithFindings,
                  apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, actionCount] END)) AS actionResults,
                  apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, outcomeMap] END)) AS actionOutcomes,
                  {actioned: COUNT(DISTINCT CASE WHEN action IS NOT NULL THEN finding.id END),
                      pending: COUNT(DISTINCT CASE WHEN action IS NULL THEN finding.id END)} AS reviewStatus,
                  CASE 
                      WHEN app.totalScore IN [1, 2] THEN 'Very High'
                      WHEN app.totalScore IN [3, 4] THEN 'High'
                      WHEN app.totalScore IN [5, 6] THEN 'Moderate'
                      WHEN app.totalScore IN [7, 8] THEN 'Low'
                      WHEN app.totalScore IN [9, 10] THEN 'Very Low'
                      ELSE 'Unknown'
                  END AS appRiskLevel,
                  COUNT(DISTINCT CASE WHEN AUTH_TYPE.last_access_time < one_month_ago_epoch THEN account END) AS unusedAccounts,
                  apoc.map.fromPairs(scopeSeverities) AS oauthScopesSeverity,
                  one_month_ago_epoch,
                  {
                      credsbased: COUNT(DISTINCT CASE WHEN loginMethod = 'CREDSBASED' THEN account END),
                      oauth: COUNT(DISTINCT CASE WHEN loginMethod = 'OAUTH' THEN account END),
                      saml: COUNT(DISTINCT CASE WHEN loginMethod = 'SAML' THEN account END)
                  } AS loginMethodCount
          }
          
          WITH app, appAdmin, appRiskLevel, categories, lastAccessTime, firstAccessTime, accountsWithFindings,
              status, logo, accounts AS totalAccounts, reviewStatus, 
              one_month_ago_epoch, actionResults, actionOutcomes, unusedAccounts, oauthScopesSeverity, loginMethodCount
          
          WHERE toLower(COALESCE(app.name, app.domain)) CONTAINS toLower('{searchText}')
          {placeholder}

          RETURN
              COUNT(DISTINCT COALESCE(app.id_, app.internalId)) AS totalCount"
  - id: BID_14
    name: "Unapproved SaaS app"
    type: widget
    active: true
    defaultValue: null
    queryFilters: []
    className: ""
    query: "CALL {
              WITH datetime.truncate('day', datetime() - duration('P1M')).epochMillis AS one_month_ago_epoch
          
              MATCH (finding:FINDING {subscriber: $subscriber, tenant: $tenant})<-[:EVALUATED_TO]-(rule:RULE)-[:BELONGS_TO]->(behavior:BEHAVIOR {id: $behavior})
              MATCH (u:USER)-[:HAS_EMAIL]->(email:EMAIL)-[AUTH_TYPE]->(account:ACCOUNT)-[:HAS_FINDING]->(finding)
              MATCH (account)-[:USING_APP]->(app:APPLICATION)-[:HAS_APP_CATEGORY]->(category:APP_CATEGORY)
              OPTIONAL MATCH (account)-[:HAS_CRED_FINGERPRINT]-(cred:CRED_FINGERPRINT)-[]-(same_password_account:ACCOUNT)
          
              OPTIONAL MATCH (app)-[:HAS_ADMIN]->(owner:ACCOUNT)
              OPTIONAL MATCH (finding)-[:TRIGGERED]->(action:ACTION)
              OPTIONAL MATCH (action)-[:RESULTED_IN]->(outcome:OUTCOME)
              OPTIONAL MATCH (app)<-[hs:HAS_APP_SETTINGS]-(t:TENANT {id: $tenant})
              OPTIONAL MATCH (app)-[:HAS_GRANT]->(grant:GRANT)-[:HAS_SCOPE]->(scope:SCOPE)
              
              UNWIND ['High', 'Medium', 'Low'] AS severity
          
              WITH app, owner, account, AUTH_TYPE, replace(type(AUTH_TYPE), '_ACCOUNT', '') AS loginMethod, hs, category, finding, action, severity, COUNT(DISTINCT CASE WHEN scope.severity = severity THEN scope END) as scopeCount,
              COALESCE(action.name, '-') AS actionName, COUNT(DISTINCT action.id) AS actionCount,
              CASE WHEN action IS NOT NULL AND outcome IS NULL THEN 'Not Responded'
                  WHEN outcome IS NOT NULL THEN COALESCE(outcome.value, outcome.message, '-')
              END as outcomeValue,
              COUNT(DISTINCT action.id) as outcomeCount,
              one_month_ago_epoch
          
              WITH app, owner, account, AUTH_TYPE, loginMethod, hs, category, finding, action,
              COLLECT([severity, scopeCount]) AS scopeSeverities,
              actionName, actionCount, apoc.map.fromPairs(COLLECT([outcomeValue, outcomeCount])) as outcomeMap,
              one_month_ago_epoch
          
              RETURN 
                  app, 
                  owner.email AS appAdmin, 
                  COUNT(DISTINCT account) AS accounts, 
                  COLLECT(DISTINCT {name: category.name, priority: category.priority}) AS categories, 
                  MIN(CASE WHEN account.creationTime = '-' THEN NULL ELSE account.creationTime END) AS firstAccessTime,
                  MAX(COALESCE(AUTH_TYPE.last_access_time, 0)) AS lastAccessTime,  
                  COALESCE(hs.approval_status, 'NEEDS REVIEW') AS status, 
                  COALESCE(hs.logoUrl, app.logoUrl) AS logo, 
                  COUNT(DISTINCT CASE WHEN finding IS NOT NULL THEN account.id END) AS accountsWithFindings,
                  apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, actionCount] END)) AS actionResults,
                  apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, outcomeMap] END)) AS actionOutcomes,
                  {actioned: COUNT(DISTINCT CASE WHEN action IS NOT NULL THEN finding.id END),
                      pending: COUNT(DISTINCT CASE WHEN action IS NULL THEN finding.id END)} AS reviewStatus,
                  CASE 
                      WHEN app.totalScore IN [1, 2] THEN 'Very High'
                      WHEN app.totalScore IN [3, 4] THEN 'High'
                      WHEN app.totalScore IN [5, 6] THEN 'Moderate'
                      WHEN app.totalScore IN [7, 8] THEN 'Low'
                      WHEN app.totalScore IN [9, 10] THEN 'Very Low'
                      ELSE 'Unknown'
                  END AS appRiskLevel,
                  COUNT(DISTINCT CASE WHEN AUTH_TYPE.last_access_time < one_month_ago_epoch THEN account END) AS unusedAccounts,
                  apoc.map.fromPairs(scopeSeverities) AS oauthScopesSeverity,
                  one_month_ago_epoch,
                  {
                      credsbased: COUNT(DISTINCT CASE WHEN loginMethod = 'CREDSBASED' THEN account END),
                      oauth: COUNT(DISTINCT CASE WHEN loginMethod = 'OAUTH' THEN account END),
                      saml: COUNT(DISTINCT CASE WHEN loginMethod = 'SAML' THEN account END)
                  } AS loginMethodCount
          }
          
          WITH app, appAdmin, appRiskLevel, categories, lastAccessTime, firstAccessTime, accountsWithFindings,
              status, logo, accounts AS totalAccounts, reviewStatus, 
              one_month_ago_epoch, actionResults, actionOutcomes, unusedAccounts, oauthScopesSeverity, loginMethodCount
          
          WHERE toLower(COALESCE(app.name, app.domain)) CONTAINS toLower('{searchText}')
          {placeholder}
          
          RETURN DISTINCT
              COALESCE(app.id_, app.internalId) AS id, 
              COALESCE(app.name, app.domain, app.id) AS app, 
              appAdmin, 
              appRiskLevel,
              COALESCE(app.criticality, 'Not Set') AS criticality, 
              status, 
              NOT status in ['APPROVED', 'UNAPPROVED'] AND COALESCE(firstAccessTime > one_month_ago_epoch, true) AS newlyDiscovered,
              logo, 
              [cat IN categories WHERE cat.priority = 2 | cat.name] AS highPriorityCategories, 
              totalAccounts, 
              accountsWithFindings, 
              reviewStatus,
              firstAccessTime,
              lastAccessTime,
              actionResults,
              actionOutcomes,
              CASE WHEN app.breachDate > 0 THEN app.breachDate * 1000 ELSE NULL END AS breachDate,
              unusedAccounts,
              oauthScopesSeverity,
              loginMethodCount
          ORDER BY totalAccounts DESC, lastAccessTime DESC"
    allowed_params: true
    input_params:
      behavior: $behavior
      risk_level: AND appRiskLevel = $risk_level
      criticality: AND toLower(COALESCE(hs.criticality, app.criticality)) = toLower($criticality)
      approval_status: AND toLower(status) = toLower($approval_status)
      number_of_accounts_greater_than: AND totalAccounts > $number_of_accounts_greater_than
      number_of_accounts_less_than: AND totalAccounts < $number_of_accounts_less_than
      technical_owner: AND appAdmin = $technical_owner
      newly_discovered: AND NOT status in ['APPROVED', 'UNAPPROVED'] AND COALESCE(firstAccessTime > one_month_ago_epoch, true) = $newly_discovered
      action_status: AND CASE WHEN toLower($action_status) = 'actioned' THEN reviewStatus['actioned'] > 0 ELSE reviewStatus['actioned'] = 0 END
      password_hygiene: AND passwordHygiene[$password_hygiene] > 0
      mfa_status: AND CASE WHEN $mfa_status = 'null' THEN mfaStatus IS NULL ELSE mfaStatus[$mfa_status] > 0 END
    dataSourceType: "knowledgegraph"
    pagination_query: "
          CALL {
              WITH datetime.truncate('day', datetime() - duration('P1M')).epochMillis AS one_month_ago_epoch
          
              MATCH (finding:FINDING {subscriber: $subscriber, tenant: $tenant})<-[:EVALUATED_TO]-(rule:RULE)-[:BELONGS_TO]->(behavior:BEHAVIOR {id: $behavior})
              MATCH (u:USER)-[:HAS_EMAIL]->(email:EMAIL)-[AUTH_TYPE]->(account:ACCOUNT)-[:HAS_FINDING]->(finding)
              MATCH (account)-[:USING_APP]->(app:APPLICATION)-[:HAS_APP_CATEGORY]->(category:APP_CATEGORY)
              OPTIONAL MATCH (account)-[:HAS_CRED_FINGERPRINT]-(cred:CRED_FINGERPRINT)-[]-(same_password_account:ACCOUNT)
          
              OPTIONAL MATCH (app)-[:HAS_ADMIN]->(owner:ACCOUNT)
              OPTIONAL MATCH (finding)-[:TRIGGERED]->(action:ACTION)
              OPTIONAL MATCH (action)-[:RESULTED_IN]->(outcome:OUTCOME)
              OPTIONAL MATCH (app)<-[hs:HAS_APP_SETTINGS]-(t:TENANT {id: $tenant})
              OPTIONAL MATCH (app)-[:HAS_GRANT]->(grant:GRANT)-[:HAS_SCOPE]->(scope:SCOPE)
              
              UNWIND ['High', 'Medium', 'Low'] AS severity
          
              WITH app, owner, account, AUTH_TYPE, replace(type(AUTH_TYPE), '_ACCOUNT', '') AS loginMethod, hs, category, finding, action, severity, COUNT(DISTINCT CASE WHEN scope.severity = severity THEN scope END) as scopeCount,
              COALESCE(action.name, '-') AS actionName, COUNT(DISTINCT action.id) AS actionCount,
              CASE WHEN action IS NOT NULL AND outcome IS NULL THEN 'Not Responded'
                  WHEN outcome IS NOT NULL THEN COALESCE(outcome.value, outcome.message, '-')
              END as outcomeValue,
              COUNT(DISTINCT action.id) as outcomeCount,
              one_month_ago_epoch
          
              WITH app, owner, account, AUTH_TYPE, loginMethod, hs, category, finding, action,
              COLLECT([severity, scopeCount]) AS scopeSeverities,
              actionName, actionCount, apoc.map.fromPairs(COLLECT([outcomeValue, outcomeCount])) as outcomeMap,
              one_month_ago_epoch
          
              RETURN 
                  app, 
                  owner.email AS appAdmin, 
                  COUNT(DISTINCT account) AS accounts, 
                  COLLECT(DISTINCT {name: category.name, priority: category.priority}) AS categories, 
                  MIN(CASE WHEN account.creationTime = '-' THEN NULL ELSE account.creationTime END) AS firstAccessTime,
                  MAX(COALESCE(AUTH_TYPE.last_access_time, 0)) AS lastAccessTime,  
                  COALESCE(hs.approval_status, 'NEEDS REVIEW') AS status, 
                  COALESCE(hs.logoUrl, app.logoUrl) AS logo, 
                  COUNT(DISTINCT CASE WHEN finding IS NOT NULL THEN account.id END) AS accountsWithFindings,
                  apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, actionCount] END)) AS actionResults,
                  apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, outcomeMap] END)) AS actionOutcomes,
                  {actioned: COUNT(DISTINCT CASE WHEN action IS NOT NULL THEN finding.id END),
                      pending: COUNT(DISTINCT CASE WHEN action IS NULL THEN finding.id END)} AS reviewStatus,
                  CASE 
                      WHEN app.totalScore IN [1, 2] THEN 'Very High'
                      WHEN app.totalScore IN [3, 4] THEN 'High'
                      WHEN app.totalScore IN [5, 6] THEN 'Moderate'
                      WHEN app.totalScore IN [7, 8] THEN 'Low'
                      WHEN app.totalScore IN [9, 10] THEN 'Very Low'
                      ELSE 'Unknown'
                  END AS appRiskLevel,
                  COUNT(DISTINCT CASE WHEN AUTH_TYPE.last_access_time < one_month_ago_epoch THEN account END) AS unusedAccounts,
                  apoc.map.fromPairs(scopeSeverities) AS oauthScopesSeverity,
                  one_month_ago_epoch,
                  {
                      credsbased: COUNT(DISTINCT CASE WHEN loginMethod = 'CREDSBASED' THEN account END),
                      oauth: COUNT(DISTINCT CASE WHEN loginMethod = 'OAUTH' THEN account END),
                      saml: COUNT(DISTINCT CASE WHEN loginMethod = 'SAML' THEN account END)
                  } AS loginMethodCount
          }
          
          WITH app, appAdmin, appRiskLevel, categories, lastAccessTime, firstAccessTime, accountsWithFindings,
              status, logo, accounts AS totalAccounts, reviewStatus, 
              one_month_ago_epoch, actionResults, actionOutcomes, unusedAccounts, oauthScopesSeverity, loginMethodCount
          
          WHERE toLower(COALESCE(app.name, app.domain)) CONTAINS toLower('{searchText}') 
          {placeholder}

          RETURN
              COUNT(DISTINCT COALESCE(app.id_, app.internalId)) AS totalCount"
  - id: BID_15
    name: "Unused Account"
    type: widget
    active: true
    defaultValue: null
    queryFilters: []
    className: ""
    query: "CALL {
              WITH datetime.truncate('day', datetime() - duration('P1M')).epochMillis AS one_month_ago_epoch
          
              MATCH (finding:FINDING {subscriber: $subscriber, tenant: $tenant})<-[:EVALUATED_TO]-(rule:RULE)-[:BELONGS_TO]->(behavior:BEHAVIOR {id: $behavior})
              MATCH (u:USER)-[:HAS_EMAIL]->(email:EMAIL)-[AUTH_TYPE]->(account:ACCOUNT)-[:HAS_FINDING]->(finding)
              MATCH (account)-[:USING_APP]->(app:APPLICATION)-[:HAS_APP_CATEGORY]->(category:APP_CATEGORY)
              OPTIONAL MATCH (account)-[:HAS_CRED_FINGERPRINT]-(cred:CRED_FINGERPRINT)-[]-(same_password_account:ACCOUNT)
          
              OPTIONAL MATCH (app)-[:HAS_ADMIN]->(owner:ACCOUNT)
              OPTIONAL MATCH (finding)-[:TRIGGERED]->(action:ACTION)
              OPTIONAL MATCH (action)-[:RESULTED_IN]->(outcome:OUTCOME)
              OPTIONAL MATCH (app)<-[hs:HAS_APP_SETTINGS]-(t:TENANT {id: $tenant})
              OPTIONAL MATCH (app)-[:HAS_GRANT]->(grant:GRANT)-[:HAS_SCOPE]->(scope:SCOPE)
              
              UNWIND ['High', 'Medium', 'Low'] AS severity
          
              WITH app, owner, account, AUTH_TYPE, replace(type(AUTH_TYPE), '_ACCOUNT', '') AS loginMethod, hs, category, finding, action, severity, COUNT(DISTINCT CASE WHEN scope.severity = severity THEN scope END) as scopeCount,
              COALESCE(action.name, '-') AS actionName, COUNT(DISTINCT action.id) AS actionCount,
              CASE WHEN action IS NOT NULL AND outcome IS NULL THEN 'Not Responded'
                  WHEN outcome IS NOT NULL THEN COALESCE(outcome.value, outcome.message, '-')
              END as outcomeValue,
              COUNT(DISTINCT action.id) as outcomeCount,
              one_month_ago_epoch
          
              WITH app, owner, account, AUTH_TYPE, loginMethod, hs, category, finding, action,
              COLLECT([severity, scopeCount]) AS scopeSeverities,
              actionName, actionCount, apoc.map.fromPairs(COLLECT([outcomeValue, outcomeCount])) as outcomeMap,
              one_month_ago_epoch
          
              RETURN 
                  app, 
                  owner.email AS appAdmin, 
                  COUNT(DISTINCT account) AS accounts, 
                  COLLECT(DISTINCT {name: category.name, priority: category.priority}) AS categories, 
                  MIN(CASE WHEN account.creationTime = '-' THEN NULL ELSE account.creationTime END) AS firstAccessTime,
                  MAX(COALESCE(AUTH_TYPE.last_access_time, 0)) AS lastAccessTime,  
                  COALESCE(hs.approval_status, 'NEEDS REVIEW') AS status, 
                  COALESCE(hs.logoUrl, app.logoUrl) AS logo, 
                  COUNT(DISTINCT CASE WHEN finding IS NOT NULL THEN account.id END) AS accountsWithFindings,
                  apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, actionCount] END)) AS actionResults,
                  apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, outcomeMap] END)) AS actionOutcomes,
                  {actioned: COUNT(DISTINCT CASE WHEN action IS NOT NULL THEN finding.id END),
                      pending: COUNT(DISTINCT CASE WHEN action IS NULL THEN finding.id END)} AS reviewStatus,
                  CASE 
                      WHEN app.totalScore IN [1, 2] THEN 'Very High'
                      WHEN app.totalScore IN [3, 4] THEN 'High'
                      WHEN app.totalScore IN [5, 6] THEN 'Moderate'
                      WHEN app.totalScore IN [7, 8] THEN 'Low'
                      WHEN app.totalScore IN [9, 10] THEN 'Very Low'
                      ELSE 'Unknown'
                  END AS appRiskLevel,
                  COUNT(DISTINCT CASE WHEN AUTH_TYPE.last_access_time < one_month_ago_epoch THEN account END) AS unusedAccounts,
                  apoc.map.fromPairs(scopeSeverities) AS oauthScopesSeverity,
                  one_month_ago_epoch,
                  {
                      credsbased: COUNT(DISTINCT CASE WHEN loginMethod = 'CREDSBASED' THEN account END),
                      oauth: COUNT(DISTINCT CASE WHEN loginMethod = 'OAUTH' THEN account END),
                      saml: COUNT(DISTINCT CASE WHEN loginMethod = 'SAML' THEN account END)
                  } AS loginMethodCount
          }
          
          WITH app, appAdmin, appRiskLevel, categories, lastAccessTime, firstAccessTime, accountsWithFindings,
              status, logo, accounts AS totalAccounts, reviewStatus, 
              one_month_ago_epoch, actionResults, actionOutcomes, unusedAccounts, oauthScopesSeverity, loginMethodCount
          
          WHERE toLower(COALESCE(app.name, app.domain)) CONTAINS toLower('{searchText}')
          {placeholder}
          
          RETURN DISTINCT
              COALESCE(app.id_, app.internalId) AS id, 
              COALESCE(app.name, app.domain, app.id) AS app, 
              appAdmin, 
              appRiskLevel,
              COALESCE(app.criticality, 'Not Set') AS criticality, 
              status, 
              NOT status in ['APPROVED', 'UNAPPROVED'] AND COALESCE(firstAccessTime > one_month_ago_epoch, true) AS newlyDiscovered,
              logo, 
              [cat IN categories WHERE cat.priority = 2 | cat.name] AS highPriorityCategories, 
              totalAccounts, 
              accountsWithFindings, 
              reviewStatus,
              firstAccessTime,
              lastAccessTime,
              actionResults,
              actionOutcomes,
              CASE WHEN app.breachDate > 0 THEN app.breachDate * 1000 ELSE NULL END AS breachDate,
              unusedAccounts,
              oauthScopesSeverity,
              loginMethodCount
          ORDER BY totalAccounts DESC, lastAccessTime DESC"
    allowed_params: true
    input_params:
      behavior: $behavior
      risk_level: AND appRiskLevel = $risk_level
      criticality: AND toLower(COALESCE(hs.criticality, app.criticality)) = toLower($criticality)
      approval_status: AND toLower(status) = toLower($approval_status)
      number_of_accounts_greater_than: AND totalAccounts > $number_of_accounts_greater_than
      number_of_accounts_less_than: AND totalAccounts < $number_of_accounts_less_than
      technical_owner: AND appAdmin = $technical_owner
      newly_discovered: AND NOT status in ['APPROVED', 'UNAPPROVED'] AND COALESCE(firstAccessTime > one_month_ago_epoch, true) = $newly_discovered
      action_status: AND CASE WHEN toLower($action_status) = 'actioned' THEN reviewStatus['actioned'] > 0 ELSE reviewStatus['actioned'] = 0 END
      password_hygiene: AND passwordHygiene[$password_hygiene] > 0
      mfa_status: AND CASE WHEN $mfa_status = 'null' THEN mfaStatus IS NULL ELSE mfaStatus[$mfa_status] > 0 END
    dataSourceType: "knowledgegraph"
    pagination_query: "
          CALL {
              WITH datetime.truncate('day', datetime() - duration('P1M')).epochMillis AS one_month_ago_epoch
          
              MATCH (finding:FINDING {subscriber: $subscriber, tenant: $tenant})<-[:EVALUATED_TO]-(rule:RULE)-[:BELONGS_TO]->(behavior:BEHAVIOR {id: $behavior})
              MATCH (u:USER)-[:HAS_EMAIL]->(email:EMAIL)-[AUTH_TYPE]->(account:ACCOUNT)-[:HAS_FINDING]->(finding)
              MATCH (account)-[:USING_APP]->(app:APPLICATION)-[:HAS_APP_CATEGORY]->(category:APP_CATEGORY)
              OPTIONAL MATCH (account)-[:HAS_CRED_FINGERPRINT]-(cred:CRED_FINGERPRINT)-[]-(same_password_account:ACCOUNT)
          
              OPTIONAL MATCH (app)-[:HAS_ADMIN]->(owner:ACCOUNT)
              OPTIONAL MATCH (finding)-[:TRIGGERED]->(action:ACTION)
              OPTIONAL MATCH (action)-[:RESULTED_IN]->(outcome:OUTCOME)
              OPTIONAL MATCH (app)<-[hs:HAS_APP_SETTINGS]-(t:TENANT {id: $tenant})
              OPTIONAL MATCH (app)-[:HAS_GRANT]->(grant:GRANT)-[:HAS_SCOPE]->(scope:SCOPE)
              
              UNWIND ['High', 'Medium', 'Low'] AS severity
          
              WITH app, owner, account, AUTH_TYPE, replace(type(AUTH_TYPE), '_ACCOUNT', '') AS loginMethod, hs, category, finding, action, severity, COUNT(DISTINCT CASE WHEN scope.severity = severity THEN scope END) as scopeCount,
              COALESCE(action.name, '-') AS actionName, COUNT(DISTINCT action.id) AS actionCount,
              CASE WHEN action IS NOT NULL AND outcome IS NULL THEN 'Not Responded'
                  WHEN outcome IS NOT NULL THEN COALESCE(outcome.value, outcome.message, '-')
              END as outcomeValue,
              COUNT(DISTINCT action.id) as outcomeCount,
              one_month_ago_epoch
          
              WITH app, owner, account, AUTH_TYPE, loginMethod, hs, category, finding, action,
              COLLECT([severity, scopeCount]) AS scopeSeverities,
              actionName, actionCount, apoc.map.fromPairs(COLLECT([outcomeValue, outcomeCount])) as outcomeMap,
              one_month_ago_epoch
          
              RETURN 
                  app, 
                  owner.email AS appAdmin, 
                  COUNT(DISTINCT account) AS accounts, 
                  COLLECT(DISTINCT {name: category.name, priority: category.priority}) AS categories, 
                  MIN(CASE WHEN account.creationTime = '-' THEN NULL ELSE account.creationTime END) AS firstAccessTime,
                  MAX(COALESCE(AUTH_TYPE.last_access_time, 0)) AS lastAccessTime,  
                  COALESCE(hs.approval_status, 'NEEDS REVIEW') AS status, 
                  COALESCE(hs.logoUrl, app.logoUrl) AS logo, 
                  COUNT(DISTINCT CASE WHEN finding IS NOT NULL THEN account.id END) AS accountsWithFindings,
                  apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, actionCount] END)) AS actionResults,
                  apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, outcomeMap] END)) AS actionOutcomes,
                  {actioned: COUNT(DISTINCT CASE WHEN action IS NOT NULL THEN finding.id END),
                      pending: COUNT(DISTINCT CASE WHEN action IS NULL THEN finding.id END)} AS reviewStatus,
                  CASE 
                      WHEN app.totalScore IN [1, 2] THEN 'Very High'
                      WHEN app.totalScore IN [3, 4] THEN 'High'
                      WHEN app.totalScore IN [5, 6] THEN 'Moderate'
                      WHEN app.totalScore IN [7, 8] THEN 'Low'
                      WHEN app.totalScore IN [9, 10] THEN 'Very Low'
                      ELSE 'Unknown'
                  END AS appRiskLevel,
                  COUNT(DISTINCT CASE WHEN AUTH_TYPE.last_access_time < one_month_ago_epoch THEN account END) AS unusedAccounts,
                  apoc.map.fromPairs(scopeSeverities) AS oauthScopesSeverity,
                  one_month_ago_epoch,
                  {
                      credsbased: COUNT(DISTINCT CASE WHEN loginMethod = 'CREDSBASED' THEN account END),
                      oauth: COUNT(DISTINCT CASE WHEN loginMethod = 'OAUTH' THEN account END),
                      saml: COUNT(DISTINCT CASE WHEN loginMethod = 'SAML' THEN account END)
                  } AS loginMethodCount
          }
          
          WITH app, appAdmin, appRiskLevel, categories, lastAccessTime, firstAccessTime, accountsWithFindings,
              status, logo, accounts AS totalAccounts, reviewStatus, 
              one_month_ago_epoch, actionResults, actionOutcomes, unusedAccounts, oauthScopesSeverity, loginMethodCount
          
          WHERE toLower(COALESCE(app.name, app.domain)) CONTAINS toLower('{searchText}') 
          {placeholder}

          RETURN
              COUNT(DISTINCT app.id_) AS totalCount"
  - id: BID_16
    name: "Breached app usage"
    type: widget
    active: true
    defaultValue: null
    queryFilters: []
    className: ""
    query: "CALL {
              WITH datetime.truncate('day', datetime() - duration('P1M')).epochMillis AS one_month_ago_epoch
          
              MATCH (finding:FINDING {subscriber: $subscriber, tenant: $tenant})<-[:EVALUATED_TO]-(rule:RULE)-[:BELONGS_TO]->(behavior:BEHAVIOR {id: $behavior})
              MATCH (u:USER)-[:HAS_EMAIL]->(email:EMAIL)-[AUTH_TYPE]->(account:ACCOUNT)-[:HAS_FINDING]->(finding)
              MATCH (account)-[:USING_APP]->(app:APPLICATION)-[:HAS_APP_CATEGORY]->(category:APP_CATEGORY)
              OPTIONAL MATCH (account)-[:HAS_CRED_FINGERPRINT]-(cred:CRED_FINGERPRINT)-[]-(same_password_account:ACCOUNT)
          
              OPTIONAL MATCH (app)-[:HAS_ADMIN]->(owner:ACCOUNT)
              OPTIONAL MATCH (finding)-[:TRIGGERED]->(action:ACTION)
              OPTIONAL MATCH (action)-[:RESULTED_IN]->(outcome:OUTCOME)
              OPTIONAL MATCH (app)<-[hs:HAS_APP_SETTINGS]-(t:TENANT {id: $tenant})
              OPTIONAL MATCH (app)-[:HAS_GRANT]->(grant:GRANT)-[:HAS_SCOPE]->(scope:SCOPE)
              
              UNWIND ['High', 'Medium', 'Low'] AS severity
          
              WITH app, owner, account, AUTH_TYPE, replace(type(AUTH_TYPE), '_ACCOUNT', '') AS loginMethod, hs, category, finding, action, severity, COUNT(DISTINCT CASE WHEN scope.severity = severity THEN scope END) as scopeCount,
              COALESCE(action.name, '-') AS actionName, COUNT(DISTINCT action.id) AS actionCount,
              CASE WHEN action IS NOT NULL AND outcome IS NULL THEN 'Not Responded'
                  WHEN outcome IS NOT NULL THEN COALESCE(outcome.value, outcome.message, '-')
              END as outcomeValue,
              COUNT(DISTINCT action.id) as outcomeCount,
              one_month_ago_epoch
          
              WITH app, owner, account, AUTH_TYPE, loginMethod, hs, category, finding, action,
              COLLECT([severity, scopeCount]) AS scopeSeverities,
              actionName, actionCount, apoc.map.fromPairs(COLLECT([outcomeValue, outcomeCount])) as outcomeMap,
              one_month_ago_epoch
          
              RETURN 
                  app, 
                  owner.email AS appAdmin, 
                  COUNT(DISTINCT account) AS accounts, 
                  COLLECT(DISTINCT {name: category.name, priority: category.priority}) AS categories, 
                  MIN(CASE WHEN account.creationTime = '-' THEN NULL ELSE account.creationTime END) AS firstAccessTime,
                  MAX(COALESCE(AUTH_TYPE.last_access_time, 0)) AS lastAccessTime,  
                  COALESCE(hs.approval_status, 'NEEDS REVIEW') AS status, 
                  COALESCE(hs.logoUrl, app.logoUrl) AS logo, 
                  COUNT(DISTINCT CASE WHEN finding IS NOT NULL THEN account.id END) AS accountsWithFindings,
                  apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, actionCount] END)) AS actionResults,
                  apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, outcomeMap] END)) AS actionOutcomes,
                  {actioned: COUNT(DISTINCT CASE WHEN action IS NOT NULL THEN finding.id END),
                      pending: COUNT(DISTINCT CASE WHEN action IS NULL THEN finding.id END)} AS reviewStatus,
                  CASE 
                      WHEN app.totalScore IN [1, 2] THEN 'Very High'
                      WHEN app.totalScore IN [3, 4] THEN 'High'
                      WHEN app.totalScore IN [5, 6] THEN 'Moderate'
                      WHEN app.totalScore IN [7, 8] THEN 'Low'
                      WHEN app.totalScore IN [9, 10] THEN 'Very Low'
                      ELSE 'Unknown'
                  END AS appRiskLevel,
                  COUNT(DISTINCT CASE WHEN AUTH_TYPE.last_access_time < one_month_ago_epoch THEN account END) AS unusedAccounts,
                  apoc.map.fromPairs(scopeSeverities) AS oauthScopesSeverity,
                  one_month_ago_epoch,
                  {
                      credsbased: COUNT(DISTINCT CASE WHEN loginMethod = 'CREDSBASED' THEN account END),
                      oauth: COUNT(DISTINCT CASE WHEN loginMethod = 'OAUTH' THEN account END),
                      saml: COUNT(DISTINCT CASE WHEN loginMethod = 'SAML' THEN account END)
                  } AS loginMethodCount
          }
          
          WITH app, appAdmin, appRiskLevel, categories, lastAccessTime, firstAccessTime, accountsWithFindings,
              status, logo, accounts AS totalAccounts, reviewStatus, 
              one_month_ago_epoch, actionResults, actionOutcomes, unusedAccounts, oauthScopesSeverity, loginMethodCount
          
          WHERE toLower(COALESCE(app.name, app.domain)) CONTAINS toLower('{searchText}')
          {placeholder}
          
          RETURN DISTINCT
              COALESCE(app.id_, app.internalId) AS id, 
              COALESCE(app.name, app.domain, app.id) AS app, 
              appAdmin, 
              appRiskLevel,
              COALESCE(app.criticality, 'Not Set') AS criticality, 
              status, 
              NOT status in ['APPROVED', 'UNAPPROVED'] AND COALESCE(firstAccessTime > one_month_ago_epoch, true) AS newlyDiscovered,
              logo, 
              [cat IN categories WHERE cat.priority = 2 | cat.name] AS highPriorityCategories, 
              totalAccounts, 
              accountsWithFindings, 
              reviewStatus,
              firstAccessTime,
              lastAccessTime,
              actionResults,
              actionOutcomes,
              CASE WHEN app.breachDate > 0 THEN app.breachDate * 1000 ELSE NULL END AS breachDate,
              unusedAccounts,
              oauthScopesSeverity,
              loginMethodCount
          ORDER BY totalAccounts DESC, lastAccessTime DESC"
    allowed_params: true
    input_params:
      behavior: $behavior
      risk_level: AND appRiskLevel = $risk_level
      criticality: AND toLower(COALESCE(hs.criticality, app.criticality)) = toLower($criticality)
      approval_status: AND toLower(status) = toLower($approval_status)
      number_of_accounts_greater_than: AND totalAccounts > $number_of_accounts_greater_than
      number_of_accounts_less_than: AND totalAccounts < $number_of_accounts_less_than
      technical_owner: AND appAdmin = $technical_owner
      newly_discovered: AND NOT status in ['APPROVED', 'UNAPPROVED'] AND COALESCE(firstAccessTime > one_month_ago_epoch, true) = $newly_discovered
      action_status: AND CASE WHEN toLower($action_status) = 'actioned' THEN reviewStatus['actioned'] > 0 ELSE reviewStatus['actioned'] = 0 END
      password_hygiene: AND passwordHygiene[$password_hygiene] > 0
      mfa_status: AND CASE WHEN $mfa_status = 'null' THEN mfaStatus IS NULL ELSE mfaStatus[$mfa_status] > 0 END
    dataSourceType: "knowledgegraph"
    pagination_query: "
          CALL {
              WITH datetime.truncate('day', datetime() - duration('P1M')).epochMillis AS one_month_ago_epoch
          
              MATCH (finding:FINDING {subscriber: $subscriber, tenant: $tenant})<-[:EVALUATED_TO]-(rule:RULE)-[:BELONGS_TO]->(behavior:BEHAVIOR {id: $behavior})
              MATCH (u:USER)-[:HAS_EMAIL]->(email:EMAIL)-[AUTH_TYPE]->(account:ACCOUNT)-[:HAS_FINDING]->(finding)
              MATCH (account)-[:USING_APP]->(app:APPLICATION)-[:HAS_APP_CATEGORY]->(category:APP_CATEGORY)
              OPTIONAL MATCH (account)-[:HAS_CRED_FINGERPRINT]-(cred:CRED_FINGERPRINT)-[]-(same_password_account:ACCOUNT)
          
              OPTIONAL MATCH (app)-[:HAS_ADMIN]->(owner:ACCOUNT)
              OPTIONAL MATCH (finding)-[:TRIGGERED]->(action:ACTION)
              OPTIONAL MATCH (action)-[:RESULTED_IN]->(outcome:OUTCOME)
              OPTIONAL MATCH (app)<-[hs:HAS_APP_SETTINGS]-(t:TENANT {id: $tenant})
              OPTIONAL MATCH (app)-[:HAS_GRANT]->(grant:GRANT)-[:HAS_SCOPE]->(scope:SCOPE)
              
              UNWIND ['High', 'Medium', 'Low'] AS severity
          
              WITH app, owner, account, AUTH_TYPE, replace(type(AUTH_TYPE), '_ACCOUNT', '') AS loginMethod, hs, category, finding, action, severity, COUNT(DISTINCT CASE WHEN scope.severity = severity THEN scope END) as scopeCount,
              COALESCE(action.name, '-') AS actionName, COUNT(DISTINCT action.id) AS actionCount,
              CASE WHEN action IS NOT NULL AND outcome IS NULL THEN 'Not Responded'
                  WHEN outcome IS NOT NULL THEN COALESCE(outcome.value, outcome.message, '-')
              END as outcomeValue,
              COUNT(DISTINCT action.id) as outcomeCount,
              one_month_ago_epoch
          
              WITH app, owner, account, AUTH_TYPE, loginMethod, hs, category, finding, action,
              COLLECT([severity, scopeCount]) AS scopeSeverities,
              actionName, actionCount, apoc.map.fromPairs(COLLECT([outcomeValue, outcomeCount])) as outcomeMap,
              one_month_ago_epoch
          
              RETURN 
                  app, 
                  owner.email AS appAdmin, 
                  COUNT(DISTINCT account) AS accounts, 
                  COLLECT(DISTINCT {name: category.name, priority: category.priority}) AS categories, 
                  MIN(CASE WHEN account.creationTime = '-' THEN NULL ELSE account.creationTime END) AS firstAccessTime,
                  MAX(COALESCE(AUTH_TYPE.last_access_time, 0)) AS lastAccessTime,  
                  COALESCE(hs.approval_status, 'NEEDS REVIEW') AS status, 
                  COALESCE(hs.logoUrl, app.logoUrl) AS logo, 
                  COUNT(DISTINCT CASE WHEN finding IS NOT NULL THEN account.id END) AS accountsWithFindings,
                  apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, actionCount] END)) AS actionResults,
                  apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, outcomeMap] END)) AS actionOutcomes,
                  {actioned: COUNT(DISTINCT CASE WHEN action IS NOT NULL THEN finding.id END),
                      pending: COUNT(DISTINCT CASE WHEN action IS NULL THEN finding.id END)} AS reviewStatus,
                  CASE 
                      WHEN app.totalScore IN [1, 2] THEN 'Very High'
                      WHEN app.totalScore IN [3, 4] THEN 'High'
                      WHEN app.totalScore IN [5, 6] THEN 'Moderate'
                      WHEN app.totalScore IN [7, 8] THEN 'Low'
                      WHEN app.totalScore IN [9, 10] THEN 'Very Low'
                      ELSE 'Unknown'
                  END AS appRiskLevel,
                  COUNT(DISTINCT CASE WHEN AUTH_TYPE.last_access_time < one_month_ago_epoch THEN account END) AS unusedAccounts,
                  apoc.map.fromPairs(scopeSeverities) AS oauthScopesSeverity,
                  one_month_ago_epoch,
                  {
                      credsbased: COUNT(DISTINCT CASE WHEN loginMethod = 'CREDSBASED' THEN account END),
                      oauth: COUNT(DISTINCT CASE WHEN loginMethod = 'OAUTH' THEN account END),
                      saml: COUNT(DISTINCT CASE WHEN loginMethod = 'SAML' THEN account END)
                  } AS loginMethodCount
          }
          
          WITH app, appAdmin, appRiskLevel, categories, lastAccessTime, firstAccessTime, accountsWithFindings,
              status, logo, accounts AS totalAccounts, reviewStatus, 
              one_month_ago_epoch, actionResults, actionOutcomes, unusedAccounts, oauthScopesSeverity, loginMethodCount
          
          WHERE toLower(COALESCE(app.name, app.domain)) CONTAINS toLower('{searchText}')
          {placeholder}

          RETURN
              COUNT(DISTINCT COALESCE(app.id_, app.internalId)) AS totalCount"
  - id: BID_22
    name: "Blocked SaaS Apps"
    type: widget
    active: true
    defaultValue: null
    queryFilters: []
    className: ""
    query: "CALL {
              WITH datetime.truncate('day', datetime() - duration('P1M')).epochMillis AS one_month_ago_epoch
          
              MATCH (finding:FINDING {subscriber: $subscriber, tenant: $tenant})<-[:EVALUATED_TO]-(rule:RULE)-[:BELONGS_TO]->(behavior:BEHAVIOR {id: $behavior})
              MATCH (u:USER)-[:HAS_EMAIL]->(email:EMAIL)-[AUTH_TYPE]->(account:ACCOUNT)-[:HAS_FINDING]->(finding)
              MATCH (account)-[:USING_APP]->(app:APPLICATION)-[:HAS_APP_CATEGORY]->(category:APP_CATEGORY)
              OPTIONAL MATCH (account)-[:HAS_CRED_FINGERPRINT]-(cred:CRED_FINGERPRINT)-[]-(same_password_account:ACCOUNT)
          
              OPTIONAL MATCH (app)-[:HAS_ADMIN]->(owner:ACCOUNT)
              OPTIONAL MATCH (finding)-[:TRIGGERED]->(action:ACTION)
              OPTIONAL MATCH (action)-[:RESULTED_IN]->(outcome:OUTCOME)
              OPTIONAL MATCH (app)<-[hs:HAS_APP_SETTINGS]-(t:TENANT {id: $tenant})
              OPTIONAL MATCH (app)-[:HAS_GRANT]->(grant:GRANT)-[:HAS_SCOPE]->(scope:SCOPE)
              
              UNWIND ['High', 'Medium', 'Low'] AS severity
          
              WITH app, owner, account, AUTH_TYPE, replace(type(AUTH_TYPE), '_ACCOUNT', '') AS loginMethod, hs, category, finding, action, severity, COUNT(DISTINCT CASE WHEN scope.severity = severity THEN scope END) as scopeCount,
              COALESCE(action.name, '-') AS actionName, COUNT(DISTINCT action.id) AS actionCount,
              CASE WHEN action IS NOT NULL AND outcome IS NULL THEN 'Not Responded'
                  WHEN outcome IS NOT NULL THEN COALESCE(outcome.value, outcome.message, '-')
              END as outcomeValue,
              COUNT(DISTINCT action.id) as outcomeCount,
              one_month_ago_epoch
          
              WITH app, owner, account, AUTH_TYPE, loginMethod, hs, category, finding, action,
              COLLECT([severity, scopeCount]) AS scopeSeverities,
              actionName, actionCount, apoc.map.fromPairs(COLLECT([outcomeValue, outcomeCount])) as outcomeMap,
              one_month_ago_epoch
          
              RETURN 
                  app, 
                  owner.email AS appAdmin, 
                  COUNT(DISTINCT account) AS accounts, 
                  COLLECT(DISTINCT {name: category.name, priority: category.priority}) AS categories, 
                  MIN(CASE WHEN account.creationTime = '-' THEN NULL ELSE account.creationTime END) AS firstAccessTime,
                  MAX(COALESCE(AUTH_TYPE.last_access_time, 0)) AS lastAccessTime,  
                  COALESCE(hs.approval_status, 'NEEDS REVIEW') AS status, 
                  COALESCE(hs.logoUrl, app.logoUrl) AS logo, 
                  COUNT(DISTINCT CASE WHEN finding IS NOT NULL THEN account.id END) AS accountsWithFindings,
                  apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, actionCount] END)) AS actionResults,
                  apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, outcomeMap] END)) AS actionOutcomes,
                  {actioned: COUNT(DISTINCT CASE WHEN action IS NOT NULL THEN finding.id END),
                      pending: COUNT(DISTINCT CASE WHEN action IS NULL THEN finding.id END)} AS reviewStatus,
                  CASE 
                      WHEN app.totalScore IN [1, 2] THEN 'Very High'
                      WHEN app.totalScore IN [3, 4] THEN 'High'
                      WHEN app.totalScore IN [5, 6] THEN 'Moderate'
                      WHEN app.totalScore IN [7, 8] THEN 'Low'
                      WHEN app.totalScore IN [9, 10] THEN 'Very Low'
                      ELSE 'Unknown'
                  END AS appRiskLevel,
                  COUNT(DISTINCT CASE WHEN AUTH_TYPE.last_access_time < one_month_ago_epoch THEN account END) AS unusedAccounts,
                  apoc.map.fromPairs(scopeSeverities) AS oauthScopesSeverity,
                  one_month_ago_epoch,
                  {
                      credsbased: COUNT(DISTINCT CASE WHEN loginMethod = 'CREDSBASED' THEN account END),
                      oauth: COUNT(DISTINCT CASE WHEN loginMethod = 'OAUTH' THEN account END),
                      saml: COUNT(DISTINCT CASE WHEN loginMethod = 'SAML' THEN account END)
                  } AS loginMethodCount
          }
          
          WITH app, appAdmin, appRiskLevel, categories, lastAccessTime, firstAccessTime, accountsWithFindings,
              status, logo, accounts AS totalAccounts, reviewStatus, 
              one_month_ago_epoch, actionResults, actionOutcomes, unusedAccounts, oauthScopesSeverity, loginMethodCount
          
          WHERE toLower(COALESCE(app.name, app.domain)) CONTAINS toLower('{searchText}')
          {placeholder}
          
          RETURN DISTINCT
              COALESCE(app.id_, app.internalId) AS id, 
              COALESCE(app.name, app.domain, app.id) AS app, 
              appAdmin, 
              appRiskLevel,
              COALESCE(app.criticality, 'Not Set') AS criticality, 
              status, 
              NOT status in ['APPROVED', 'UNAPPROVED'] AND COALESCE(firstAccessTime > one_month_ago_epoch, true) AS newlyDiscovered,
              logo, 
              [cat IN categories WHERE cat.priority = 2 | cat.name] AS highPriorityCategories, 
              totalAccounts, 
              accountsWithFindings, 
              reviewStatus,
              firstAccessTime,
              lastAccessTime,
              actionResults,
              actionOutcomes,
              CASE WHEN app.breachDate > 0 THEN app.breachDate * 1000 ELSE NULL END AS breachDate,
              unusedAccounts,
              oauthScopesSeverity,
              loginMethodCount
          ORDER BY totalAccounts DESC, lastAccessTime DESC"
    allowed_params: true
    input_params:
      behavior: $behavior
      risk_level: AND appRiskLevel = $risk_level
      criticality: AND toLower(COALESCE(hs.criticality, app.criticality)) = toLower($criticality)
      approval_status: AND toLower(status) = toLower($approval_status)
      number_of_accounts_greater_than: AND totalAccounts > $number_of_accounts_greater_than
      number_of_accounts_less_than: AND totalAccounts < $number_of_accounts_less_than
      technical_owner: AND appAdmin = $technical_owner
      newly_discovered: AND NOT status in ['APPROVED', 'UNAPPROVED'] AND COALESCE(firstAccessTime > one_month_ago_epoch, true) = $newly_discovered
      action_status: AND CASE WHEN toLower($action_status) = 'actioned' THEN reviewStatus['actioned'] > 0 ELSE reviewStatus['actioned'] = 0 END
      password_hygiene: AND passwordHygiene[$password_hygiene] > 0
      mfa_status: AND CASE WHEN $mfa_status = 'null' THEN mfaStatus IS NULL ELSE mfaStatus[$mfa_status] > 0 END
    dataSourceType: "knowledgegraph"
    pagination_query: "
          CALL {
              WITH datetime.truncate('day', datetime() - duration('P1M')).epochMillis AS one_month_ago_epoch
          
              MATCH (finding:FINDING {subscriber: $subscriber, tenant: $tenant})<-[:EVALUATED_TO]-(rule:RULE)-[:BELONGS_TO]->(behavior:BEHAVIOR {id: $behavior})
              MATCH (u:USER)-[:HAS_EMAIL]->(email:EMAIL)-[AUTH_TYPE]->(account:ACCOUNT)-[:HAS_FINDING]->(finding)
              MATCH (account)-[:USING_APP]->(app:APPLICATION)-[:HAS_APP_CATEGORY]->(category:APP_CATEGORY)
              OPTIONAL MATCH (account)-[:HAS_CRED_FINGERPRINT]-(cred:CRED_FINGERPRINT)-[]-(same_password_account:ACCOUNT)
          
              OPTIONAL MATCH (app)-[:HAS_ADMIN]->(owner:ACCOUNT)
              OPTIONAL MATCH (finding)-[:TRIGGERED]->(action:ACTION)
              OPTIONAL MATCH (action)-[:RESULTED_IN]->(outcome:OUTCOME)
              OPTIONAL MATCH (app)<-[hs:HAS_APP_SETTINGS]-(t:TENANT {id: $tenant})
              OPTIONAL MATCH (app)-[:HAS_GRANT]->(grant:GRANT)-[:HAS_SCOPE]->(scope:SCOPE)
              
              UNWIND ['High', 'Medium', 'Low'] AS severity
          
              WITH app, owner, account, AUTH_TYPE, replace(type(AUTH_TYPE), '_ACCOUNT', '') AS loginMethod, hs, category, finding, action, severity, COUNT(DISTINCT CASE WHEN scope.severity = severity THEN scope END) as scopeCount,
              COALESCE(action.name, '-') AS actionName, COUNT(DISTINCT action.id) AS actionCount,
              CASE WHEN action IS NOT NULL AND outcome IS NULL THEN 'Not Responded'
                  WHEN outcome IS NOT NULL THEN COALESCE(outcome.value, outcome.message, '-')
              END as outcomeValue,
              COUNT(DISTINCT action.id) as outcomeCount,
              one_month_ago_epoch
          
              WITH app, owner, account, AUTH_TYPE, loginMethod, hs, category, finding, action,
              COLLECT([severity, scopeCount]) AS scopeSeverities,
              actionName, actionCount, apoc.map.fromPairs(COLLECT([outcomeValue, outcomeCount])) as outcomeMap,
              one_month_ago_epoch
          
              RETURN 
                  app, 
                  owner.email AS appAdmin, 
                  COUNT(DISTINCT account) AS accounts, 
                  COLLECT(DISTINCT {name: category.name, priority: category.priority}) AS categories, 
                  MIN(CASE WHEN account.creationTime = '-' THEN NULL ELSE account.creationTime END) AS firstAccessTime,
                  MAX(COALESCE(AUTH_TYPE.last_access_time, 0)) AS lastAccessTime,  
                  COALESCE(hs.approval_status, 'NEEDS REVIEW') AS status, 
                  COALESCE(hs.logoUrl, app.logoUrl) AS logo, 
                  COUNT(DISTINCT CASE WHEN finding IS NOT NULL THEN account.id END) AS accountsWithFindings,
                  apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, actionCount] END)) AS actionResults,
                  apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, outcomeMap] END)) AS actionOutcomes,
                  {actioned: COUNT(DISTINCT CASE WHEN action IS NOT NULL THEN finding.id END),
                      pending: COUNT(DISTINCT CASE WHEN action IS NULL THEN finding.id END)} AS reviewStatus,
                  CASE 
                      WHEN app.totalScore IN [1, 2] THEN 'Very High'
                      WHEN app.totalScore IN [3, 4] THEN 'High'
                      WHEN app.totalScore IN [5, 6] THEN 'Moderate'
                      WHEN app.totalScore IN [7, 8] THEN 'Low'
                      WHEN app.totalScore IN [9, 10] THEN 'Very Low'
                      ELSE 'Unknown'
                  END AS appRiskLevel,
                  COUNT(DISTINCT CASE WHEN AUTH_TYPE.last_access_time < one_month_ago_epoch THEN account END) AS unusedAccounts,
                  apoc.map.fromPairs(scopeSeverities) AS oauthScopesSeverity,
                  one_month_ago_epoch,
                  {
                      credsbased: COUNT(DISTINCT CASE WHEN loginMethod = 'CREDSBASED' THEN account END),
                      oauth: COUNT(DISTINCT CASE WHEN loginMethod = 'OAUTH' THEN account END),
                      saml: COUNT(DISTINCT CASE WHEN loginMethod = 'SAML' THEN account END)
                  } AS loginMethodCount
          }
          
          WITH app, appAdmin, appRiskLevel, categories, lastAccessTime, firstAccessTime, accountsWithFindings,
              status, logo, accounts AS totalAccounts, reviewStatus, 
              one_month_ago_epoch, actionResults, actionOutcomes, unusedAccounts, oauthScopesSeverity, loginMethodCount
          
          WHERE toLower(COALESCE(app.name, app.domain)) CONTAINS toLower('{searchText}')
          {placeholder}

          RETURN
              COUNT(DISTINCT COALESCE(app.id_, app.internalId)) AS totalCount"
table_filters:
  - id: risk_level
    name: Risk Level
    defaultValue:
    active: true
    view_by:
        - app
    optional: true
    defaultOptions: 
        - 'Very High'
        - 'High'
        - 'Moderate'
        - 'Low'
        - 'Very Low'
    type: multiselect
    allowed_params: false
    dataSourceType: knowledgegraph
    input_params: null
    query: ""
  - id: criticality
    name: Criticality
    defaultValue:
    active: true
    view_by:
        - app
    optional: true
    defaultOptions:
        "Yes": "critical"
        "No": "not critical"
    type: single
    allowed_params: false
    dataSourceType: knowledgegraph
    input_params: null
    query: ""
  - id: approval_status
    name: Approval Status
    defaultValue:
    active: true
    view_by:
        - app
    optional: false
    defaultOptions:
        - "Approved"
        - "Unapproved"
        - "Needs Review"
        - "Tolerated"
    type: multiselect
    allowed_params: false
    dataSourceType: knowledgegraph
    input_params: null
    query: ""
  - id: number_of_accounts
    name: Number of Account
    defaultValue:
    active: true
    view_by:
        - app
        - account
    optional: false
    defaultOptions: 
        - "greater_than"
        - "less_than"
    type: range
    allowed_params: false
    dataSourceType: knowledgegraph
    input_params: null
    query: ""
  - id: technical_owner
    name: Technical Owner
    defaultValue:
    active: true
    view_by:
        - app
        - account
    optional: true
    defaultOptions:
    type: single
    allowed_params: false
    dataSourceType: knowledgegraph
    input_params:
        search: true
    query: "MATCH (app:APPLICATION)-[:HAS_ADMIN]->(owner:ACCOUNT {subscriber: $subscriber, tenant: $tenant})-[]-(email:EMAIL)-[]-(user:USER)
            RETURN DISTINCT    user.id as id, user.displayName as label, user.mail as value"
  - id: newly_discovered
    name: Newly Discovered
    defaultValue:
    active: true
    view_by:
        - app
    optional: true
    defaultOptions:
        "Yes": true
        "No": false
    type: single
    allowed_params: false
    dataSourceType: knowledgegraph
    input_params: null
    query: ""
  - id: usage_level
    name: Usage Level
    defaultValue:
    active: false
    view_by:
        - app
    optional: true
    defaultOptions: []
    type: multiselect
    allowed_params: false
    dataSourceType: knowledgegraph
    input_params: null
    query: ""
  - id: action_status
    name: Action Status
    defaultValue:
    active: true
    view_by:
      - app
      - account
    optional: false
    defaultOptions:
        - "Actioned"
        - "Pending"
    type: single
    allowed_params: false
    dataSourceType: knowledgegraph
    input_params: null
    query: ""
  - id: department
    name: Department
    defaultValue:
    active: true
    view_by:
      - account
    optional: false
    defaultOptions: []
    type: multiselect
    allowed_params: false
    dataSourceType: knowledgegraph
    input_params: null
    query: "match(d:DEPARTMENT {subscriber: $subscriber, tenant: $tenant}) 
            return DISTINCT d.id AS id, d.name AS value , d.name AS label"
  - id: posture_risk_level
    name: Posture Risk Level
    defaultValue:
    active: true
    view_by:
      - account
    optional: false
    defaultOptions:
        - 'Very High'
        - 'High'
        - 'Moderate'
        - 'Low'
        - 'Very Low'
    type: multiselect
    allowed_params: false
    dataSourceType: knowledgegraph
    input_params: null
    query: ""
  - id: app_category
    name: App Category
    defaultValue:
    active: true
    view_by:
      - account
    optional: true
    defaultOptions: []
    type: multiselect
    allowed_params: false
    dataSourceType: knowledgegraph
    input_params: null
    query: "MATCH (email:EMAIL {subscriber: $subscriber, tenant: $tenant})-[]-(acc:ACCOUNT)-[:USING_APP]-(app:APPLICATION)-[:HAS_APP_CATEGORY]-(cat:APP_CATEGORY)WHERE cat.priority IS NULL OR cat.priority < 2
            RETURN DISTINCT    cat.name as label, 
                               cat.name as value, 
                               cat.name as id"
  - id: appname
    name: Appname
    defaultValue:
    active: true
    view_by:
      - account
    optional: false
    defaultOptions: []
    type: multiselect
    allowed_params: false
    dataSourceType: knowledgegraph
    input_params: null
    query: "MATCH (email:EMAIL {subscriber: $subscriber, tenant: $tenant})-[]-(acc:ACCOUNT)-[:USING_APP]-(app:APPLICATION)-[:HAS_APP_CATEGORY]-(cat:APP_CATEGORY)WHERE cat.priority IS NULL OR cat.priority < 2
            RETURN DISTINCT  app.id_ as id, app.id_ as value, app.name as label"
  - id: group
    name: Group
    defaultValue:
    active: true
    view_by:
      - account
    optional: false
    defaultOptions: []
    type: multiselect
    allowed_params: false
    dataSourceType: knowledgegraph
    input_params: null
    query: "MATCH (g:GROUP {subscriber: $subscriber, tenant: $tenant, userDefined: true}) 
            RETURN DISTINCT 
            g.id AS id, 
            g.displayName as label,
            g.displayName as value"
  - id: login_method
    name: Login Method
    defaultValue:
    active: true
    view_by:
      - "BID_14"
      - "BID_16"
    optional: false
    defaultOptions: []
    type: multiselect
    allowed_params: false
    dataSourceType: knowledgegraph
    input_params: null
    query: ""
  - id: risky_oauth_scopes
    name: Risky Oauth Scopes
    defaultValue:
    active: true
    view_by:
      - "BID_14"
      - "BID_16"
    optional: false
    defaultOptions: 
        "Yes": true
        "No": false
    type: single
    allowed_params: false
    dataSourceType: knowledgegraph
    input_params: null
    query: ""
  - id: granted_by
    name: Granted by
    defaultValue:
    active: true
    view_by:
        - BID_12
    optional: false
    defaultOptions:
       - "Admin"
       - "User"
    type: single
    allowed_params: false
    dataSourceType: knowledgegraph
    input_params: null
    query: ""
  - id: grant_type
    name: Grant Type
    defaultValue:
    active: true
    view_by:
      - BID_12
    optional: false
    defaultOptions:
      - "Delegated"
      - "User"
    type: single
    allowed_params: false
    dataSourceType: knowledgegraph
    input_params: null
    query: ""
  - id: sensitive_data_shared
    name: Sensitive Data Shared
    defaultValue:
    active: true
    view_by:
      - BID_12
    optional: true
    defaultOptions:
       "Yes": true
       "No": false
    type: single
    allowed_params: false
    dataSourceType: knowledgegraph
    input_params: null
    query: ""
  - id: oauth_scope_risk_level
    name: Oauth Scope Risk Level
    defaultValue:
    active: true
    view_by:
      - BID_12
    optional: false
    defaultOptions:
        - 'High'
        - 'Medium'
        - 'Low'
    type: multi
    allowed_params: false
    dataSourceType: knowledgegraph
    input_params: null
    query: ""
widgets:
  - id: saas_risk
    name: "SaaS Risk Trend"
    label: Widget
    template: identity_risk
    enabled: true
    type: multi_linechart
    widget_type: insights_widget
    dataSourceType: datalake
    allowed_params: true
    className: col-span-1
    query_id: ""
    input_params:
      endtime: $endtime
      posture: $posture
    queryFilters:
    query: "select year, monthofyear, dayofmonth, alert_percentile*100 as risk_score, ROUND((alert_percentile*4)+1) as risk_index from kafka_connect.snowdata_schema.postureprofileaggregated where agg_type = 'organization' and agg_subtype = 'posture' and agg_subtype_name = $posture and subscriber = $subscriber and tenant = $tenant order by monthofyear, dayofmonth, agg_type_name, agg_subtype_name"
  - id: saas_metrics
    name: ""
    label: Widget
    template: "detailed_chart"
    enabled: true
    type: detailed
    widget_type: insights_widget
    dataSourceType: datalake
    allowed_params: true
    className: col-span-1
    query_id: ""
    dataLabels:
      - isDetail: true
        label: "Risk Level"
        dataIndex: "Risk_Level"
        percentageIndex: "Risk_Level_chane"
        widget: "risk_level"
      - isDetail: true
        label: "Total Accounts"
        dataIndex: "TOTAL_ACCOUNTS"
        percentageIndex: "TOTAL_ACCOUNTS_CHANGE"
      - isDetail: true
        label: "Total Employees"
        dataIndex: "TOTAL_USERS"
        percentageIndex: "TOTAL_USERS_CHANGE"
      - isDetail: true
        label: "Total Apps"
        dataIndex: "TOTAL_APPS"
        percentageIndex: "TOTAL_APPS_CHANGE"
    input_params:
      endtime: $endtime
    queryFilters:
    query:
      "SELECT * FROM kafka_connect.snowdata_schema.daily_org_analytics WHERE subscriber = $subscriber AND tenant = $tenant ORDER BY timestamp DESC"
  - id: risk_level
    name: ""
    label: Widget
    template: "detailed_chart"
    enabled: true
    type: detailed
    widget_type: insights_widget
    dataSourceType: datalake
    allowed_params: true
    className: col-span-1
    query_id: ""
    dataLabels:
      - isDetail: true
        label: "Risk Level"
        dataIndex: "avg_risk_level"
        percentageIndex: ""
    input_params:
      endtime: $endtime
    queryFilters:
    query: "WITH data AS (
                SELECT 
                    year, monthofyear, dayofmonth, agg_subtype_name, alert_percentile*100 as risk_score, ROUND((alert_percentile*4)+1) as risk_index 
                FROM kafka_connect.snowdata_schema.postureprofileaggregated 
                WHERE agg_type = 'organization' and agg_subtype = 'posture' and agg_subtype_name = 'SaaS Risk' and tenant = $tenant
                ORDER BY year, monthofyear, dayofmonth, agg_subtype_name DESC 
                LIMIT 2
            ),
            risk_level AS (
                SELECT CEIL(AVG(risk_index)) value from data
            )
            SELECT 
                value avg_risk_index,
                CASE WHEN value = 1.0 THEN 'Very Low'
                WHEN value = 2.0 THEN 'Low'
                WHEN value = 3.0 THEN 'Moderate'
                END avg_risk_level
            FROM risk_level"
  - id: approval_status
    name: ""
    label: Widget
    template: "detailed_chart"
    enabled: true
    type: detailed
    widget_type: insights_widget
    dataSourceType: knowledgegraph
    allowed_params: true
    className: col-span-1
    query_id: ""
    dataLabels: []
    input_params:
      endtime: $endtime
    queryFilters:
    query: "MATCH (user:USER {subscriber: $subscriber, tenant: $tenant})-[]-(email:EMAIL)-[auth_type]-(account:ACCOUNT)-[:USING_APP]-(app:APPLICATION)
            WHERE app.name IS NOT NULL
            OPTIONAL MATCH (app)-[has:HAS_APP_SETTINGS]-(tenant:TENANT {id: $tenant})
            WITH 
                app.id_ as appId, 
                toUpper(
                    COALESCE(
                        CASE WHEN has.approval_status <> '-' THEN has.approval_status ELSE NULL END, 
                        CASE WHEN app.approval_status <> '-' THEN app.approval_status ELSE NULL END, 
                        'NEEDS REVIEW'
                    )
                ) as approval_status
            UNWIND ['APPROVED', 'UNAPPROVED', 'TOLERATED', 'NEEDS REVIEW'] as status
            WITH status, COUNT(DISTINCT CASE WHEN approval_status = status THEN appId END) as occurrences
            RETURN
                apoc.map.fromPairs(COLLECT([status, occurrences])) AS approval_status"
  - id: login_methods
    name: ""
    label: Widget
    template: "detailed_chart"
    enabled: true
    type: detailed
    widget_type: insights_widget
    dataSourceType: knowledgegraph
    allowed_params: true
    className: col-span-1
    query_id: ""
    dataLabels: []
    input_params:
      endtime: $endtime
    queryFilters:
    query: "MATCH (user:USER {subscriber: $subscriber, tenant: $tenant})-[]-(email:EMAIL)-[auth_type]-(account:ACCOUNT)
            WITH auth_type, replace(type(auth_type), '_ACCOUNT', '') AS login_method
            UNWIND ['CREDSBASED', 'OAUTH', 'SAML'] as account_type
            WITH account_type, COUNT(DISTINCT CASE WHEN login_method = account_type THEN auth_type END) as occurrences
            RETURN
                apoc.map.fromPairs(COLLECT([account_type, occurrences])) AS login_methods"
  - id: appsGraph
    name: "Ai Usage"
    label: Widget
    template: this_template
    enabled: true
    type: detailed
    dataSourceType: knowledgegraph
    allowed_params: true
    className: col-span-1
    query_id: ""
    input_params:
      endtime: $endtime
    queryFilters:
      - id: 23154174-af03-40c1-ac44-cb8b078c3b0f
        name: Time Filter
        type: multiselect
        options: null
    query: " "
  - id: status
    name: Distribution by status
    label: Widget
    template: status
    enabled: true
    dataSourceType: knowledgegraph
    allowed_params: false
    type: variable_pie_chart
    className: col-span-3
    query_id: ""
    input_params: null
    queryFilters: []
    query: ""
  - id: PiChart
    name: Sensitive Data
    label: Widget
    template: PieChart
    enabled: true
    dataSourceType: knowledgegraph
    allowed_params: true
    type: bar_chart_2
    className: col-span-3
    query_id: ""
    input_params:
      starttime: AND app.timestamp >= $starttime
      endtime: AND app.timestamp <= $endtime
    queryFilters:
      - id: c58d1d61-6422-449f-96fd-b2b740bcd6f3
        name: Time Filter
        type: multiselect
        options: null
    # TODO : add a.resolverType IS NOT NULL in this query later.
    query: ""
  - id: BID_12
    name: "High Risk Oauth Scopes"
    label: "Widget"
    template: ""
    widget_type: behavior_widget
    type: behavior_widget
    query_id: ""
    enabled: true
    queryFilters: []
    className: ""
    query: "MATCH (user:USER {subscriber: $subscriber, tenant: $tenant})-[]-(email:EMAIL)-[]-(acc:ACCOUNT)-[]-(finding:FINDING)-[]
            -(rule:RULE)-[]-(behavior:BEHAVIOR {id: $behavior})
            MATCH (acc)-[:USING_APP]->(app:APPLICATION)
            WHERE app.name IS NOT NULL
            OPTIONAL MATCH (finding)-[]-(action:ACTION)
            WITH app, CASE WHEN COUNT(action) > 0 THEN true ELSE false END as hasAction
            RETURN
                COUNT(DISTINCT app.id_) AS total,
                COUNT(DISTINCT CASE WHEN hasAction = true THEN app.id_ END) AS actioned,
                COUNT(DISTINCT CASE WHEN hasAction = false THEN app.id_ END) AS pending"
    allowed_params: true
    input_params:
      behavior: $behavior
    dataSourceType: "knowledgegraph"
  - id: BID_13
    name: "Terminated User with Enabled Accounts"
    label: "Widget"
    template: ""
    widget_type: behavior_widget
    type: behavior_widget
    query_id: ""
    enabled: true
    queryFilters: []
    className: ""
    query: "MATCH (user:USER {subscriber: $subscriber, tenant: $tenant})-[]-(email:EMAIL)-[]-(acc:ACCOUNT)-[]-(finding:FINDING)-[]
            -(rule:RULE)-[]-(behavior:BEHAVIOR {id: $behavior})
            MATCH (acc)-[:USING_APP]->(app:APPLICATION)
            WHERE app.name IS NOT NULL
            OPTIONAL MATCH (finding)-[]-(action:ACTION)
            WITH acc, CASE WHEN COUNT(action) > 0 THEN true ELSE false END as hasAction
            RETURN
                COUNT(DISTINCT acc.id) AS total,
                COUNT(DISTINCT CASE WHEN hasAction = true THEN acc.id END) AS actioned,
                COUNT(DISTINCT CASE WHEN hasAction = false THEN acc.id END) AS pending"
    allowed_params: true
    input_params:
      behavior: $behavior
    dataSourceType: "knowledgegraph"
  - id: BID_14
    name: "Unapproved SaaS Apps"
    label: "Widget"
    template: ""
    widget_type: behavior_widget
    type: behavior_widget
    query_id: ""
    enabled: true
    queryFilters: []
    className: ""
    query: "MATCH (user:USER {subscriber: $subscriber, tenant: $tenant})-[]-(email:EMAIL)-[]-(acc:ACCOUNT)-[]-(finding:FINDING)-[]
            -(rule:RULE)-[]-(behavior:BEHAVIOR {id: $behavior})
            MATCH (acc)-[:USING_APP]->(app:APPLICATION)
            WHERE app.name IS NOT NULL
            OPTIONAL MATCH (finding)-[]-(action:ACTION)
            WITH app, CASE WHEN COUNT(action) > 0 THEN true ELSE false END as hasAction
            RETURN
                COUNT(DISTINCT app.id_) AS total,
                COUNT(DISTINCT CASE WHEN hasAction = true THEN app.id_ END) AS actioned,
                COUNT(DISTINCT CASE WHEN hasAction = false THEN app.id_ END) AS pending"
    allowed_params: true
    input_params:
      behavior: $behavior
    dataSourceType: "knowledgegraph"
  - id: BID_15
    name: "Unused Accounts"
    label: "Widget"
    template: ""
    widget_type: behavior_widget
    type: behavior_widget
    query_id: ""
    enabled: true
    queryFilters: []
    className: ""
    query: "MATCH (user:USER {subscriber: $subscriber, tenant: $tenant})-[]-(email:EMAIL)-[]-(acc:ACCOUNT)-[]-(finding:FINDING)-[]
            -(rule:RULE)-[]-(behavior:BEHAVIOR {id: $behavior})
            MATCH (acc)-[:USING_APP]->(app:APPLICATION)
            WHERE app.name IS NOT NULL
            OPTIONAL MATCH (finding)-[]-(action:ACTION)
            WITH app, CASE WHEN COUNT(action) > 0 THEN true ELSE false END as hasAction
            RETURN
                COUNT(DISTINCT app.id_) AS total,
                COUNT(DISTINCT CASE WHEN hasAction = true THEN app.id_ END) AS actioned,
                COUNT(DISTINCT CASE WHEN hasAction = false THEN app.id_ END) AS pending"
    allowed_params: true
    input_params:
      behavior: $behavior
    dataSourceType: "knowledgegraph"
  - id: BID_16
    name: "Breached Apps Usage"
    label: "Widget"
    template: ""
    widget_type: behavior_widget
    type: behavior_widget
    query_id: ""
    enabled: true
    queryFilters: []
    className: ""
    query: "MATCH (user:USER {subscriber: $subscriber, tenant: $tenant})-[]-(email:EMAIL)-[]-(acc:ACCOUNT)-[]-(finding:FINDING)-[]
            -(rule:RULE)-[]-(behavior:BEHAVIOR {id: $behavior})
            MATCH (acc)-[:USING_APP]->(app:APPLICATION)
            WHERE app.name IS NOT NULL
            OPTIONAL MATCH (finding)-[]-(action:ACTION)
            WITH app, CASE WHEN COUNT(action) > 0 THEN true ELSE false END as hasAction
            RETURN
                COUNT(DISTINCT app.id_) AS total,
                COUNT(DISTINCT CASE WHEN hasAction = true THEN app.id_ END) AS actioned,
                COUNT(DISTINCT CASE WHEN hasAction = false THEN app.id_ END) AS pending"
    allowed_params: true
    input_params:
      behavior: $behavior
    dataSourceType: "knowledgegraph"
  - id: BID_22
    name: "Blocked SaaS Apps"
    label: "Widget"
    template: ""
    widget_type: behavior_widget
    type: behavior_widget
    query_id: ""
    enabled: true
    queryFilters: []
    className: ""
    query: "MATCH (user:USER {subscriber: $subscriber, tenant: $tenant})-[]-(email:EMAIL)-[]-(acc:ACCOUNT)-[]-(finding:FINDING)-[]
            -(rule:RULE)-[]-(behavior:BEHAVIOR {id: $behavior})
            MATCH (acc)-[:USING_APP]->(app:APPLICATION)
            WHERE app.name IS NOT NULL
            OPTIONAL MATCH (finding)-[]-(action:ACTION)
            WITH app, CASE WHEN COUNT(action) > 0 THEN true ELSE false END as hasAction
            RETURN
                COUNT(DISTINCT app.id_) AS total,
                COUNT(DISTINCT CASE WHEN hasAction = true THEN app.id_ END) AS actioned,
                COUNT(DISTINCT CASE WHEN hasAction = false THEN app.id_ END) AS pending"
    allowed_params: true
    input_params:
      behavior: $behavior
    dataSourceType: "knowledgegraph"
  - id: apps_detailed_BID_12
    name: "High Risk Oauth Scope Detailed"
    label: Widget
    template: this_template
    enabled: true
    type: drilldown_widget
    widget_type: drilldown_widget
    dataSourceType: knowledgegraph
    allowed_params: true
    className: col-span-1
    query_id: ""
    input_params:
      endtime: $endtime
      appId: $appId
      behavior: $behavior
    queryFilters: []
    query: "MATCH (app:APPLICATION {id_: $appId})
            MATCH (app)-[:USING_APP]-(account:ACCOUNT)-[]-(finding:FINDING)-[]-(rule:RULE)-[]-(behavior:BEHAVIOR {id: $behavior})
            MATCH (user:USER {subscriber: $subscriber, tenant: $tenant})-[]-(email:EMAIL)-[auth_type]-(account)
            
            OPTIONAL MATCH (app)-[]-(grant:GRANT)-[]-(scope:SCOPE)
            WHERE toLower(scope.severity) IN ['high', 'medium', 'low']
            OPTIONAL MATCH (app)-[has:HAS_APP_SETTINGS]-(tenant:TENANT {id: $tenant})
            OPTIONAL MATCH (finding)-[:TRIGGERED]-(action:ACTION)
            OPTIONAL MATCH (action)-[:RESULTED_IN]-(outcome:OUTCOME)
            OPTIONAL MATCH (finding)-[:HAS_ARTIFACT]->(dlp:DLP_FINAL_CLASS | DLP_ORIGINAL_CLASS)
            
            OPTIONAL MATCH (category)<-[:HAS_APP_CATEGORY]-(alternative_app:APPLICATION)-[has1:HAS_APP_SETTINGS]-(:TENANT {id: $tenant})
            WHERE COALESCE(has1.approval_status, alternative_app.approval_status, 'NOT SET') = 'APPROVED'
            
            WITH app, auth_type, account, COLLECT(DISTINCT scope.severity) as severities, has, finding, action, outcome, dlp, alternative_app
            
            WITH app, auth_type, account, severities, has, finding, action, dlp, alternative_app,
                COALESCE(action.name, '-') AS actionName,
                COUNT(DISTINCT action) AS actionCount,
                CASE WHEN action IS NOT NULL AND outcome IS NULL THEN 'Not Responded'
                    WHEN outcome IS NOT NULL THEN COALESCE(outcome.value, outcome.message, '-')
                END as outcomeValue
            WHERE actionName IS NOT NULL
            
            WITH app, auth_type, account, severities, has, finding, action, dlp, alternative_app, actionName, actionCount,
                outcomeValue, COUNT(outcomeValue) AS outcomeCount
            
            WITH app, auth_type, account, severities, has, finding, action, dlp, alternative_app, actionName, actionCount,
                apoc.map.fromPairs(COLLECT([outcomeValue, outcomeCount])) as outcomeMap
            
            WITH app, severities, has, alternative_app,
                COUNT(DISTINCT finding.id) as totalFindings,
                COUNT(DISTINCT CASE WHEN action IS NOT NULL THEN account.id END) as actionedCount,
                COUNT(DISTINCT CASE WHEN action IS NULL THEN account.id END) as pendingCount,
                MIN(COALESCE(
                    CASE WHEN account.creationTime <> '-' THEN account.creationTime ELSE NULL END, timestamp()
                )) AS firstAccessed,
                MAX(auth_type.last_access_time) AS lastAccessed,
                COLLECT(DISTINCT dlp.id) AS sensitiveDataClasses,
                apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, actionCount] END)) AS combinedActionTracker,
                apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, outcomeMap] END)) AS combinedActionOutcomes
            
            RETURN DISTINCT
                COALESCE(app.id_, app.internalId) AS id,
                COALESCE(app.name, app.domain, app.id) AS app,
                app.logoUrl AS appLogoUrl,
                app.description AS description,
                firstAccessed,
                lastAccessed,
                COALESCE(has.approval_status, 'Not Defined') AS approvalStatus,
                COALESCE(has.criticality, 'Not Defined') AS criticality,
                app.domain AS domain,
                CASE
                    WHEN app.complianceScore <= 2 THEN 'Very High'
                    WHEN app.complianceScore <= 4 THEN 'High'
                    WHEN app.complianceScore <= 6 THEN 'Moderate'
                    WHEN app.complianceScore <= 8 THEN 'Low'
                    WHEN app.complianceScore <= 10 THEN 'Very Low'
                    ELSE ''
                END AS complianceRisk,
                apoc.map.fromPairs([key IN keys(app) WHERE key STARTS WITH 'Compliance' | [replace(key, 'Compliance', ''), app[key] = true]]) AS complianceList,
                CASE
                    WHEN app.securityScore <= 2 THEN 'Very High'
                    WHEN app.securityScore <= 4 THEN 'High'
                    WHEN app.securityScore <= 6 THEN 'Moderate'
                    WHEN app.securityScore <= 8 THEN 'Low'
                    WHEN app.securityScore <= 10 THEN 'Very Low'
                    ELSE ''
                END AS securityRisk,
                apoc.map.fromPairs([key IN keys(app) WHERE key STARTS WITH 'Security' | [replace(key, 'Security', ''), app[key] = true]]) AS securitySupportedList,
                app.SecuritySupportsSAML = true AS isSamlSupported,
                app.isMfaSupported = true AS isMfaSupported,
                CASE
                    WHEN 'High' IN severities THEN 'High'
                    WHEN 'Medium' IN severities THEN 'Medium'
                    ELSE 'Low'
                END AS severityRisk,
                apoc.map.fromPairs([
                    ['High', SIZE([x IN severities WHERE toLower(x) = 'high'])],
                    ['Medium', SIZE([x IN severities WHERE toLower(x) = 'medium'])],
                    ['Low', SIZE([x IN severities WHERE toLower(x) = 'low'])]
                ]) AS oauthSeverity,
                apoc.map.fromPairs([
                    ['breachDate', app.breachDate * 1000],
                    ['breachDataClasses', app.breachDataClasses]
                ]) AS breachData,
                sensitiveDataClasses,
                COLLECT(DISTINCT alternative_app.name) AS alternativeApps,
                totalFindings,
                actionedCount,
                pendingCount,
                combinedActionTracker AS actionTracker,
                combinedActionOutcomes AS actionOutcomes"
  - id: apps_detailed_BID_13
    name: "Terminated User with enabled account Detailed"
    label: Widget
    template: this_template
    enabled: true
    type: drilldown_widget
    widget_type: drilldown_widget
    dataSourceType: knowledgegraph
    allowed_params: true
    className: col-span-1
    query_id: ""
    input_params:
      endtime: $endtime
      appId: $appId
      behavior: $behavior
    queryFilters: []
    query: "MATCH (app:APPLICATION {id_: $appId})
            MATCH (app)-[:USING_APP]-(account:ACCOUNT)-[]-(finding:FINDING)-[]-(rule:RULE)-[]-(behavior:BEHAVIOR {id: $behavior})
            MATCH (user:USER {subscriber: $subscriber, tenant: $tenant})-[]-(email:EMAIL)-[auth_type]-(account)
            
            OPTIONAL MATCH (app)-[]-(grant:GRANT)-[]-(scope:SCOPE)
            WHERE toLower(scope.severity) IN ['high', 'medium', 'low']
            OPTIONAL MATCH (app)-[has:HAS_APP_SETTINGS]-(tenant:TENANT {id: $tenant})
            OPTIONAL MATCH (finding)-[:TRIGGERED]-(action:ACTION)
            OPTIONAL MATCH (action)-[:RESULTED_IN]-(outcome:OUTCOME)
            OPTIONAL MATCH (finding)-[:HAS_ARTIFACT]->(dlp:DLP_FINAL_CLASS | DLP_ORIGINAL_CLASS)
            
            OPTIONAL MATCH (category)<-[:HAS_APP_CATEGORY]-(alternative_app:APPLICATION)-[has1:HAS_APP_SETTINGS]-(:TENANT {id: $tenant})
            WHERE COALESCE(has1.approval_status, alternative_app.approval_status, 'NOT SET') = 'APPROVED'
            
            WITH app, auth_type, account, COLLECT(DISTINCT scope.severity) as severities, has, finding, action, outcome, dlp, alternative_app
            
            WITH app, auth_type, account, severities, has, finding, action, dlp, alternative_app,
                COALESCE(action.name, '-') AS actionName,
                COUNT(DISTINCT action) AS actionCount,
                CASE WHEN action IS NOT NULL AND outcome IS NULL THEN 'Not Responded'
                    WHEN outcome IS NOT NULL THEN COALESCE(outcome.value, outcome.message, '-')
                END as outcomeValue
            WHERE actionName IS NOT NULL
            
            WITH app, auth_type, account, severities, has, finding, action, dlp, alternative_app, actionName, actionCount,
                outcomeValue, COUNT(outcomeValue) AS outcomeCount
            
            WITH app, auth_type, account, severities, has, finding, action, dlp, alternative_app, actionName, actionCount,
                apoc.map.fromPairs(COLLECT([outcomeValue, outcomeCount])) as outcomeMap
            
            WITH app, severities, has, alternative_app,
                COUNT(DISTINCT finding.id) as totalFindings,
                COUNT(DISTINCT CASE WHEN action IS NOT NULL THEN account.id END) as actionedCount,
                COUNT(DISTINCT CASE WHEN action IS NULL THEN account.id END) as pendingCount,
                MIN(COALESCE(
                    CASE WHEN account.creationTime <> '-' THEN account.creationTime ELSE NULL END, timestamp()
                )) AS firstAccessed,
                MAX(auth_type.last_access_time) AS lastAccessed,
                COLLECT(DISTINCT dlp.id) AS sensitiveDataClasses,
                apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, actionCount] END)) AS combinedActionTracker,
                apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, outcomeMap] END)) AS combinedActionOutcomes
            
            RETURN DISTINCT
                COALESCE(app.id_, app.internalId) AS id,
                COALESCE(app.name, app.domain, app.id) AS app,
                app.logoUrl AS appLogoUrl,
                app.description AS description,
                firstAccessed,
                lastAccessed,
                COALESCE(has.approval_status, 'Not Defined') AS approvalStatus,
                COALESCE(has.criticality, 'Not Defined') AS criticality,
                app.domain AS domain,
                CASE
                    WHEN app.complianceScore <= 2 THEN 'Very High'
                    WHEN app.complianceScore <= 4 THEN 'High'
                    WHEN app.complianceScore <= 6 THEN 'Moderate'
                    WHEN app.complianceScore <= 8 THEN 'Low'
                    WHEN app.complianceScore <= 10 THEN 'Very Low'
                    ELSE ''
                END AS complianceRisk,
                apoc.map.fromPairs([key IN keys(app) WHERE key STARTS WITH 'Compliance' | [replace(key, 'Compliance', ''), app[key] = true]]) AS complianceList,
                CASE
                    WHEN app.securityScore <= 2 THEN 'Very High'
                    WHEN app.securityScore <= 4 THEN 'High'
                    WHEN app.securityScore <= 6 THEN 'Moderate'
                    WHEN app.securityScore <= 8 THEN 'Low'
                    WHEN app.securityScore <= 10 THEN 'Very Low'
                    ELSE ''
                END AS securityRisk,
                apoc.map.fromPairs([key IN keys(app) WHERE key STARTS WITH 'Security' | [replace(key, 'Security', ''), app[key] = true]]) AS securitySupportedList,
                app.SecuritySupportsSAML = true AS isSamlSupported,
                app.isMfaSupported = true AS isMfaSupported,
                CASE
                    WHEN 'High' IN severities THEN 'High'
                    WHEN 'Medium' IN severities THEN 'Medium'
                    ELSE 'Low'
                END AS severityRisk,
                apoc.map.fromPairs([
                    ['High', SIZE([x IN severities WHERE toLower(x) = 'high'])],
                    ['Medium', SIZE([x IN severities WHERE toLower(x) = 'medium'])],
                    ['Low', SIZE([x IN severities WHERE toLower(x) = 'low'])]
                ]) AS oauthSeverity,
                apoc.map.fromPairs([
                    ['breachDate', app.breachDate * 1000],
                    ['breachDataClasses', app.breachDataClasses]
                ]) AS breachData,
                sensitiveDataClasses,
                COLLECT(DISTINCT alternative_app.name) AS alternativeApps,
                totalFindings,
                actionedCount,
                pendingCount,
                combinedActionTracker AS actionTracker,
                combinedActionOutcomes AS actionOutcomes"
  - id: apps_detailed_BID_14
    name: "Unapproved SaaS app Detailed"
    label: Widget
    template: this_template
    enabled: true
    type: drilldown_widget
    widget_type: drilldown_widget
    dataSourceType: knowledgegraph
    allowed_params: true
    className: col-span-1
    query_id: ""
    input_params:
      endtime: $endtime
      appId: $appId
      behavior: $behavior
    queryFilters: []
    query: "MATCH (app:APPLICATION {id_: $appId})
            MATCH (app)-[:USING_APP]-(account:ACCOUNT)-[]-(finding:FINDING)-[]-(rule:RULE)-[]-(behavior:BEHAVIOR {id: $behavior})
            MATCH (user:USER {subscriber: $subscriber, tenant: $tenant})-[]-(email:EMAIL)-[auth_type]-(account)
            
            OPTIONAL MATCH (app)-[]-(grant:GRANT)-[]-(scope:SCOPE)
            WHERE toLower(scope.severity) IN ['high', 'medium', 'low']
            OPTIONAL MATCH (app)-[has:HAS_APP_SETTINGS]-(tenant:TENANT {id: $tenant})
            OPTIONAL MATCH (finding)-[:TRIGGERED]-(action:ACTION)
            OPTIONAL MATCH (action)-[:RESULTED_IN]-(outcome:OUTCOME)
            OPTIONAL MATCH (finding)-[:HAS_ARTIFACT]->(dlp:DLP_FINAL_CLASS | DLP_ORIGINAL_CLASS)
            
            OPTIONAL MATCH (category)<-[:HAS_APP_CATEGORY]-(alternative_app:APPLICATION)-[has1:HAS_APP_SETTINGS]-(:TENANT {id: $tenant})
            WHERE COALESCE(has1.approval_status, alternative_app.approval_status, 'NOT SET') = 'APPROVED'
            
            WITH app, auth_type, account, COLLECT(DISTINCT scope.severity) as severities, has, finding, action, outcome, dlp, alternative_app
            
            WITH app, auth_type, account, severities, has, finding, action, dlp, alternative_app,
                COALESCE(action.name, '-') AS actionName,
                COUNT(DISTINCT action) AS actionCount,
                CASE WHEN action IS NOT NULL AND outcome IS NULL THEN 'Not Responded'
                    WHEN outcome IS NOT NULL THEN COALESCE(outcome.value, outcome.message, '-')
                END as outcomeValue
            WHERE actionName IS NOT NULL
            
            WITH app, auth_type, account, severities, has, finding, action, dlp, alternative_app, actionName, actionCount,
                outcomeValue, COUNT(outcomeValue) AS outcomeCount
            
            WITH app, auth_type, account, severities, has, finding, action, dlp, alternative_app, actionName, actionCount,
                apoc.map.fromPairs(COLLECT([outcomeValue, outcomeCount])) as outcomeMap
            
            WITH app, severities, has, alternative_app,
                COUNT(DISTINCT finding.id) as totalFindings,
                COUNT(DISTINCT CASE WHEN action IS NOT NULL THEN account.id END) as actionedCount,
                COUNT(DISTINCT CASE WHEN action IS NULL THEN account.id END) as pendingCount,
                MIN(COALESCE(
                    CASE WHEN account.creationTime <> '-' THEN account.creationTime ELSE NULL END, timestamp()
                )) AS firstAccessed,
                MAX(auth_type.last_access_time) AS lastAccessed,
                COLLECT(DISTINCT dlp.id) AS sensitiveDataClasses,
                apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, actionCount] END)) AS combinedActionTracker,
                apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, outcomeMap] END)) AS combinedActionOutcomes
            
            RETURN DISTINCT
                COALESCE(app.id_, app.internalId) AS id,
                COALESCE(app.name, app.domain, app.id) AS app,
                app.logoUrl AS appLogoUrl,
                app.description AS description,
                firstAccessed,
                lastAccessed,
                COALESCE(has.approval_status, 'Not Defined') AS approvalStatus,
                COALESCE(has.criticality, 'Not Defined') AS criticality,
                app.domain AS domain,
                CASE
                    WHEN app.complianceScore <= 2 THEN 'Very High'
                    WHEN app.complianceScore <= 4 THEN 'High'
                    WHEN app.complianceScore <= 6 THEN 'Moderate'
                    WHEN app.complianceScore <= 8 THEN 'Low'
                    WHEN app.complianceScore <= 10 THEN 'Very Low'
                    ELSE ''
                END AS complianceRisk,
                apoc.map.fromPairs([key IN keys(app) WHERE key STARTS WITH 'Compliance' | [replace(key, 'Compliance', ''), app[key] = true]]) AS complianceList,
                CASE
                    WHEN app.securityScore <= 2 THEN 'Very High'
                    WHEN app.securityScore <= 4 THEN 'High'
                    WHEN app.securityScore <= 6 THEN 'Moderate'
                    WHEN app.securityScore <= 8 THEN 'Low'
                    WHEN app.securityScore <= 10 THEN 'Very Low'
                    ELSE ''
                END AS securityRisk,
                apoc.map.fromPairs([key IN keys(app) WHERE key STARTS WITH 'Security' | [replace(key, 'Security', ''), app[key] = true]]) AS securitySupportedList,
                app.SecuritySupportsSAML = true AS isSamlSupported,
                app.isMfaSupported = true AS isMfaSupported,
                CASE
                    WHEN 'High' IN severities THEN 'High'
                    WHEN 'Medium' IN severities THEN 'Medium'
                    ELSE 'Low'
                END AS severityRisk,
                apoc.map.fromPairs([
                    ['High', SIZE([x IN severities WHERE toLower(x) = 'high'])],
                    ['Medium', SIZE([x IN severities WHERE toLower(x) = 'medium'])],
                    ['Low', SIZE([x IN severities WHERE toLower(x) = 'low'])]
                ]) AS oauthSeverity,
                apoc.map.fromPairs([
                    ['breachDate', app.breachDate * 1000],
                    ['breachDataClasses', app.breachDataClasses]
                ]) AS breachData,
                sensitiveDataClasses,
                COLLECT(DISTINCT alternative_app.name) AS alternativeApps,
                totalFindings,
                actionedCount,
                pendingCount,
                combinedActionTracker AS actionTracker,
                combinedActionOutcomes AS actionOutcomes"
  - id: apps_detailed_BID_15
    name: "Unused Account Detailed"
    label: Widget
    template: this_template
    enabled: true
    type: drilldown_widget
    widget_type: drilldown_widget
    dataSourceType: knowledgegraph
    allowed_params: true
    className: col-span-1
    query_id: ""
    input_params:
      endtime: $endtime
      appId: $appId
      behavior: $behavior
    queryFilters: []
    query: "MATCH (app:APPLICATION {id_: $appId})
            MATCH (app)-[:USING_APP]-(account:ACCOUNT)-[]-(finding:FINDING)-[]-(rule:RULE)-[]-(behavior:BEHAVIOR {id: $behavior})
            MATCH (user:USER {subscriber: $subscriber, tenant: $tenant})-[]-(email:EMAIL)-[auth_type]-(account)
            
            OPTIONAL MATCH (app)-[]-(grant:GRANT)-[]-(scope:SCOPE)
            WHERE toLower(scope.severity) IN ['high', 'medium', 'low']
            OPTIONAL MATCH (app)-[has:HAS_APP_SETTINGS]-(tenant:TENANT {id: $tenant})
            OPTIONAL MATCH (finding)-[:TRIGGERED]-(action:ACTION)
            OPTIONAL MATCH (action)-[:RESULTED_IN]-(outcome:OUTCOME)
            OPTIONAL MATCH (finding)-[:HAS_ARTIFACT]->(dlp:DLP_FINAL_CLASS | DLP_ORIGINAL_CLASS)
            
            OPTIONAL MATCH (category)<-[:HAS_APP_CATEGORY]-(alternative_app:APPLICATION)-[has1:HAS_APP_SETTINGS]-(:TENANT {id: $tenant})
            WHERE COALESCE(has1.approval_status, alternative_app.approval_status, 'NOT SET') = 'APPROVED'
            
            WITH app, auth_type, account, COLLECT(DISTINCT scope.severity) as severities, has, finding, action, outcome, dlp, alternative_app
            
            WITH app, auth_type, account, severities, has, finding, action, dlp, alternative_app,
                COALESCE(action.name, '-') AS actionName,
                COUNT(DISTINCT action) AS actionCount,
                CASE WHEN action IS NOT NULL AND outcome IS NULL THEN 'Not Responded'
                    WHEN outcome IS NOT NULL THEN COALESCE(outcome.value, outcome.message, '-')
                END as outcomeValue
            WHERE actionName IS NOT NULL
            
            WITH app, auth_type, account, severities, has, finding, action, dlp, alternative_app, actionName, actionCount,
                outcomeValue, COUNT(outcomeValue) AS outcomeCount
            
            WITH app, auth_type, account, severities, has, finding, action, dlp, alternative_app, actionName, actionCount,
                apoc.map.fromPairs(COLLECT([outcomeValue, outcomeCount])) as outcomeMap
            
            WITH app, severities, has, alternative_app,
                COUNT(DISTINCT finding.id) as totalFindings,
                COUNT(DISTINCT CASE WHEN action IS NOT NULL THEN account.id END) as actionedCount,
                COUNT(DISTINCT CASE WHEN action IS NULL THEN account.id END) as pendingCount,
                MIN(COALESCE(
                    CASE WHEN account.creationTime <> '-' THEN account.creationTime ELSE NULL END, timestamp()
                )) AS firstAccessed,
                MAX(auth_type.last_access_time) AS lastAccessed,
                COLLECT(DISTINCT dlp.id) AS sensitiveDataClasses,
                apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, actionCount] END)) AS combinedActionTracker,
                apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, outcomeMap] END)) AS combinedActionOutcomes
            
            RETURN DISTINCT
                COALESCE(app.id_, app.internalId) AS id,
                COALESCE(app.name, app.domain, app.id) AS app,
                app.logoUrl AS appLogoUrl,
                app.description AS description,
                firstAccessed,
                lastAccessed,
                COALESCE(has.approval_status, 'Not Defined') AS approvalStatus,
                COALESCE(has.criticality, 'Not Defined') AS criticality,
                app.domain AS domain,
                CASE
                    WHEN app.complianceScore <= 2 THEN 'Very High'
                    WHEN app.complianceScore <= 4 THEN 'High'
                    WHEN app.complianceScore <= 6 THEN 'Moderate'
                    WHEN app.complianceScore <= 8 THEN 'Low'
                    WHEN app.complianceScore <= 10 THEN 'Very Low'
                    ELSE ''
                END AS complianceRisk,
                apoc.map.fromPairs([key IN keys(app) WHERE key STARTS WITH 'Compliance' | [replace(key, 'Compliance', ''), app[key] = true]]) AS complianceList,
                CASE
                    WHEN app.securityScore <= 2 THEN 'Very High'
                    WHEN app.securityScore <= 4 THEN 'High'
                    WHEN app.securityScore <= 6 THEN 'Moderate'
                    WHEN app.securityScore <= 8 THEN 'Low'
                    WHEN app.securityScore <= 10 THEN 'Very Low'
                    ELSE ''
                END AS securityRisk,
                apoc.map.fromPairs([key IN keys(app) WHERE key STARTS WITH 'Security' | [replace(key, 'Security', ''), app[key] = true]]) AS securitySupportedList,
                app.SecuritySupportsSAML = true AS isSamlSupported,
                app.isMfaSupported = true AS isMfaSupported,
                CASE
                    WHEN 'High' IN severities THEN 'High'
                    WHEN 'Medium' IN severities THEN 'Medium'
                    ELSE 'Low'
                END AS severityRisk,
                apoc.map.fromPairs([
                    ['High', SIZE([x IN severities WHERE toLower(x) = 'high'])],
                    ['Medium', SIZE([x IN severities WHERE toLower(x) = 'medium'])],
                    ['Low', SIZE([x IN severities WHERE toLower(x) = 'low'])]
                ]) AS oauthSeverity,
                apoc.map.fromPairs([
                    ['breachDate', app.breachDate * 1000],
                    ['breachDataClasses', app.breachDataClasses]
                ]) AS breachData,
                sensitiveDataClasses,
                COLLECT(DISTINCT alternative_app.name) AS alternativeApps,
                totalFindings,
                actionedCount,
                pendingCount,
                combinedActionTracker AS actionTracker,
                combinedActionOutcomes AS actionOutcomes"
  - id: apps_detailed_BID_16
    name: "Breached app usage Detailed"
    label: Widget
    template: this_template
    enabled: true
    type: drilldown_widget
    widget_type: drilldown_widget
    dataSourceType: knowledgegraph
    allowed_params: true
    className: col-span-1
    query_id: ""
    input_params:
      endtime: $endtime
      appId: $appId
      behavior: $behavior
    queryFilters: []
    query: "MATCH (app:APPLICATION {id_: $appId})
            MATCH (app)-[:USING_APP]-(account:ACCOUNT)-[]-(finding:FINDING)-[]-(rule:RULE)-[]-(behavior:BEHAVIOR {id: $behavior})
            MATCH (user:USER {subscriber: $subscriber, tenant: $tenant})-[]-(email:EMAIL)-[auth_type]-(account)
            
            OPTIONAL MATCH (app)-[]-(grant:GRANT)-[]-(scope:SCOPE)
            WHERE toLower(scope.severity) IN ['high', 'medium', 'low']
            OPTIONAL MATCH (app)-[has:HAS_APP_SETTINGS]-(tenant:TENANT {id: $tenant})
            OPTIONAL MATCH (finding)-[:TRIGGERED]-(action:ACTION)
            OPTIONAL MATCH (action)-[:RESULTED_IN]-(outcome:OUTCOME)
            OPTIONAL MATCH (finding)-[:HAS_ARTIFACT]->(dlp:DLP_FINAL_CLASS | DLP_ORIGINAL_CLASS)
            
            OPTIONAL MATCH (category)<-[:HAS_APP_CATEGORY]-(alternative_app:APPLICATION)-[has1:HAS_APP_SETTINGS]-(:TENANT {id: $tenant})
            WHERE COALESCE(has1.approval_status, alternative_app.approval_status, 'NOT SET') = 'APPROVED'
            
            WITH app, auth_type, account, COLLECT(DISTINCT scope.severity) as severities, has, finding, action, outcome, dlp, alternative_app
            
            WITH app, auth_type, account, severities, has, finding, action, dlp, alternative_app,
                COALESCE(action.name, '-') AS actionName,
                COUNT(DISTINCT action) AS actionCount,
                CASE WHEN action IS NOT NULL AND outcome IS NULL THEN 'Not Responded'
                    WHEN outcome IS NOT NULL THEN COALESCE(outcome.value, outcome.message, '-')
                END as outcomeValue
            WHERE actionName IS NOT NULL
            
            WITH app, auth_type, account, severities, has, finding, action, dlp, alternative_app, actionName, actionCount,
                outcomeValue, COUNT(outcomeValue) AS outcomeCount
            
            WITH app, auth_type, account, severities, has, finding, action, dlp, alternative_app, actionName, actionCount,
                apoc.map.fromPairs(COLLECT([outcomeValue, outcomeCount])) as outcomeMap
            
            WITH app, severities, has, alternative_app,
                COUNT(DISTINCT finding.id) as totalFindings,
                COUNT(DISTINCT CASE WHEN action IS NOT NULL THEN account.id END) as actionedCount,
                COUNT(DISTINCT CASE WHEN action IS NULL THEN account.id END) as pendingCount,
                MIN(COALESCE(
                    CASE WHEN account.creationTime <> '-' THEN account.creationTime ELSE NULL END, timestamp()
                )) AS firstAccessed,
                MAX(auth_type.last_access_time) AS lastAccessed,
                COLLECT(DISTINCT dlp.id) AS sensitiveDataClasses,
                apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, actionCount] END)) AS combinedActionTracker,
                apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, outcomeMap] END)) AS combinedActionOutcomes
            
            RETURN DISTINCT
                COALESCE(app.id_, app.internalId) AS id,
                COALESCE(app.name, app.domain, app.id) AS app,
                app.logoUrl AS appLogoUrl,
                app.description AS description,
                firstAccessed,
                lastAccessed,
                COALESCE(has.approval_status, 'Not Defined') AS approvalStatus,
                COALESCE(has.criticality, 'Not Defined') AS criticality,
                app.domain AS domain,
                CASE
                    WHEN app.complianceScore <= 2 THEN 'Very High'
                    WHEN app.complianceScore <= 4 THEN 'High'
                    WHEN app.complianceScore <= 6 THEN 'Moderate'
                    WHEN app.complianceScore <= 8 THEN 'Low'
                    WHEN app.complianceScore <= 10 THEN 'Very Low'
                    ELSE ''
                END AS complianceRisk,
                apoc.map.fromPairs([key IN keys(app) WHERE key STARTS WITH 'Compliance' | [replace(key, 'Compliance', ''), app[key] = true]]) AS complianceList,
                CASE
                    WHEN app.securityScore <= 2 THEN 'Very High'
                    WHEN app.securityScore <= 4 THEN 'High'
                    WHEN app.securityScore <= 6 THEN 'Moderate'
                    WHEN app.securityScore <= 8 THEN 'Low'
                    WHEN app.securityScore <= 10 THEN 'Very Low'
                    ELSE ''
                END AS securityRisk,
                apoc.map.fromPairs([key IN keys(app) WHERE key STARTS WITH 'Security' | [replace(key, 'Security', ''), app[key] = true]]) AS securitySupportedList,
                app.SecuritySupportsSAML = true AS isSamlSupported,
                app.isMfaSupported = true AS isMfaSupported,
                CASE
                    WHEN 'High' IN severities THEN 'High'
                    WHEN 'Medium' IN severities THEN 'Medium'
                    ELSE 'Low'
                END AS severityRisk,
                apoc.map.fromPairs([
                    ['High', SIZE([x IN severities WHERE toLower(x) = 'high'])],
                    ['Medium', SIZE([x IN severities WHERE toLower(x) = 'medium'])],
                    ['Low', SIZE([x IN severities WHERE toLower(x) = 'low'])]
                ]) AS oauthSeverity,
                apoc.map.fromPairs([
                    ['breachDate', app.breachDate * 1000],
                    ['breachDataClasses', app.breachDataClasses]
                ]) AS breachData,
                sensitiveDataClasses,
                COLLECT(DISTINCT alternative_app.name) AS alternativeApps,
                totalFindings,
                actionedCount,
                pendingCount,
                combinedActionTracker AS actionTracker,
                combinedActionOutcomes AS actionOutcomes"
  - id: apps_detailed_BID_22
    name: "Blocked SaaS Apps Detailed"
    label: Widget
    template: this_template
    enabled: true
    type: drilldown_widget
    widget_type: drilldown_widget
    dataSourceType: knowledgegraph
    allowed_params: true
    className: col-span-1
    query_id: ""
    input_params:
      endtime: $endtime
      appId: $appId
      behavior: $behavior
    queryFilters: []
    query: "MATCH (app:APPLICATION {id_: $appId})
            MATCH (app)-[:USING_APP]-(account:ACCOUNT)-[]-(finding:FINDING)-[]-(rule:RULE)-[]-(behavior:BEHAVIOR {id: $behavior})
            MATCH (user:USER {subscriber: $subscriber, tenant: $tenant})-[]-(email:EMAIL)-[auth_type]-(account)
            
            OPTIONAL MATCH (app)-[]-(grant:GRANT)-[]-(scope:SCOPE)
            WHERE toLower(scope.severity) IN ['high', 'medium', 'low']
            OPTIONAL MATCH (app)-[has:HAS_APP_SETTINGS]-(tenant:TENANT {id: $tenant})
            OPTIONAL MATCH (finding)-[:TRIGGERED]-(action:ACTION)
            OPTIONAL MATCH (action)-[:RESULTED_IN]-(outcome:OUTCOME)
            OPTIONAL MATCH (finding)-[:HAS_ARTIFACT]->(dlp:DLP_FINAL_CLASS | DLP_ORIGINAL_CLASS)
            
            WITH app, auth_type, account, COLLECT(DISTINCT scope.severity) as severities, has, finding, action, outcome, dlp
            
            WITH app, auth_type, account, severities, has, finding, action, dlp,
                COALESCE(action.name, '-') AS actionName,
                COUNT(DISTINCT action) AS actionCount,
                CASE WHEN action IS NOT NULL AND outcome IS NULL THEN 'Not Responded'
                    WHEN outcome IS NOT NULL THEN COALESCE(outcome.value, outcome.message, '-')
                END as outcomeValue
            WHERE actionName IS NOT NULL
            
            WITH app, auth_type, account, severities, has, finding, action, dlp, actionName, actionCount,
                outcomeValue, COUNT(outcomeValue) AS outcomeCount
            
            WITH app, auth_type, account, severities, has, finding, action, dlp, actionName, actionCount,
                apoc.map.fromPairs(COLLECT([outcomeValue, outcomeCount])) as outcomeMap
            
            WITH app, severities, has,
                COUNT(DISTINCT finding.id) as totalFindings,
                COUNT(DISTINCT CASE WHEN action IS NOT NULL THEN finding.id END) as actionedCount,
                COUNT(DISTINCT CASE WHEN action IS NULL THEN finding.id END) as pendingCount,
                MIN(COALESCE(
                    CASE WHEN account.creationTime <> '-' THEN account.creationTime ELSE NULL END, timestamp()
                )) AS firstAccessed,
                MAX(auth_type.last_access_time) AS lastAccessed,
                COLLECT(DISTINCT dlp.id) AS sensitiveDataClasses,
                apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, actionCount] END)) AS combinedActionTracker,
                apoc.map.fromPairs(COLLECT(CASE WHEN actionName <> '-' THEN [actionName, outcomeMap] END)) AS combinedActionOutcomes
            
            RETURN DISTINCT
                COALESCE(app.id_, app.internalId) AS id,
                COALESCE(app.name, app.domain, app.id) AS app,
                app.logoUrl AS appLogoUrl,
                app.description AS description,
                firstAccessed,
                lastAccessed,
                COALESCE(has.approval_status, 'Not Defined') AS approvalStatus,
                COALESCE(has.criticality, 'Not Defined') AS criticality,
                app.domain AS domain,
                CASE
                    WHEN app.complianceScore <= 2 THEN 'Very High'
                    WHEN app.complianceScore <= 4 THEN 'High'
                    WHEN app.complianceScore <= 6 THEN 'Moderate'
                    WHEN app.complianceScore <= 8 THEN 'Low'
                    WHEN app.complianceScore <= 10 THEN 'Very Low'
                    ELSE ''
                END AS complianceRisk,
                apoc.map.fromPairs([key IN keys(app) WHERE key STARTS WITH 'Compliance' | [replace(key, 'Compliance', ''), app[key] = true]]) AS complianceList,
                CASE
                    WHEN app.securityScore <= 2 THEN 'Very High'
                    WHEN app.securityScore <= 4 THEN 'High'
                    WHEN app.securityScore <= 6 THEN 'Moderate'
                    WHEN app.securityScore <= 8 THEN 'Low'
                    WHEN app.securityScore <= 10 THEN 'Very Low'
                    ELSE ''
                END AS securityRisk,
                apoc.map.fromPairs([key IN keys(app) WHERE key STARTS WITH 'Security' | [replace(key, 'Security', ''), app[key] = true]]) AS securitySupportedList,
                app.SecuritySupportsSAML = true AS isSamlSupported,
                app.isMfaSupported = true AS isMfaSupported,
                CASE
                    WHEN 'High' IN severities THEN 'High'
                    WHEN 'Medium' IN severities THEN 'Medium'
                    ELSE 'Low'
                END AS severityRisk,
                apoc.map.fromPairs([
                    ['High', SIZE([x IN severities WHERE toLower(x) = 'high'])],
                    ['Medium', SIZE([x IN severities WHERE toLower(x) = 'medium'])],
                    ['Low', SIZE([x IN severities WHERE toLower(x) = 'low'])]
                ]) AS oauthSeverity,
                apoc.map.fromPairs([
                    ['breachDate', app.breachDate],
                    ['breachDataClasses', app.breachDataClasses]
                ]) AS breachData,
                sensitiveDataClasses,
                totalFindings,
                actionedCount,
                pendingCount,
                combinedActionTracker AS actionTracker,
                combinedActionOutcomes AS actionOutcomes"
table_render:
  table_additional_data:
    no_hover: true
    row_border: true
    alternate_row_colors: true
    no_table_padding: true
    table_heading_bg: bg-dark-300
    table_filters_wrapper_class: grid grid-cols-12
    no_calendar: true
    no_drilldown: true
  table_filters:
    risk_level:
      show_in_view:
        - id: unapproved_ai_applications
          is_default: false
        - id: ai_applications_with_risky_oauth_scopes
          is_default: false
        - id: newly_introduced_ai_users
          is_default: false
        - id: users_leaking_sensitive_data
          is_default: false
    criticality:
      show_in_view:
        - id: unapproved_ai_applications
          is_default: false
        - id: ai_applications_with_risky_oauth_scopes
          is_default: false
        - id: newly_introduced_ai_users
          is_default: false
        - id: users_leaking_sensitive_data
          is_default: false
    approval_status:
      show_in_view:
        - id: unapproved_ai_applications
          is_default: true
        - id: ai_applications_with_risky_oauth_scopes
          is_default: true
        - id: newly_introduced_ai_users
          is_default: true
        - id: users_leaking_sensitive_data
          is_default: true
    number_of_accounts:
      show_in_view:
        - id: unapproved_ai_applications
          is_default: true
        - id: ai_applications_with_risky_oauth_scopes
          is_default: true
        - id: newly_introduced_ai_users
          is_default: true
        - id: users_leaking_sensitive_data
          is_default: true
    technical_owner:
      show_in_view:
        - id: unapproved_ai_applications
          is_default: false
        - id: ai_applications_with_risky_oauth_scopes
          is_default: false
        - id: newly_introduced_ai_users
          is_default: false
        - id: users_leaking_sensitive_data
          is_default: false
    newly_discovered:
      show_in_view:
        - id: unapproved_ai_applications
          is_default: false
        - id: ai_applications_with_risky_oauth_scopes
          is_default: false
        - id: newly_introduced_ai_users
          is_default: false
        - id: users_leaking_sensitive_data
          is_default: false
    usage_level:
      show_in_view:
        - id: unapproved_ai_applications
          is_default: false
        - id: ai_applications_with_risky_oauth_scopes
          is_default: false
        - id: newly_introduced_ai_users
          is_default: false
        - id: users_leaking_sensitive_data
          is_default: false
    finding_status:
      show_in_view:
        - id: unapproved_ai_applications
          is_default: true
        - id: ai_applications_with_risky_oauth_scopes
          is_default: true
        - id: newly_introduced_ai_users
          is_default: true
        - id: users_leaking_sensitive_data
          is_default: true
    sensitive_data:
      show_in_view:
        - id: unapproved_ai_applications
          is_default: true
        - id: ai_applications_with_risky_oauth_scopes
          is_default: true
        - id: newly_introduced_ai_users
          is_default: true
        - id: users_leaking_sensitive_data
          is_default: true
    risky_oauth_scopes:
      show_in_view:
        - id: unapproved_ai_applications
          is_default: true
        - id: ai_applications_with_risky_oauth_scopes
          is_default: true
        - id: newly_introduced_ai_users
          is_default: true
        - id: users_leaking_sensitive_data
          is_default: true
    oauth_scope_risk_level:
      show_in_view:
        - id: unapproved_ai_applications
          is_default: true
        - id: ai_applications_with_risky_oauth_scopes
          is_default: true
        - id: newly_introduced_ai_users
          is_default: true
        - id: users_leaking_sensitive_data
          is_default: true
    granted_by:
      show_in_view:
        - id: unapproved_ai_applications
          is_default: true
        - id: ai_applications_with_risky_oauth_scopes
          is_default: true
        - id: newly_introduced_ai_users
          is_default: true
        - id: users_leaking_sensitive_data
          is_default: true
    grant_type:
      show_in_view:
        - id: unapproved_ai_applications
          is_default: true
        - id: ai_applications_with_risky_oauth_scopes
          is_default: true
        - id: newly_introduced_ai_users
          is_default: true
        - id: users_leaking_sensitive_data
          is_default: true
  table:
  unapproved_ai_applications:
  ai_applications_with_risky_oauth_scopes:
  newly_introduced_ai_users:
  users_leaking_sensitive_data:
pagination_query:
  query: ""
  dataSourceType: knowledgegraph
table_widget: []
